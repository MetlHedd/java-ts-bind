declare module 'java.time' {
import { TextStyle, DateTimeFormatter } from 'java.time.format';
import { Locale, Set, List, Map, Comparator } from 'java.util';
import { Enum, Comparable, RuntimeException, CharSequence, Throwable } from 'java.lang';
import { Pattern } from 'java.util.regex';
import { Serializable } from 'java.io';
import { ChronoPeriod, ChronoLocalDate, ChronoLocalDateTime, IsoEra, ChronoZonedDateTime, IsoChronology } from 'java.time.chrono';
import { ConcurrentMap } from 'java.util.concurrent';
import { Stream } from 'java.util.stream';
import { ZoneRules } from 'java.time.zone';
import { ValueRange, TemporalField, TemporalAccessor, Temporal, TemporalUnit, TemporalAmount, TemporalQuery, TemporalAdjuster } from 'java.time.temporal';
import { BigInteger } from 'java.math';
/**
 * A date-time without a time-zone in the ISO-8601 calendar system,
 * such as `2007-12-03T10:15:30`.
 * 
 * `LocalDateTime` is an immutable date-time object that represents a date-time,
 * often viewed as year-month-day-hour-minute-second. Other date and time fields,
 * such as day-of-year, day-of-week and week-of-year, can also be accessed.
 * Time is represented to nanosecond precision.
 * For example, the value "2nd October 2007 at 13:45.30.123456789" can be
 * stored in a `LocalDateTime`.
 * 
 * This class does not store or represent a time-zone.
 * Instead, it is a description of the date, as used for birthdays, combined with
 * the local time as seen on a wall clock.
 * It cannot represent an instant on the time-line without additional information
 * such as an offset or time-zone.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * For most applications written today, the ISO-8601 rules are entirely suitable.
 * However, any application that makes use of historical dates, and requires them
 * to be accurate will find the ISO-8601 approach unsuitable.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class LocalDateTime extends Temporal {
  /**
   * The minimum supported `LocalDateTime`, '-999999999-01-01T00:00:00'.
   * This is the local date-time of midnight at the start of the minimum date.
   * This combines {@link LocalDate#MIN} and {@link LocalTime#MIN}.
   * This could be used by an application as a "far past" date-time.
  */
  static readonly MIN: LocalDateTime;
  /**
   * The maximum supported `LocalDateTime`, '+999999999-12-31T23:59:59.999999999'.
   * This is the local date-time just before midnight at the end of the maximum date.
   * This combines {@link LocalDate#MAX} and {@link LocalTime#MAX}.
   * This could be used by an application as a "far future" date-time.
  */
  static readonly MAX: LocalDateTime;
  /**
   * Obtains the current date-time from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date-time.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date-time using the system clock and default time-zone, not null
  */
  static now(): LocalDateTime;
  /**
   * Obtains the current date-time from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date-time using the system clock, not null
  */
  static now(zone: ZoneId): LocalDateTime;
  /**
   * Obtains the current date-time from the specified clock.
   * 
   * This will query the specified clock to obtain the current date-time.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date-time, not null
  */
  static now(clock: Clock): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour and minute, setting the second and nanosecond to zero.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour and minute.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * The second and nanosecond fields will be set to zero.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, not null
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: Month, dayOfMonth: number, hour: number, minute: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour, minute and second, setting the nanosecond to zero.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour, minute and second.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * The nanosecond field will be set to zero.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, not null
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: Month, dayOfMonth: number, hour: number, minute: number, second: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour, minute, second and nanosecond.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour, minute, second and nanosecond.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, not null
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: Month, dayOfMonth: number, hour: number, minute: number, second: number, nanoOfSecond: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour and minute, setting the second and nanosecond to zero.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour and minute.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * The second and nanosecond fields will be set to zero.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number, hour: number, minute: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour, minute and second, setting the nanosecond to zero.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour, minute and second.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * The nanosecond field will be set to zero.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from year, month,
   * day, hour, minute, second and nanosecond.
   * 
   * This returns a `LocalDateTime` with the specified year, month,
   * day-of-month, hour, minute, second and nanosecond.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @return the local date-time, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, nanoOfSecond: number): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from a date and time.
   *
   * @param date  the local date, not null
   * @param time  the local time, not null
   * @return the local date-time, not null
  */
  static of(date: LocalDate, time: LocalTime): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from an `Instant` and zone ID.
   * 
   * This creates a local date-time based on the specified instant.
   * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
   * which is simple as there is only one valid offset for each instant.
   * Then, the instant and offset are used to calculate the local date-time.
   *
   * @param instant  the instant to create the date-time from, not null
   * @param zone  the time-zone, which may be an offset, not null
   * @return the local date-time, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  static ofInstant(instant: Instant, zone: ZoneId): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` using seconds from the
   * epoch of 1970-01-01T00:00:00Z.
   * 
   * This allows the {@link ChronoField#INSTANT_SECONDS epoch-second} field
   * to be converted to a local date-time. This is primarily intended for
   * low-level conversions rather than general application usage.
   *
   * @param epochSecond  the number of seconds from the epoch of 1970-01-01T00:00:00Z
   * @param nanoOfSecond  the nanosecond within the second, from 0 to 999,999,999
   * @param offset  the zone offset, not null
   * @return the local date-time, not null
   * @throws DateTimeException if the result exceeds the supported range,
   *  or if the nano-of-second is invalid
  */
  static ofEpochSecond(epochSecond: number, nanoOfSecond: number, offset: ZoneOffset): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from a temporal object.
   * 
   * This obtains a local date-time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `LocalDateTime`.
   * 
   * The conversion extracts and combines the `LocalDate` and the
   * `LocalTime` from the temporal object.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `LocalDateTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the local date-time, not null
   * @throws DateTimeException if unable to convert to a `LocalDateTime`
  */
  static from(temporal: TemporalAccessor): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from a text string such as `2007-12-03T10:15:30`.
   * 
   * The string must represent a valid date-time and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE_TIME}.
   *
   * @param text  the text to parse such as "2007-12-03T10:15:30", not null
   * @return the parsed local date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): LocalDateTime;
  /**
   * Obtains an instance of `LocalDateTime` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a date-time.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed local date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): LocalDateTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this date-time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `NANO_OF_DAY`
   * `MICRO_OF_SECOND`
   * `MICRO_OF_DAY`
   * `MILLI_OF_SECOND`
   * `MILLI_OF_DAY`
   * `SECOND_OF_MINUTE`
   * `SECOND_OF_DAY`
   * `MINUTE_OF_HOUR`
   * `MINUTE_OF_DAY`
   * `HOUR_OF_AMPM`
   * `CLOCK_HOUR_OF_AMPM`
   * `HOUR_OF_DAY`
   * `CLOCK_HOUR_OF_DAY`
   * `AMPM_OF_DAY`
   * `DAY_OF_WEEK`
   * `ALIGNED_DAY_OF_WEEK_IN_MONTH`
   * `ALIGNED_DAY_OF_WEEK_IN_YEAR`
   * `DAY_OF_MONTH`
   * `DAY_OF_YEAR`
   * `EPOCH_DAY`
   * `ALIGNED_WEEK_OF_MONTH`
   * `ALIGNED_WEEK_OF_YEAR`
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this date-time, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * `DAYS`
   * `WEEKS`
   * `MONTHS`
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This date-time is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this date-time as an `int`.
   * 
   * This queries this date-time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time, except `NANO_OF_DAY`, `MICRO_OF_DAY`,
   * `EPOCH_DAY` and `PROLEPTIC_MONTH` which are too large to fit in
   * an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this date-time as a `long`.
   * 
   * This queries this date-time for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the `LocalDate` part of this date-time.
   * 
   * This returns a `LocalDate` with the same year, month and day
   * as this date-time.
   *
   * @return the date part of this date-time, not null
  */
  toLocalDate(): LocalDate;
  /**
   * Gets the year field.
   * 
   * This method returns the primitive `int` value for the year.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.
   *
   * @return the year, from MIN_YEAR to MAX_YEAR
  */
  get year(): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Gets the day-of-month field.
   * 
   * This method returns the primitive `int` value for the day-of-month.
   *
   * @return the day-of-month, from 1 to 31
  */
  get dayOfMonth(): number;
  /**
   * Gets the day-of-year field.
   * 
   * This method returns the primitive `int` value for the day-of-year.
   *
   * @return the day-of-year, from 1 to 365, or 366 in a leap year
  */
  get dayOfYear(): number;
  /**
   * Gets the day-of-week field, which is an enum `DayOfWeek`.
   * 
   * This method returns the enum {@link DayOfWeek} for the day-of-week.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link DayOfWeek#getValue() int value}.
   * 
   * Additional information can be obtained from the `DayOfWeek`.
   * This includes textual names of the values.
   *
   * @return the day-of-week, not null
  */
  get dayOfWeek(): DayOfWeek;
  /**
   * Gets the `LocalTime` part of this date-time.
   * 
   * This returns a `LocalTime` with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Gets the hour-of-day field.
   *
   * @return the hour-of-day, from 0 to 23
  */
  get hour(): number;
  /**
   * Gets the minute-of-hour field.
   *
   * @return the minute-of-hour, from 0 to 59
  */
  get minute(): number;
  /**
   * Gets the second-of-minute field.
   *
   * @return the second-of-minute, from 0 to 59
  */
  get second(): number;
  /**
   * Gets the nano-of-second field.
   *
   * @return the nano-of-second, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this date-time.
   * 
   * This returns a `LocalDateTime`, based on this one, with the date-time adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the date to the last day of the month.
   * 
   * A selection of common adjustments is provided in
   * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
   * These include finding the "last day of the month" and "next Wednesday".
   * Key date-time classes also implement the `TemporalAdjuster` interface,
   * such as {@link Month} and {@link java.time.MonthDay MonthDay}.
   * The adjuster is responsible for handling special cases, such as the varying
   * lengths of month and leap years.
   * 
   * For example this code returns a date on the last day of July:
   *      *  import static java.time.Month.*;
   *  import static java.time.temporal.TemporalAdjusters.*;
   *
   *  result = localDateTime.with(JULY).with(lastDayOfMonth());
   * 
   * 
   * The classes {@link LocalDate} and {@link LocalTime} implement `TemporalAdjuster`,
   * thus this method can be used to change the date, time or offset:
   *      *  result = localDateTime.with(date);
   *  result = localDateTime.with(time);
   * 
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `LocalDateTime` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): LocalDateTime;
  /**
   * Returns a copy of this date-time with the specified field set to a new value.
   * 
   * This returns a `LocalDateTime`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the year, month or day-of-month.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * In some cases, changing the specified field can cause the resulting date-time to become invalid,
   * such as changing the month from 31st January to February would make the day-of-month invalid.
   * In cases like this, the field is responsible for resolving the date. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will behave as per
   * the matching method on {@link LocalDate#with(TemporalField, long) LocalDate}
   * or {@link LocalTime#with(TemporalField, long) LocalTime}.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `LocalDateTime` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the year altered.
   * 
   * The time does not affect the calculation and will be the same in the result.
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR
   * @return a `LocalDateTime` based on this date-time with the requested year, not null
   * @throws DateTimeException if the year value is invalid
  */
  withYear(year: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the month-of-year altered.
   * 
   * The time does not affect the calculation and will be the same in the result.
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)
   * @return a `LocalDateTime` based on this date-time with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the day-of-month altered.
   * 
   * If the resulting date-time is invalid, an exception is thrown.
   * The time does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31
   * @return a `LocalDateTime` based on this date-time with the requested day, not null
   * @throws DateTimeException if the day-of-month value is invalid,
   *  or if the day-of-month is invalid for the month-year
  */
  withDayOfMonth(dayOfMonth: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the day-of-year altered.
   * 
   * If the resulting date-time is invalid, an exception is thrown.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366
   * @return a `LocalDateTime` based on this date with the requested day, not null
   * @throws DateTimeException if the day-of-year value is invalid,
   *  or if the day-of-year is invalid for the year
  */
  withDayOfYear(dayOfYear: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the hour-of-day altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hour  the hour-of-day to set in the result, from 0 to 23
   * @return a `LocalDateTime` based on this date-time with the requested hour, not null
   * @throws DateTimeException if the hour value is invalid
  */
  withHour(hour: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the minute-of-hour altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minute  the minute-of-hour to set in the result, from 0 to 59
   * @return a `LocalDateTime` based on this date-time with the requested minute, not null
   * @throws DateTimeException if the minute value is invalid
  */
  withMinute(minute: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the second-of-minute altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param second  the second-of-minute to set in the result, from 0 to 59
   * @return a `LocalDateTime` based on this date-time with the requested second, not null
   * @throws DateTimeException if the second value is invalid
  */
  withSecond(second: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the nano-of-second altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
   * @return a `LocalDateTime` based on this date-time with the requested nanosecond, not null
   * @throws DateTimeException if the nano value is invalid
  */
  withNano(nanoOfSecond: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the time truncated.
   * 
   * Truncation returns a copy of the original date-time with fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
   * will set the second-of-minute and nano-of-second field to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return a `LocalDateTime` based on this date-time with the time truncated, not null
   * @throws DateTimeException if unable to truncate
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): LocalDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns a `LocalDateTime`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `LocalDateTime` based on this date-time with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): LocalDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns a `LocalDateTime`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * Date units are added as per {@link LocalDate#plus(long, TemporalUnit)}.
   * Time units are added as per {@link LocalTime#plus(long, TemporalUnit)} with
   * any overflow in days added equivalent to using {@link #plusDays(long)}.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `LocalDateTime` based on this date-time with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of years added.
   * 
   * This method adds the specified amount to the years field in three steps:
   * 
   * Add the input years to the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) plus one year would result in the
   * invalid date 2009-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2009-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the years added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusYears(years: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of months added.
   * 
   * This method adds the specified amount to the months field in three steps:
   * 
   * Add the input months to the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 plus one month would result in the invalid date
   * 2007-04-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-04-30, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the months added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMonths(months: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of weeks added.
   * 
   * This method adds the specified amount in weeks to the days field incrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one week would result in 2009-01-07.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the weeks added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusWeeks(weeks: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of days added.
   * 
   * This method adds the specified amount to the days field incrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one day would result in 2009-01-01.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the days added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusDays(days: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of hours added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the hours added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusHours(hours: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of minutes added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the minutes added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMinutes(minutes: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of seconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the seconds added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusSeconds(seconds: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of nanoseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to add, may be negative
   * @return a `LocalDateTime` based on this date-time with the nanoseconds added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusNanos(nanos: number): LocalDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns a `LocalDateTime`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `LocalDateTime` based on this date-time with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): LocalDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns a `LocalDateTime`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `LocalDateTime` based on this date-time with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of years subtracted.
   * 
   * This method subtracts the specified amount from the years field in three steps:
   * 
   * Subtract the input years from the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) minus one year would result in the
   * invalid date 2007-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the years subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusYears(years: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of months subtracted.
   * 
   * This method subtracts the specified amount from the months field in three steps:
   * 
   * Subtract the input months from the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 minus one month would result in the invalid date
   * 2007-02-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the months subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMonths(months: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of weeks subtracted.
   * 
   * This method subtracts the specified amount in weeks from the days field decrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-07 minus one week would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the weeks subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusWeeks(weeks: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of days subtracted.
   * 
   * This method subtracts the specified amount from the days field decrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-01 minus one day would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the days subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusDays(days: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of hours subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the hours subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusHours(hours: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of minutes subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the minutes subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMinutes(minutes: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of seconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the seconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusSeconds(seconds: number): LocalDateTime;
  /**
   * Returns a copy of this `LocalDateTime` with the specified number of nanoseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to subtract, may be negative
   * @return a `LocalDateTime` based on this date-time with the nanoseconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusNanos(nanos: number): LocalDateTime;
  /**
   * Queries this date-time using the specified query.
   * 
   * This queries this date-time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same date and time as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the date and time changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * twice, passing {@link ChronoField#EPOCH_DAY} and
   * {@link ChronoField#NANO_OF_DAY} as the fields.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisLocalDateTime.adjustInto(temporal);
   *   temporal = temporal.with(thisLocalDateTime);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another date-time in terms of the specified unit.
   * 
   * This calculates the amount of time between two `LocalDateTime`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date-time.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `LocalDateTime` using {@link #from(TemporalAccessor)}.
   * For example, the amount in days between two date-times can be calculated
   * using `startDateTime.until(endDateTime, DAYS)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two date-times.
   * For example, the amount in months between 2012-06-15T00:00 and 2012-08-14T23:59
   * will only be one month as it is one minute short of two months.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS` and `HALF_DAYS`, `DAYS`,
   * `WEEKS`, `MONTHS`, `YEARS`, `DECADES`,
   * `CENTURIES`, `MILLENNIA` and `ERAS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a `LocalDateTime`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date-time and the end date-time
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `LocalDateTime`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this date-time using the specified formatter.
   * 
   * This date-time will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date-time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this date-time with an offset to create an `OffsetDateTime`.
   * 
   * This returns an `OffsetDateTime` formed from this date-time at the specified offset.
   * All possible combinations of date-time and offset are valid.
   *
   * @param offset  the offset to combine with, not null
   * @return the offset date-time formed from this date-time and the specified offset, not null
  */
  atOffset(offset: ZoneOffset): OffsetDateTime;
  /**
   * Combines this date-time with a time-zone to create a `ZonedDateTime`.
   * 
   * This returns a `ZonedDateTime` formed from this date-time at the
   * specified time-zone. The result will match this date-time as closely as possible.
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may be adjusted.
   * 
   * The local date-time is resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, where clocks are set back, there are two valid offsets.
   * This method uses the earlier offset typically corresponding to "summer".
   * 
   * In the case of a gap, where clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   * 
   * To obtain the later offset during an overlap, call
   * {@link ZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.
   * To throw an exception when there is a gap or overlap, use
   * {@link ZonedDateTime#ofStrict(LocalDateTime, ZoneOffset, ZoneId)}.
   *
   * @param zone  the time-zone to use, not null
   * @return the zoned date-time formed from this date-time, not null
  */
  atZone(zone: ZoneId): ZonedDateTime;
  /**
   * Compares this date-time to another date-time.
   * 
   * The comparison is primarily based on the date-time, from earliest to latest.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * If all the date-times being compared are instances of `LocalDateTime`,
   * then the comparison will be entirely based on the date-time.
   * If some dates being compared are in different chronologies, then the
   * chronology is also considered, see {@link ChronoLocalDateTime#compareTo}.
   *
   * @param other  the other date-time to compare to, not null
   * @return the comparator value, that is the comparison of this local date-time with
   *          the `other` local date-time and this chronology with the `other` chronology,
   *          in order, returning the first non-zero result, and otherwise returning zero
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: ChronoLocalDateTime<any>): number;
  /**
   * Checks if this date-time is after the specified date-time.
   * 
   * This checks to see if this date-time represents a point on the
   * local time-line after the other date-time.
   *      *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);
   *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);
   *   a.isAfter(b) == false
   *   a.isAfter(a) == false
   *   b.isAfter(a) == true
   * 
   * 
   * This method only considers the position of the two date-times on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},
   * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this date-time is after the specified date-time
  */
  isAfter(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is before the specified date-time.
   * 
   * This checks to see if this date-time represents a point on the
   * local time-line before the other date-time.
   *      *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);
   *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);
   *   a.isBefore(b) == true
   *   a.isBefore(a) == false
   *   b.isBefore(a) == false
   * 
   * 
   * This method only considers the position of the two date-times on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},
   * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this date-time is before the specified date-time
  */
  isBefore(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is equal to the specified date-time.
   * 
   * This checks to see if this date-time represents the same point on the
   * local time-line as the other date-time.
   *      *   LocalDate a = LocalDateTime.of(2012, 6, 30, 12, 00);
   *   LocalDate b = LocalDateTime.of(2012, 7, 1, 12, 00);
   *   a.isEqual(b) == false
   *   a.isEqual(a) == true
   *   b.isEqual(a) == false
   * 
   * 
   * This method only considers the position of the two date-times on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDateTime)},
   * but is the same approach as {@link ChronoLocalDateTime#timeLineOrder()}.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this date-time is equal to the specified date-time
  */
  isEqual(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is equal to another date-time.
   * 
   * Compares this `LocalDateTime` with another ensuring that the date-time is the same.
   * Only objects of type `LocalDateTime` are compared, other types return false.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date-time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date-time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date-time as a `String`, such as `2007-12-03T10:15:30`.
   * 
   * The output will be one of the following ISO-8601 formats:
   * 
   * `uuuu-MM-dd'T'HH:mm`
   * `uuuu-MM-dd'T'HH:mm:ss`
   * `uuuu-MM-dd'T'HH:mm:ss.SSS`
   * `uuuu-MM-dd'T'HH:mm:ss.SSSSSS`
   * `uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSS`
   * 
   * The format used will be the shortest that outputs the full value of
   * the time where the omitted parts are implied to be zero.
   *
   * @return a string representation of this date-time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface LocalDateTime extends Temporal, TemporalAdjuster, ChronoLocalDateTime<LocalDate>, Serializable {}
/**
 * A year-month in the ISO-8601 calendar system, such as `2007-12`.
 * 
 * `YearMonth` is an immutable date-time object that represents the combination
 * of a year and month. Any field that can be derived from a year and month, such as
 * quarter-of-year, can be obtained.
 * 
 * This class does not store or represent a day, time or time-zone.
 * For example, the value "October 2007" can be stored in a `YearMonth`.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * For most applications written today, the ISO-8601 rules are entirely suitable.
 * However, any application that makes use of historical dates, and requires them
 * to be accurate will find the ISO-8601 approach unsuitable.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class YearMonth extends Temporal {
  /**
   * Obtains the current year-month from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current year-month.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current year-month using the system clock and default time-zone, not null
  */
  static now(): YearMonth;
  /**
   * Obtains the current year-month from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current year-month.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current year-month using the system clock, not null
  */
  static now(zone: ZoneId): YearMonth;
  /**
   * Obtains the current year-month from the specified clock.
   * 
   * This will query the specified clock to obtain the current year-month.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current year-month, not null
  */
  static now(clock: Clock): YearMonth;
  /**
   * Obtains an instance of `YearMonth` from a year and month.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, not null
   * @return the year-month, not null
   * @throws DateTimeException if the year value is invalid
  */
  static of(year: number, month: Month): YearMonth;
  /**
   * Obtains an instance of `YearMonth` from a year and month.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @return the year-month, not null
   * @throws DateTimeException if either field value is invalid
  */
  static of(year: number, month: number): YearMonth;
  /**
   * Obtains an instance of `YearMonth` from a temporal object.
   * 
   * This obtains a year-month based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `YearMonth`.
   * 
   * The conversion extracts the {@link ChronoField#YEAR YEAR} and
   * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} fields.
   * The extraction is only permitted if the temporal object has an ISO
   * chronology, or can be converted to a `LocalDate`.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `YearMonth::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the year-month, not null
   * @throws DateTimeException if unable to convert to a `YearMonth`
  */
  static from(temporal: TemporalAccessor): YearMonth;
  /**
   * Obtains an instance of `YearMonth` from a text string such as `2007-12`.
   * 
   * The string must represent a valid year-month.
   * The format must be `uuuu-MM`.
   * Years outside the range 0000 to 9999 must be prefixed by the plus or minus symbol.
   *
   * @param text  the text to parse such as "2007-12", not null
   * @return the parsed year-month, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): YearMonth;
  /**
   * Obtains an instance of `YearMonth` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a year-month.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed year-month, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): YearMonth;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this year-month can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this year-month, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this year-month.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `MONTHS`
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This year-month is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this year-month as an `int`.
   * 
   * This queries this year-month for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this year-month, except `PROLEPTIC_MONTH` which is too
   * large to fit in an `int` and throw a `DateTimeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this year-month as a `long`.
   * 
   * This queries this year-month for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this year-month.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the year field.
   * 
   * This method returns the primitive `int` value for the year.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   *
   * @return the year, from MIN_YEAR to MAX_YEAR
  */
  get year(): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Checks if the year is a leap year, according to the ISO proleptic
   * calendar system rules.
   * 
   * This method applies the current rules for leap years across the whole time-line.
   * In general, a year is a leap year if it is divisible by four without
   * remainder. However, years divisible by 100, are not leap years, with
   * the exception of years divisible by 400 which are.
   * 
   * For example, 1904 is a leap year it is divisible by 4.
   * 1900 was not a leap year as it is divisible by 100, however 2000 was a
   * leap year as it is divisible by 400.
   * 
   * The calculation is proleptic - applying the same rules into the far future and far past.
   * This is historically inaccurate, but is correct for the ISO-8601 standard.
   *
   * @return true if the year is leap, false otherwise
  */
  isLeapYear(): boolean;
  /**
   * Checks if the day-of-month is valid for this year-month.
   * 
   * This method checks whether this year and month and the input day form
   * a valid date.
   *
   * @param dayOfMonth  the day-of-month to validate, from 1 to 31, invalid value returns false
   * @return true if the day is valid for this year-month
  */
  isValidDay(dayOfMonth: number): boolean;
  /**
   * Returns the length of the month, taking account of the year.
   * 
   * This returns the length of the month in days.
   * For example, a date in January would return 31.
   *
   * @return the length of the month in days, from 28 to 31
  */
  lengthOfMonth(): number;
  /**
   * Returns the length of the year.
   * 
   * This returns the length of the year in days, either 365 or 366.
   *
   * @return 366 if the year is leap, 365 otherwise
  */
  lengthOfYear(): number;
  /**
   * Returns an adjusted copy of this year-month.
   * 
   * This returns a `YearMonth`, based on this one, with the year-month adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the year-month to the next month that
   * Halley's comet will pass the Earth.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `YearMonth` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): YearMonth;
  /**
   * Returns a copy of this year-month with the specified field set to a new value.
   * 
   * This returns a `YearMonth`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the year or month.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The supported fields behave as follows:
   * 
   * `MONTH_OF_YEAR` -
   *  Returns a `YearMonth` with the specified month-of-year.
   *  The year will be unchanged.
   * `PROLEPTIC_MONTH` -
   *  Returns a `YearMonth` with the specified proleptic-month.
   *  This completely replaces the year and month of this object.
   * `YEAR_OF_ERA` -
   *  Returns a `YearMonth` with the specified year-of-era
   *  The month and era will be unchanged.
   * `YEAR` -
   *  Returns a `YearMonth` with the specified year.
   *  The month will be unchanged.
   * `ERA` -
   *  Returns a `YearMonth` with the specified era.
   *  The month and year-of-era will be unchanged.
   * 
   * 
   * In all cases, if the new value is outside the valid range of values for the field
   * then a `DateTimeException` will be thrown.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `YearMonth` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the year altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to set in the returned year-month, from MIN_YEAR to MAX_YEAR
   * @return a `YearMonth` based on this year-month with the requested year, not null
   * @throws DateTimeException if the year value is invalid
  */
  withYear(year: number): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the month-of-year altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the returned year-month, from 1 (January) to 12 (December)
   * @return a `YearMonth` based on this year-month with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): YearMonth;
  /**
   * Returns a copy of this year-month with the specified amount added.
   * 
   * This returns a `YearMonth`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `YearMonth` based on this year-month with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): YearMonth;
  /**
   * Returns a copy of this year-month with the specified amount added.
   * 
   * This returns a `YearMonth`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The supported fields behave as follows:
   * 
   * `MONTHS` -
   *  Returns a `YearMonth` with the specified number of months added.
   *  This is equivalent to {@link #plusMonths(long)}.
   * `YEARS` -
   *  Returns a `YearMonth` with the specified number of years added.
   *  This is equivalent to {@link #plusYears(long)}.
   * `DECADES` -
   *  Returns a `YearMonth` with the specified number of decades added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 10.
   * `CENTURIES` -
   *  Returns a `YearMonth` with the specified number of centuries added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 100.
   * `MILLENNIA` -
   *  Returns a `YearMonth` with the specified number of millennia added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 1,000.
   * `ERAS` -
   *  Returns a `YearMonth` with the specified number of eras added.
   *  Only two eras are supported so the amount must be one, zero or minus one.
   *  If the amount is non-zero then the year is changed such that the year-of-era
   *  is unchanged.
   * 
   * 
   * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `YearMonth` based on this year-month with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the specified number of years added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToAdd  the years to add, may be negative
   * @return a `YearMonth` based on this year-month with the years added, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  plusYears(yearsToAdd: number): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the specified number of months added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToAdd  the months to add, may be negative
   * @return a `YearMonth` based on this year-month with the months added, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  plusMonths(monthsToAdd: number): YearMonth;
  /**
   * Returns a copy of this year-month with the specified amount subtracted.
   * 
   * This returns a `YearMonth`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `YearMonth` based on this year-month with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): YearMonth;
  /**
   * Returns a copy of this year-month with the specified amount subtracted.
   * 
   * This returns a `YearMonth`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `YearMonth` based on this year-month with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the specified number of years subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToSubtract  the years to subtract, may be negative
   * @return a `YearMonth` based on this year-month with the years subtracted, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  minusYears(yearsToSubtract: number): YearMonth;
  /**
   * Returns a copy of this `YearMonth` with the specified number of months subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToSubtract  the months to subtract, may be negative
   * @return a `YearMonth` based on this year-month with the months subtracted, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  minusMonths(monthsToSubtract: number): YearMonth;
  /**
   * Queries this year-month using the specified query.
   * 
   * This queries this year-month using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this year-month.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the year and month changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#PROLEPTIC_MONTH} as the field.
   * If the specified temporal object does not use the ISO calendar system then
   * a `DateTimeException` is thrown.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisYearMonth.adjustInto(temporal);
   *   temporal = temporal.with(thisYearMonth);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another year-month in terms of the specified unit.
   * 
   * This calculates the amount of time between two `YearMonth`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified year-month.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `YearMonth` using {@link #from(TemporalAccessor)}.
   * For example, the amount in years between two year-months can be calculated
   * using `startYearMonth.until(endYearMonth, YEARS)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two year-months.
   * For example, the amount in decades between 2012-06 and 2032-05
   * will only be one decade as it is one month short of two decades.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `MONTHS`, `YEARS`, `DECADES`,
   * `CENTURIES`, `MILLENNIA` and `ERAS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a `YearMonth`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this year-month and the end year-month
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `YearMonth`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this year-month using the specified formatter.
   * 
   * This year-month will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted year-month string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this year-month with a day-of-month to create a `LocalDate`.
   * 
   * This returns a `LocalDate` formed from this year-month and the specified day-of-month.
   * 
   * The day-of-month value must be valid for the year-month.
   * 
   * This method can be used as part of a chain to produce a date:
   *      *  LocalDate date = year.atMonth(month).atDay(day);
   * 
   *
   * @param dayOfMonth  the day-of-month to use, from 1 to 31
   * @return the date formed from this year-month and the specified day, not null
   * @throws DateTimeException if the day is invalid for the year-month
   * @see #isValidDay(int)
  */
  atDay(dayOfMonth: number): LocalDate;
  /**
   * Returns a `LocalDate` at the end of the month.
   * 
   * This returns a `LocalDate` based on this year-month.
   * The day-of-month is set to the last valid day of the month, taking
   * into account leap years.
   * 
   * This method can be used as part of a chain to produce a date:
   *      *  LocalDate date = year.atMonth(month).atEndOfMonth();
   * 
   *
   * @return the last valid date of this year-month, not null
  */
  atEndOfMonth(): LocalDate;
  /**
   * Compares this year-month to another year-month.
   * 
   * The comparison is based first on the value of the year, then on the value of the month.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other year-month to compare to, not null
   * @return the comparator value, that is less than zero if this is before `other`,
   *          zero if they are equal, greater than zero if this is after `other`
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: YearMonth): number;
  /**
   * Checks if this year-month is after the specified year-month.
   *
   * @param other  the other year-month to compare to, not null
   * @return true if this is after the specified year-month
  */
  isAfter(other: YearMonth): boolean;
  /**
   * Checks if this year-month is before the specified year-month.
   *
   * @param other  the other year-month to compare to, not null
   * @return true if this point is before the specified year-month
  */
  isBefore(other: YearMonth): boolean;
  /**
   * Checks if this year-month is equal to another year-month.
   * 
   * The comparison is based on the time-line position of the year-months.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other year-month
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this year-month.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this year-month as a `String`, such as `2007-12`.
   * 
   * The output will be in the format `uuuu-MM`:
   *
   * @return a string representation of this year-month, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface YearMonth extends Temporal, TemporalAdjuster, Comparable<YearMonth>, Serializable {}
/**
 * Provides access to the current instant.
 * 
 * Instances of this interface are used to access a pluggable representation of the current instant.
 * For example, `InstantSource` can be used instead of {@link System#currentTimeMillis()}.
 * 
 * The primary purpose of this abstraction is to allow alternate instant sources to be
 * plugged in as and when required. Applications use an object to obtain the
 * current time rather than a static method. This can simplify testing.
 * 
 * As such, this interface does not guarantee the result actually represents the current instant
 * on the time-line. Instead, it allows the application to provide a controlled view as to what
 * the current instant is.
 * 
 * Best practice for applications is to pass an `InstantSource` into any method
 * that requires the current instant. A dependency injection framework is one
 * way to achieve this:
 *  *  public class MyBean {
 *    private InstantSource source;  // dependency inject
 *    ...
 *    public void process(Instant endInstant) {
 *      if (source.instant().isAfter(endInstant) {
 *        ...
 *      }
 *    }
 *  }
 * 
 * This approach allows an alternative source, such as {@link #fixed(Instant) fixed}
 * or {@link #offset(InstantSource, Duration) offset} to be used during testing.
 * 
 * The `system` factory method provides a source based on the best available
 * system clock. This may use {@link System#currentTimeMillis()}, or a higher
 * resolution clock if one is available.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations must be thread-safe - a single instance must be capable of be invoked
 * from multiple threads without negative consequences such as race conditions.
 * 
 * The principal methods are defined to allow the throwing of an exception.
 * In normal use, no exceptions will be thrown, however one possible implementation would be to
 * obtain the time from a central time server across the network. Obviously, in this case the
 * lookup could fail, and so the method is permitted to throw an exception.
 * 
 * The returned instants from `InstantSource` work on a time-scale that ignores leap seconds,
 * as described in {@link Instant}. If the implementation wraps a source that provides leap
 * second information, then a mechanism should be used to "smooth" the leap second.
 * The Java Time-Scale mandates the use of UTC-SLS, however implementations may choose
 * how accurate they are with the time-scale so long as they document how they work.
 * Implementations are therefore not required to actually perform the UTC-SLS slew or to
 * otherwise be aware of leap seconds.
 * 
 * Implementations should implement `Serializable` wherever possible and must
 * document whether or not they do support serialization.
 *
 * @implNote
 * The implementation provided here is based on the same underlying system clock
 * as {@link System#currentTimeMillis()}, but may have a precision finer than
 * milliseconds if available.
 * However, little to no guarantee is provided about the accuracy of the
 * underlying system clock. Applications requiring a more accurate system clock must
 * implement this abstract class themselves using a different external system clock,
 * such as an NTP server.
 *
 * @since 17
*/
export class InstantSource {
  /**
   * Obtains a source that returns the current instant using the best available
   * system clock.
   * 
   * This source is based on the best available system clock. This may use
   * {@link System#currentTimeMillis()}, or a higher resolution system clock if
   * one is available.
   * 
   * The returned implementation is immutable, thread-safe and
   * `Serializable`.
   *
   * @return a source that uses the best available system clock, not null
  */
  static system(): InstantSource;
  /**
   * Obtains a source that returns instants from the specified source truncated to
   * the nearest occurrence of the specified duration.
   * 
   * This source will only tick as per the specified duration. Thus, if the
   * duration is half a second, the source will return instants truncated to the
   * half second.
   * 
   * The tick duration must be positive. If it has a part smaller than a whole
   * millisecond, then the whole duration must divide into one second without
   * leaving a remainder. All normal tick durations will match these criteria,
   * including any multiple of hours, minutes, seconds and milliseconds, and
   * sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.
   * 
   * A duration of zero or one nanosecond would have no truncation effect. Passing
   * one of these will return the underlying source.
   * 
   * Implementations may use a caching strategy for performance reasons. As such,
   * it is possible that the start of the requested duration observed via this
   * source will be later than that observed directly via the underlying source.
   * 
   * The returned implementation is immutable, thread-safe and
   * `Serializable` providing that the base source is.
   *
   * @param baseSource  the base source to base the ticking source on, not null
   * @param tickDuration  the duration of each visible tick, not negative, not null
   * @return a source that ticks in whole units of the duration, not null
   * @throws IllegalArgumentException if the duration is negative, or has a
   *  part smaller than a whole millisecond such that the whole duration is not
   *  divisible into one second
   * @throws ArithmeticException if the duration is too large to be represented as nanos
  */
  static tick(baseSource: InstantSource, tickDuration: Duration): InstantSource;
  /**
   * Obtains a source that always returns the same instant.
   * 
   * This source simply returns the specified instant.
   * As such, it is not a source that represents the current instant.
   * The main use case for this is in testing, where the fixed source ensures
   * tests are not dependent on the current source.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   *
   * @param fixedInstant  the instant to use, not null
   * @return a source that always returns the same instant, not null
  */
  static fixed(fixedInstant: Instant): InstantSource;
  /**
   * Obtains a source that returns instants from the specified source with the
   * specified duration added.
   * 
   * This source wraps another source, returning instants that are later by the
   * specified duration. If the duration is negative, the instants will be
   * earlier than the current date and time.
   * The main use case for this is to simulate running in the future or in the past.
   * 
   * A duration of zero would have no offsetting effect.
   * Passing zero will return the underlying source.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`
   * providing that the base source is.
   *
   * @param baseSource  the base source to add the duration to, not null
   * @param offsetDuration  the duration to add, not null
   * @return a source based on the base source with the duration added, not null
  */
  static offset(baseSource: InstantSource, offsetDuration: Duration): InstantSource;
  /**
   * Gets the current instant of the source.
   * 
   * This returns an instant representing the current instant as defined by the source.
   *
   * @return the current instant from this source, not null
   * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
  */
  instant(): Instant;
  /**
   * Gets the current millisecond instant of the source.
   * 
   * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).
   * This is equivalent to the definition of {@link System#currentTimeMillis()}.
   * 
   * Most applications should avoid this method and use {@link Instant} to represent
   * an instant on the time-line rather than a raw millisecond value.
   * This method is provided to allow the use of the source in high performance use cases
   * where the creation of an object would be unacceptable.
   *
   * @implSpec
   * The default implementation calls {@link #instant()}.
   *
   * @return the current millisecond instant from this source, measured from
   *  the Java epoch of 1970-01-01T00:00Z (UTC), not null
   * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
  */
  millis(): number;
  /**
   * Returns a clock with the specified time-zone.
   * 
   * This returns a {@link Clock}, which is an extension of this interface
   * that combines this source and the specified time-zone.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`
   * providing that this source is.
   *
   * @implSpec
   * The default implementation returns an immutable, thread-safe and
   * `Serializable` subclass of {@link Clock} that combines this
   * source and the specified zone.
   *
   * @param zone  the time-zone to use, not null
   * @return a clock based on this source with the specified time-zone, not null
  */
  withZone(zone: ZoneId): Clock;
}
/**
 * A date without a time-zone in the ISO-8601 calendar system,
 * such as `2007-12-03`.
 * 
 * `LocalDate` is an immutable date-time object that represents a date,
 * often viewed as year-month-day. Other date fields, such as day-of-year,
 * day-of-week and week-of-year, can also be accessed.
 * For example, the value "2nd October 2007" can be stored in a `LocalDate`.
 * 
 * This class does not store or represent a time or time-zone.
 * Instead, it is a description of the date, as used for birthdays.
 * It cannot represent an instant on the time-line without additional information
 * such as an offset or time-zone.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * For most applications written today, the ISO-8601 rules are entirely suitable.
 * However, any application that makes use of historical dates, and requires them
 * to be accurate will find the ISO-8601 approach unsuitable.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class LocalDate extends Temporal {
  /**
   * The minimum supported `LocalDate`, '-999999999-01-01'.
   * This could be used by an application as a "far past" date.
  */
  static readonly MIN: LocalDate;
  /**
   * The maximum supported `LocalDate`, '+999999999-12-31'.
   * This could be used by an application as a "far future" date.
  */
  static readonly MAX: LocalDate;
  /**
   * The epoch year `LocalDate`, '1970-01-01'.
   *
   * @since 9
  */
  static readonly EPOCH: LocalDate;
  /**
   * Obtains the current date from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date using the system clock and default time-zone, not null
  */
  static now(): LocalDate;
  /**
   * Obtains the current date from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date using the system clock, not null
  */
  static now(zone: ZoneId): LocalDate;
  /**
   * Obtains the current date from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date, not null
  */
  static now(clock: Clock): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a year, month and day.
   * 
   * This returns a `LocalDate` with the specified year, month and day-of-month.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, not null
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @return the local date, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: Month, dayOfMonth: number): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a year, month and day.
   * 
   * This returns a `LocalDate` with the specified year, month and day-of-month.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @return the local date, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a year and day-of-year.
   * 
   * This returns a `LocalDate` with the specified year and day-of-year.
   * The day-of-year must be valid for the year, otherwise an exception will be thrown.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param dayOfYear  the day-of-year to represent, from 1 to 366
   * @return the local date, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-year is invalid for the year
  */
  static ofYearDay(year: number, dayOfYear: number): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from an `Instant` and zone ID.
   * 
   * This creates a local date based on the specified instant.
   * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
   * which is simple as there is only one valid offset for each instant.
   * Then, the instant and offset are used to calculate the local date.
   *
   * @param instant  the instant to create the date from, not null
   * @param zone  the time-zone, which may be an offset, not null
   * @return the local date, not null
   * @throws DateTimeException if the result exceeds the supported range
   * @since 9
  */
  static ofInstant(instant: Instant, zone: ZoneId): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from the epoch day count.
   * 
   * This returns a `LocalDate` with the specified epoch-day.
   * The {@link ChronoField#EPOCH_DAY EPOCH_DAY} is a simple incrementing count
   * of days where day 0 is 1970-01-01. Negative numbers represent earlier days.
   *
   * @param epochDay  the Epoch Day to convert, based on the epoch 1970-01-01
   * @return the local date, not null
   * @throws DateTimeException if the epoch day exceeds the supported date range
  */
  static ofEpochDay(epochDay: number): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a temporal object.
   * 
   * This obtains a local date based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `LocalDate`.
   * 
   * The conversion uses the {@link TemporalQueries#localDate()} query, which relies
   * on extracting the {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `LocalDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the local date, not null
   * @throws DateTimeException if unable to convert to a `LocalDate`
  */
  static from(temporal: TemporalAccessor): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a text string such as `2007-12-03`.
   * 
   * The string must represent a valid date and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_DATE}.
   *
   * @param text  the text to parse such as "2007-12-03", not null
   * @return the parsed local date, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): LocalDate;
  /**
   * Obtains an instance of `LocalDate` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a date.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed local date, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): LocalDate;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this date can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `DAY_OF_WEEK`
   * `ALIGNED_DAY_OF_WEEK_IN_MONTH`
   * `ALIGNED_DAY_OF_WEEK_IN_YEAR`
   * `DAY_OF_MONTH`
   * `DAY_OF_YEAR`
   * `EPOCH_DAY`
   * `ALIGNED_WEEK_OF_MONTH`
   * `ALIGNED_WEEK_OF_YEAR`
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this date, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `DAYS`
   * `WEEKS`
   * `MONTHS`
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This date is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this date as an `int`.
   * 
   * This queries this date for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date, except `EPOCH_DAY` and `PROLEPTIC_MONTH`
   * which are too large to fit in an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this date as a `long`.
   * 
   * This queries this date for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the chronology of this date, which is the ISO calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The ISO-8601 calendar system is the modern civil calendar system used today
   * in most of the world. It is equivalent to the proleptic Gregorian calendar
   * system, in which today's rules for leap years are applied for all time.
   *
   * @return the ISO chronology, not null
  */
  get chronology(): IsoChronology;
  /**
   * Gets the era applicable at this date.
   * 
   * The official ISO-8601 standard does not define eras, however `IsoChronology` does.
   * It defines two eras, 'CE' from year one onwards and 'BCE' from year zero backwards.
   * Since dates before the Julian-Gregorian cutover are not in line with history,
   * the cutover between 'BCE' and 'CE' is also not aligned with the commonly used
   * eras, often referred to using 'BC' and 'AD'.
   * 
   * Users of this class should typically ignore this method as it exists primarily
   * to fulfill the {@link ChronoLocalDate} contract where it is necessary to support
   * the Japanese calendar system.
   *
   * @return the IsoEra applicable at this date, not null
  */
  get era(): IsoEra;
  /**
   * Gets the year field.
   * 
   * This method returns the primitive `int` value for the year.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.
   *
   * @return the year, from MIN_YEAR to MAX_YEAR
  */
  get year(): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Gets the day-of-month field.
   * 
   * This method returns the primitive `int` value for the day-of-month.
   *
   * @return the day-of-month, from 1 to 31
  */
  get dayOfMonth(): number;
  /**
   * Gets the day-of-year field.
   * 
   * This method returns the primitive `int` value for the day-of-year.
   *
   * @return the day-of-year, from 1 to 365, or 366 in a leap year
  */
  get dayOfYear(): number;
  /**
   * Gets the day-of-week field, which is an enum `DayOfWeek`.
   * 
   * This method returns the enum {@link DayOfWeek} for the day-of-week.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link DayOfWeek#getValue() int value}.
   * 
   * Additional information can be obtained from the `DayOfWeek`.
   * This includes textual names of the values.
   *
   * @return the day-of-week, not null
  */
  get dayOfWeek(): DayOfWeek;
  /**
   * Checks if the year is a leap year, according to the ISO proleptic
   * calendar system rules.
   * 
   * This method applies the current rules for leap years across the whole time-line.
   * In general, a year is a leap year if it is divisible by four without
   * remainder. However, years divisible by 100, are not leap years, with
   * the exception of years divisible by 400 which are.
   * 
   * For example, 1904 is a leap year it is divisible by 4.
   * 1900 was not a leap year as it is divisible by 100, however 2000 was a
   * leap year as it is divisible by 400.
   * 
   * The calculation is proleptic - applying the same rules into the far future and far past.
   * This is historically inaccurate, but is correct for the ISO-8601 standard.
   *
   * @return true if the year is leap, false otherwise
  */
  isLeapYear(): boolean;
  /**
   * Returns the length of the month represented by this date.
   * 
   * This returns the length of the month in days.
   * For example, a date in January would return 31.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  /**
   * Returns the length of the year represented by this date.
   * 
   * This returns the length of the year in days, either 365 or 366.
   *
   * @return 366 if the year is leap, 365 otherwise
  */
  lengthOfYear(): number;
  /**
   * Returns an adjusted copy of this date.
   * 
   * This returns a `LocalDate`, based on this one, with the date adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the date to the last day of the month.
   * 
   * A selection of common adjustments is provided in
   * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
   * These include finding the "last day of the month" and "next Wednesday".
   * Key date-time classes also implement the `TemporalAdjuster` interface,
   * such as {@link Month} and {@link java.time.MonthDay MonthDay}.
   * The adjuster is responsible for handling special cases, such as the varying
   * lengths of month and leap years.
   * 
   * For example this code returns a date on the last day of July:
   *      *  import static java.time.Month.*;
   *  import static java.time.temporal.TemporalAdjusters.*;
   *
   *  result = localDate.with(JULY).with(lastDayOfMonth());
   * 
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `LocalDate` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): LocalDate;
  /**
   * Returns a copy of this date with the specified field set to a new value.
   * 
   * This returns a `LocalDate`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the year, month or day-of-month.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * In some cases, changing the specified field can cause the resulting date to become invalid,
   * such as changing the month from 31st January to February would make the day-of-month invalid.
   * In cases like this, the field is responsible for resolving the date. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The supported fields behave as follows:
   * 
   * `DAY_OF_WEEK` -
   *  Returns a `LocalDate` with the specified day-of-week.
   *  The date is adjusted up to 6 days forward or backward within the boundary
   *  of a Monday to Sunday week.
   * `ALIGNED_DAY_OF_WEEK_IN_MONTH` -
   *  Returns a `LocalDate` with the specified aligned-day-of-week.
   *  The date is adjusted to the specified month-based aligned-day-of-week.
   *  Aligned weeks are counted such that the first week of a given month starts
   *  on the first day of that month.
   *  This may cause the date to be moved up to 6 days into the following month.
   * `ALIGNED_DAY_OF_WEEK_IN_YEAR` -
   *  Returns a `LocalDate` with the specified aligned-day-of-week.
   *  The date is adjusted to the specified year-based aligned-day-of-week.
   *  Aligned weeks are counted such that the first week of a given year starts
   *  on the first day of that year.
   *  This may cause the date to be moved up to 6 days into the following year.
   * `DAY_OF_MONTH` -
   *  Returns a `LocalDate` with the specified day-of-month.
   *  The month and year will be unchanged. If the day-of-month is invalid for the
   *  year and month, then a `DateTimeException` is thrown.
   * `DAY_OF_YEAR` -
   *  Returns a `LocalDate` with the specified day-of-year.
   *  The year will be unchanged. If the day-of-year is invalid for the
   *  year, then a `DateTimeException` is thrown.
   * `EPOCH_DAY` -
   *  Returns a `LocalDate` with the specified epoch-day.
   *  This completely replaces the date and is equivalent to {@link #ofEpochDay(long)}.
   * `ALIGNED_WEEK_OF_MONTH` -
   *  Returns a `LocalDate` with the specified aligned-week-of-month.
   *  Aligned weeks are counted such that the first week of a given month starts
   *  on the first day of that month.
   *  This adjustment moves the date in whole week chunks to match the specified week.
   *  The result will have the same day-of-week as this date.
   *  This may cause the date to be moved into the following month.
   * `ALIGNED_WEEK_OF_YEAR` -
   *  Returns a `LocalDate` with the specified aligned-week-of-year.
   *  Aligned weeks are counted such that the first week of a given year starts
   *  on the first day of that year.
   *  This adjustment moves the date in whole week chunks to match the specified week.
   *  The result will have the same day-of-week as this date.
   *  This may cause the date to be moved into the following year.
   * `MONTH_OF_YEAR` -
   *  Returns a `LocalDate` with the specified month-of-year.
   *  The year will be unchanged. The day-of-month will also be unchanged,
   *  unless it would be invalid for the new month and year. In that case, the
   *  day-of-month is adjusted to the maximum valid value for the new month and year.
   * `PROLEPTIC_MONTH` -
   *  Returns a `LocalDate` with the specified proleptic-month.
   *  The day-of-month will be unchanged, unless it would be invalid for the new month
   *  and year. In that case, the day-of-month is adjusted to the maximum valid value
   *  for the new month and year.
   * `YEAR_OF_ERA` -
   *  Returns a `LocalDate` with the specified year-of-era.
   *  The era and month will be unchanged. The day-of-month will also be unchanged,
   *  unless it would be invalid for the new month and year. In that case, the
   *  day-of-month is adjusted to the maximum valid value for the new month and year.
   * `YEAR` -
   *  Returns a `LocalDate` with the specified year.
   *  The month will be unchanged. The day-of-month will also be unchanged,
   *  unless it would be invalid for the new month and year. In that case, the
   *  day-of-month is adjusted to the maximum valid value for the new month and year.
   * `ERA` -
   *  Returns a `LocalDate` with the specified era.
   *  The year-of-era and month will be unchanged. The day-of-month will also be unchanged,
   *  unless it would be invalid for the new month and year. In that case, the
   *  day-of-month is adjusted to the maximum valid value for the new month and year.
   * 
   * 
   * In all cases, if the new value is outside the valid range of values for the field
   * then a `DateTimeException` will be thrown.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `LocalDate` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the year altered.
   * 
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR
   * @return a `LocalDate` based on this date with the requested year, not null
   * @throws DateTimeException if the year value is invalid
  */
  withYear(year: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the month-of-year altered.
   * 
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)
   * @return a `LocalDate` based on this date with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the day-of-month altered.
   * 
   * If the resulting date is invalid, an exception is thrown.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31
   * @return a `LocalDate` based on this date with the requested day, not null
   * @throws DateTimeException if the day-of-month value is invalid,
   *  or if the day-of-month is invalid for the month-year
  */
  withDayOfMonth(dayOfMonth: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the day-of-year altered.
   * 
   * If the resulting date is invalid, an exception is thrown.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366
   * @return a `LocalDate` based on this date with the requested day, not null
   * @throws DateTimeException if the day-of-year value is invalid,
   *  or if the day-of-year is invalid for the year
  */
  withDayOfYear(dayOfYear: number): LocalDate;
  /**
   * Returns a copy of this date with the specified amount added.
   * 
   * This returns a `LocalDate`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `LocalDate` based on this date with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): LocalDate;
  /**
   * Returns a copy of this date with the specified amount added.
   * 
   * This returns a `LocalDate`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * In some cases, adding the amount can cause the resulting date to become invalid.
   * For example, adding one month to 31st January would result in 31st February.
   * In cases like this, the unit is responsible for resolving the date.
   * Typically it will choose the previous valid date, which would be the last valid
   * day of February in this example.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The supported fields behave as follows:
   * 
   * `DAYS` -
   *  Returns a `LocalDate` with the specified number of days added.
   *  This is equivalent to {@link #plusDays(long)}.
   * `WEEKS` -
   *  Returns a `LocalDate` with the specified number of weeks added.
   *  This is equivalent to {@link #plusWeeks(long)} and uses a 7 day week.
   * `MONTHS` -
   *  Returns a `LocalDate` with the specified number of months added.
   *  This is equivalent to {@link #plusMonths(long)}.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * `YEARS` -
   *  Returns a `LocalDate` with the specified number of years added.
   *  This is equivalent to {@link #plusYears(long)}.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * `DECADES` -
   *  Returns a `LocalDate` with the specified number of decades added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 10.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * `CENTURIES` -
   *  Returns a `LocalDate` with the specified number of centuries added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 100.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * `MILLENNIA` -
   *  Returns a `LocalDate` with the specified number of millennia added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 1,000.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * `ERAS` -
   *  Returns a `LocalDate` with the specified number of eras added.
   *  Only two eras are supported so the amount must be one, zero or minus one.
   *  If the amount is non-zero then the year is changed such that the year-of-era
   *  is unchanged.
   *  The day-of-month will be unchanged unless it would be invalid for the new
   *  month and year. In that case, the day-of-month is adjusted to the maximum
   *  valid value for the new month and year.
   * 
   * 
   * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `LocalDate` based on this date with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of years added.
   * 
   * This method adds the specified amount to the years field in three steps:
   * 
   * Add the input years to the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) plus one year would result in the
   * invalid date 2009-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2009-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToAdd  the years to add, may be negative
   * @return a `LocalDate` based on this date with the years added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusYears(yearsToAdd: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of months added.
   * 
   * This method adds the specified amount to the months field in three steps:
   * 
   * Add the input months to the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 plus one month would result in the invalid date
   * 2007-04-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-04-30, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToAdd  the months to add, may be negative
   * @return a `LocalDate` based on this date with the months added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMonths(monthsToAdd: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of weeks added.
   * 
   * This method adds the specified amount in weeks to the days field incrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one week would result in 2009-01-07.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeksToAdd  the weeks to add, may be negative
   * @return a `LocalDate` based on this date with the weeks added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusWeeks(weeksToAdd: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of days added.
   * 
   * This method adds the specified amount to the days field incrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one day would result in 2009-01-01.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToAdd  the days to add, may be negative
   * @return a `LocalDate` based on this date with the days added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusDays(daysToAdd: number): LocalDate;
  /**
   * Returns a copy of this date with the specified amount subtracted.
   * 
   * This returns a `LocalDate`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `LocalDate` based on this date with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): LocalDate;
  /**
   * Returns a copy of this date with the specified amount subtracted.
   * 
   * This returns a `LocalDate`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `LocalDate` based on this date with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of years subtracted.
   * 
   * This method subtracts the specified amount from the years field in three steps:
   * 
   * Subtract the input years from the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) minus one year would result in the
   * invalid date 2007-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToSubtract  the years to subtract, may be negative
   * @return a `LocalDate` based on this date with the years subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusYears(yearsToSubtract: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of months subtracted.
   * 
   * This method subtracts the specified amount from the months field in three steps:
   * 
   * Subtract the input months from the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 minus one month would result in the invalid date
   * 2007-02-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToSubtract  the months to subtract, may be negative
   * @return a `LocalDate` based on this date with the months subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMonths(monthsToSubtract: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of weeks subtracted.
   * 
   * This method subtracts the specified amount in weeks from the days field decrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-07 minus one week would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeksToSubtract  the weeks to subtract, may be negative
   * @return a `LocalDate` based on this date with the weeks subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusWeeks(weeksToSubtract: number): LocalDate;
  /**
   * Returns a copy of this `LocalDate` with the specified number of days subtracted.
   * 
   * This method subtracts the specified amount from the days field decrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-01 minus one day would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToSubtract  the days to subtract, may be negative
   * @return a `LocalDate` based on this date with the days subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusDays(daysToSubtract: number): LocalDate;
  /**
   * Queries this date using the specified query.
   * 
   * This queries this date using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same date as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the date changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#EPOCH_DAY} as the field.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisLocalDate.adjustInto(temporal);
   *   temporal = temporal.with(thisLocalDate);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `LocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `LocalDate` using {@link #from(TemporalAccessor)}.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in months between 2012-06-15 and 2012-08-14
   * will only be one month as it is one day short of two months.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * are supported. Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a `LocalDate`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `LocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Calculates the period between this date and another date as a `Period`.
   * 
   * This calculates the period between two dates in terms of years, months and days.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The negative sign will be the same in each of year, month and day.
   * 
   * The calculation is performed using the ISO calendar system.
   * If necessary, the input date will be converted to ISO.
   * 
   * The start date is included, but the end date is not.
   * The period is calculated by removing complete months, then calculating
   * the remaining number of days, adjusting to ensure that both have the same sign.
   * The number of months is then normalized into years and months based on a 12 month year.
   * A month is considered to be complete if the end day-of-month is greater
   * than or equal to the start day-of-month.
   * For example, from `2010-01-15` to `2011-03-18` is "1 year, 2 months and 3 days".
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link Period#between(LocalDate, LocalDate)}:
   *      *   // these two lines are equivalent
   *   period = start.until(end);
   *   period = Period.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   *
   * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null
   * @return the period between this date and the end date, not null
  */
  until(endDateExclusive: ChronoLocalDate): Period;
  /**
   * Returns a sequential ordered stream of dates. The returned stream starts from this date
   * (inclusive) and goes to `endExclusive` (exclusive) by an incremental step of 1 day.
   * 
   * This method is equivalent to `datesUntil(endExclusive, Period.ofDays(1))`.
   *
   * @param endExclusive  the end date, exclusive, not null
   * @return a sequential `Stream` for the range of `LocalDate` values
   * @throws IllegalArgumentException if end date is before this date
   * @since 9
  */
  datesUntil(endExclusive: LocalDate): Stream<LocalDate>;
  /**
   * Returns a sequential ordered stream of dates by given incremental step. The returned stream
   * starts from this date (inclusive) and goes to `endExclusive` (exclusive).
   * 
   * The n-th date which appears in the stream is equal to `this.plus(step.multipliedBy(n))`
   * (but the result of step multiplication never overflows). For example, if this date is
   * `2015-01-31`, the end date is `2015-05-01` and the step is 1 month, then the
   * stream contains `2015-01-31`, `2015-02-28`, `2015-03-31`, and
   * `2015-04-30`.
   *
   * @param endExclusive  the end date, exclusive, not null
   * @param step  the non-zero, non-negative `Period` which represents the step.
   * @return a sequential `Stream` for the range of `LocalDate` values
   * @throws IllegalArgumentException if step is zero, or `step.getDays()` and
   *             `step.toTotalMonths()` have opposite sign, or end date is before this date
   *             and step is positive, or end date is after this date and step is negative
   * @since 9
  */
  datesUntil(endExclusive: LocalDate, step: Period): Stream<LocalDate>;
  /**
   * Formats this date using the specified formatter.
   * 
   * This date will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this date with a time to create a `LocalDateTime`.
   * 
   * This returns a `LocalDateTime` formed from this date at the specified time.
   * All possible combinations of date and time are valid.
   *
   * @param time  the time to combine with, not null
   * @return the local date-time formed from this date and the specified time, not null
  */
  atTime(time: LocalTime): LocalDateTime;
  /**
   * Combines this date with a time to create a `LocalDateTime`.
   * 
   * This returns a `LocalDateTime` formed from this date at the
   * specified hour and minute.
   * The seconds and nanosecond fields will be set to zero.
   * The individual time fields must be within their valid range.
   * All possible combinations of date and time are valid.
   *
   * @param hour  the hour-of-day to use, from 0 to 23
   * @param minute  the minute-of-hour to use, from 0 to 59
   * @return the local date-time formed from this date and the specified time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  atTime(hour: number, minute: number): LocalDateTime;
  /**
   * Combines this date with a time to create a `LocalDateTime`.
   * 
   * This returns a `LocalDateTime` formed from this date at the
   * specified hour, minute and second.
   * The nanosecond field will be set to zero.
   * The individual time fields must be within their valid range.
   * All possible combinations of date and time are valid.
   *
   * @param hour  the hour-of-day to use, from 0 to 23
   * @param minute  the minute-of-hour to use, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @return the local date-time formed from this date and the specified time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  atTime(hour: number, minute: number, second: number): LocalDateTime;
  /**
   * Combines this date with a time to create a `LocalDateTime`.
   * 
   * This returns a `LocalDateTime` formed from this date at the
   * specified hour, minute, second and nanosecond.
   * The individual time fields must be within their valid range.
   * All possible combinations of date and time are valid.
   *
   * @param hour  the hour-of-day to use, from 0 to 23
   * @param minute  the minute-of-hour to use, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @return the local date-time formed from this date and the specified time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  atTime(hour: number, minute: number, second: number, nanoOfSecond: number): LocalDateTime;
  /**
   * Combines this date with an offset time to create an `OffsetDateTime`.
   * 
   * This returns an `OffsetDateTime` formed from this date at the specified time.
   * All possible combinations of date and time are valid.
   *
   * @param time  the time to combine with, not null
   * @return the offset date-time formed from this date and the specified time, not null
  */
  atTime(time: OffsetTime): OffsetDateTime;
  /**
   * Combines this date with the time of midnight to create a `LocalDateTime`
   * at the start of this date.
   * 
   * This returns a `LocalDateTime` formed from this date at the time of
   * midnight, 00:00, at the start of this date.
   *
   * @return the local date-time of midnight at the start of this date, not null
  */
  atStartOfDay(): LocalDateTime;
  /**
   * Returns a zoned date-time from this date at the earliest valid time according
   * to the rules in the time-zone.
   * 
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may not be midnight.
   * 
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, there are two valid offsets, and the earlier one is used,
   * corresponding to the first occurrence of midnight on the date.
   * In the case of a gap, the zoned date-time will represent the instant just after the gap.
   * 
   * If the zone ID is a {@link ZoneOffset}, then the result always has a time of midnight.
   * 
   * To convert to a specific time in a given time-zone call {@link #atTime(LocalTime)}
   * followed by {@link LocalDateTime#atZone(ZoneId)}.
   *
   * @param zone  the zone ID to use, not null
   * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null
  */
  atStartOfDay(zone: ZoneId): ZonedDateTime;
  /**
   * Converts this date to the Epoch Day.
   * 
   * The {@link ChronoField#EPOCH_DAY Epoch Day count} is a simple
   * incrementing count of days where day 0 is 1970-01-01 (ISO).
   * This definition is the same for all chronologies, enabling conversion.
   * 
   * This default implementation queries the `EPOCH_DAY` field.
   *
   * @return the Epoch Day equivalent to this date
  */
  toEpochDay(): number;
  /**
   * Converts this `LocalDate` to the number of seconds since the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * This combines this local date with the specified time and
   * offset to calculate the epoch-second value, which is the
   * number of elapsed seconds from 1970-01-01T00:00:00Z.
   * Instants on the time-line after the epoch are positive, earlier
   * are negative.
   *
   * @param time the local time, not null
   * @param offset the zone offset, not null
   * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
   * @since 9
  */
  toEpochSecond(time: LocalTime, offset: ZoneOffset): number;
  /**
   * Compares this date to another date.
   * 
   * The comparison is primarily based on the date, from earliest to latest.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * If all the dates being compared are instances of `LocalDate`,
   * then the comparison will be entirely based on the date.
   * If some dates being compared are in different chronologies, then the
   * chronology is also considered, see {@link java.time.chrono.ChronoLocalDate#compareTo}.
   *
   * @param other  the other date to compare to, not null
   * @return the comparator value, that is the comparison of this local date with
   *          the `other` local date and this chronology with the `other` chronology,
   *          in order, returning the first non-zero result, and otherwise returning zero
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: ChronoLocalDate): number;
  /**
   * Checks if this date is after the specified date.
   * 
   * This checks to see if this date represents a point on the
   * local time-line after the other date.
   *      *   LocalDate a = LocalDate.of(2012, 6, 30);
   *   LocalDate b = LocalDate.of(2012, 7, 1);
   *   a.isAfter(b) == false
   *   a.isAfter(a) == false
   *   b.isAfter(a) == true
   * 
   * 
   * This method only considers the position of the two dates on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},
   * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.
   *
   * @param other  the other date to compare to, not null
   * @return true if this date is after the specified date
  */
  isAfter(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is before the specified date.
   * 
   * This checks to see if this date represents a point on the
   * local time-line before the other date.
   *      *   LocalDate a = LocalDate.of(2012, 6, 30);
   *   LocalDate b = LocalDate.of(2012, 7, 1);
   *   a.isBefore(b) == true
   *   a.isBefore(a) == false
   *   b.isBefore(a) == false
   * 
   * 
   * This method only considers the position of the two dates on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDate)},
   * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.
   *
   * @param other  the other date to compare to, not null
   * @return true if this date is before the specified date
  */
  isBefore(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is equal to the specified date.
   * 
   * This checks to see if this date represents the same point on the
   * local time-line as the other date.
   *      *   LocalDate a = LocalDate.of(2012, 6, 30);
   *   LocalDate b = LocalDate.of(2012, 7, 1);
   *   a.isEqual(b) == false
   *   a.isEqual(a) == true
   *   b.isEqual(a) == false
   * 
   * 
   * This method only considers the position of the two dates on the local time-line.
   * It does not take into account the chronology, or calendar system.
   * This is different from the comparison in {@link #compareTo(ChronoLocalDate)}
   * but is the same approach as {@link ChronoLocalDate#timeLineOrder()}.
   *
   * @param other  the other date to compare to, not null
   * @return true if this date is equal to the specified date
  */
  isEqual(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is equal to another date.
   * 
   * Compares this `LocalDate` with another ensuring that the date is the same.
   * 
   * Only objects of type `LocalDate` are compared, other types return false.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date as a `String`, such as `2007-12-03`.
   * 
   * The output will be in the ISO-8601 format `uuuu-MM-dd`.
   *
   * @return a string representation of this date, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface LocalDate extends Temporal, TemporalAdjuster, ChronoLocalDate, Serializable {}
/**
 * A date-based amount of time in the ISO-8601 calendar system,
 * such as '2 years, 3 months and 4 days'.
 * 
 * This class models a quantity or amount of time in terms of years, months and days.
 * See {@link Duration} for the time-based equivalent to this class.
 * 
 * Durations and periods differ in their treatment of daylight savings time
 * when added to {@link ZonedDateTime}. A `Duration` will add an exact
 * number of seconds, thus a duration of one day is always exactly 24 hours.
 * By contrast, a `Period` will add a conceptual day, trying to maintain
 * the local time.
 * 
 * For example, consider adding a period of one day and a duration of one day to
 * 18:00 on the evening before a daylight savings gap. The `Period` will add
 * the conceptual day and result in a `ZonedDateTime` at 18:00 the following day.
 * By contrast, the `Duration` will add exactly 24 hours, resulting in a
 * `ZonedDateTime` at 19:00 the following day (assuming a one hour DST gap).
 * 
 * The supported units of a period are {@link ChronoUnit#YEARS YEARS},
 * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
 * All three fields are always present, but may be set to zero.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * 
 * The period is modeled as a directed amount of time, meaning that individual parts of the
 * period may be negative.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class Period extends ChronoPeriod {
  /**
   * A constant for a period of zero.
  */
  static readonly ZERO: Period;
  /**
   * Obtains a `Period` representing a number of years.
   * 
   * The resulting period will have the specified years.
   * The months and days units will be zero.
   *
   * @param years  the number of years, positive or negative
   * @return the period of years, not null
  */
  static ofYears(years: number): Period;
  /**
   * Obtains a `Period` representing a number of months.
   * 
   * The resulting period will have the specified months.
   * The years and days units will be zero.
   *
   * @param months  the number of months, positive or negative
   * @return the period of months, not null
  */
  static ofMonths(months: number): Period;
  /**
   * Obtains a `Period` representing a number of weeks.
   * 
   * The resulting period will be day-based, with the amount of days
   * equal to the number of weeks multiplied by 7.
   * The years and months units will be zero.
   *
   * @param weeks  the number of weeks, positive or negative
   * @return the period, with the input weeks converted to days, not null
  */
  static ofWeeks(weeks: number): Period;
  /**
   * Obtains a `Period` representing a number of days.
   * 
   * The resulting period will have the specified days.
   * The years and months units will be zero.
   *
   * @param days  the number of days, positive or negative
   * @return the period of days, not null
  */
  static ofDays(days: number): Period;
  /**
   * Obtains a `Period` representing a number of years, months and days.
   * 
   * This creates an instance based on years, months and days.
   *
   * @param years  the amount of years, may be negative
   * @param months  the amount of months, may be negative
   * @param days  the amount of days, may be negative
   * @return the period of years, months and days, not null
  */
  static of(years: number, months: number, days: number): Period;
  /**
   * Obtains an instance of `Period` from a temporal amount.
   * 
   * This obtains a period based on the specified amount.
   * A `TemporalAmount` represents an  amount of time, which may be
   * date-based or time-based, which this factory extracts to a `Period`.
   * 
   * The conversion loops around the set of units from the amount and uses
   * the {@link ChronoUnit#YEARS YEARS}, {@link ChronoUnit#MONTHS MONTHS}
   * and {@link ChronoUnit#DAYS DAYS} units to create a period.
   * If any other units are found then an exception is thrown.
   * 
   * If the amount is a `ChronoPeriod` then it must use the ISO chronology.
   *
   * @param amount  the temporal amount to convert, not null
   * @return the equivalent period, not null
   * @throws DateTimeException if unable to convert to a `Period`
   * @throws ArithmeticException if the amount of years, months or days exceeds an int
  */
  static from(amount: TemporalAmount): Period;
  /**
   * Obtains a `Period` from a text string such as `PnYnMnD`.
   * 
   * This will parse the string produced by `toString()` which is
   * based on the ISO-8601 period formats `PnYnMnD` and `PnW`.
   * 
   * The string starts with an optional sign, denoted by the ASCII negative
   * or positive symbol. If negative, the whole period is negated.
   * The ASCII letter "P" is next in upper or lower case.
   * There are then four sections, each consisting of a number and a suffix.
   * At least one of the four sections must be present.
   * The sections have suffixes in ASCII of "Y", "M", "W" and "D" for
   * years, months, weeks and days, accepted in upper or lower case.
   * The suffixes must occur in order.
   * The number part of each section must consist of ASCII digits.
   * The number may be prefixed by the ASCII negative or positive symbol.
   * The number must parse to an `int`.
   * 
   * The leading plus/minus sign, and negative values for other units are
   * not part of the ISO-8601 standard. In addition, ISO-8601 does not
   * permit mixing between the `PnYnMnD` and `PnW` formats.
   * Any week-based input is multiplied by 7 and treated as a number of days.
   * 
   * For example, the following are valid inputs:
   *      *   "P2Y"             -- Period.ofYears(2)
   *   "P3M"             -- Period.ofMonths(3)
   *   "P4W"             -- Period.ofWeeks(4)
   *   "P5D"             -- Period.ofDays(5)
   *   "P1Y2M3D"         -- Period.of(1, 2, 3)
   *   "P1Y2M3W4D"       -- Period.of(1, 2, 25)
   *   "P-1Y2M"          -- Period.of(-1, 2, 0)
   *   "-P1Y2M"          -- Period.of(-1, -2, 0)
   * 
   *
   * @param text  the text to parse, not null
   * @return the parsed period, not null
   * @throws DateTimeParseException if the text cannot be parsed to a period
  */
  static parse(text: CharSequence): Period;
  /**
   * Obtains a `Period` consisting of the number of years, months,
   * and days between two dates.
   * 
   * The start date is included, but the end date is not.
   * The period is calculated by removing complete months, then calculating
   * the remaining number of days, adjusting to ensure that both have the same sign.
   * The number of months is then split into years and months based on a 12 month year.
   * A month is considered if the end day-of-month is greater than or equal to the start day-of-month.
   * For example, from `2010-01-15` to `2011-03-18` is one year, two months and three days.
   * 
   * The result of this method can be a negative period if the end is before the start.
   * The negative sign will be the same in each of year, month and day.
   *
   * @param startDateInclusive  the start date, inclusive, not null
   * @param endDateExclusive  the end date, exclusive, not null
   * @return the period between this date and the end date, not null
   * @see ChronoLocalDate#until(ChronoLocalDate)
  */
  static between(startDateInclusive: LocalDate, endDateExclusive: LocalDate): Period;
  /**
   * Gets the value of the requested unit.
   * 
   * This returns a value for each of the three supported units,
   * {@link ChronoUnit#YEARS YEARS}, {@link ChronoUnit#MONTHS MONTHS} and
   * {@link ChronoUnit#DAYS DAYS}.
   * All other units throw an exception.
   *
   * @param unit the `TemporalUnit` for which to return the value
   * @return the long value of the unit
   * @throws DateTimeException if the unit is not supported
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  get(unit: TemporalUnit): number;
  /**
   * Gets the set of units supported by this period.
   * 
   * The supported units are {@link ChronoUnit#YEARS YEARS},
   * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
   * They are returned in the order years, months, days.
   * 
   * This set can be used in conjunction with {@link #get(TemporalUnit)}
   * to access the entire state of the period.
   *
   * @return a list containing the years, months and days units, not null
  */
  get units(): TemporalUnit[];
  /**
   * Gets the chronology of this period, which is the ISO calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The ISO-8601 calendar system is the modern civil calendar system used today
   * in most of the world. It is equivalent to the proleptic Gregorian calendar
   * system, in which today's rules for leap years are applied for all time.
   *
   * @return the ISO chronology, not null
  */
  get chronology(): IsoChronology;
  /**
   * Checks if all three units of this period are zero.
   * 
   * A zero period has the value zero for the years, months and days units.
   *
   * @return true if this period is zero-length
  */
  isZero(): boolean;
  /**
   * Checks if any of the three units of this period are negative.
   * 
   * This checks whether the years, months or days units are less than zero.
   *
   * @return true if any unit of this period is negative
  */
  isNegative(): boolean;
  /**
   * Gets the amount of years of this period.
   * 
   * This returns the years unit.
   * 
   * The months unit is not automatically normalized with the years unit.
   * This means that a period of "15 months" is different to a period
   * of "1 year and 3 months".
   *
   * @return the amount of years of this period, may be negative
  */
  get years(): number;
  /**
   * Gets the amount of months of this period.
   * 
   * This returns the months unit.
   * 
   * The months unit is not automatically normalized with the years unit.
   * This means that a period of "15 months" is different to a period
   * of "1 year and 3 months".
   *
   * @return the amount of months of this period, may be negative
  */
  get months(): number;
  /**
   * Gets the amount of days of this period.
   * 
   * This returns the days unit.
   *
   * @return the amount of days of this period, may be negative
  */
  get days(): number;
  /**
   * Returns a copy of this period with the specified amount of years.
   * 
   * This sets the amount of the years unit in a copy of this period.
   * The months and days units are unaffected.
   * 
   * The months unit is not automatically normalized with the years unit.
   * This means that a period of "15 months" is different to a period
   * of "1 year and 3 months".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to represent, may be negative
   * @return a `Period` based on this period with the requested years, not null
  */
  withYears(years: number): Period;
  /**
   * Returns a copy of this period with the specified amount of months.
   * 
   * This sets the amount of the months unit in a copy of this period.
   * The years and days units are unaffected.
   * 
   * The months unit is not automatically normalized with the years unit.
   * This means that a period of "15 months" is different to a period
   * of "1 year and 3 months".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to represent, may be negative
   * @return a `Period` based on this period with the requested months, not null
  */
  withMonths(months: number): Period;
  /**
   * Returns a copy of this period with the specified amount of days.
   * 
   * This sets the amount of the days unit in a copy of this period.
   * The years and months units are unaffected.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to represent, may be negative
   * @return a `Period` based on this period with the requested days, not null
  */
  withDays(days: number): Period;
  /**
   * Returns a copy of this period with the specified period added.
   * 
   * This operates separately on the years, months and days.
   * No normalization is performed.
   * 
   * For example, "1 year, 6 months and 3 days" plus "2 years, 2 months and 2 days"
   * returns "3 years, 8 months and 5 days".
   * 
   * The specified amount is typically an instance of `Period`.
   * Other types are interpreted using {@link Period#from(TemporalAmount)}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `Period` based on this period with the requested period added, not null
   * @throws DateTimeException if the specified amount has a non-ISO chronology or
   *  contains an invalid unit
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): Period;
  /**
   * Returns a copy of this period with the specified years added.
   * 
   * This adds the amount to the years unit in a copy of this period.
   * The months and days units are unaffected.
   * For example, "1 year, 6 months and 3 days" plus 2 years returns "3 years, 6 months and 3 days".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToAdd  the years to add, positive or negative
   * @return a `Period` based on this period with the specified years added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusYears(yearsToAdd: number): Period;
  /**
   * Returns a copy of this period with the specified months added.
   * 
   * This adds the amount to the months unit in a copy of this period.
   * The years and days units are unaffected.
   * For example, "1 year, 6 months and 3 days" plus 2 months returns "1 year, 8 months and 3 days".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToAdd  the months to add, positive or negative
   * @return a `Period` based on this period with the specified months added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusMonths(monthsToAdd: number): Period;
  /**
   * Returns a copy of this period with the specified days added.
   * 
   * This adds the amount to the days unit in a copy of this period.
   * The years and months units are unaffected.
   * For example, "1 year, 6 months and 3 days" plus 2 days returns "1 year, 6 months and 5 days".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToAdd  the days to add, positive or negative
   * @return a `Period` based on this period with the specified days added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusDays(daysToAdd: number): Period;
  /**
   * Returns a copy of this period with the specified period subtracted.
   * 
   * This operates separately on the years, months and days.
   * No normalization is performed.
   * 
   * For example, "1 year, 6 months and 3 days" minus "2 years, 2 months and 2 days"
   * returns "-1 years, 4 months and 1 day".
   * 
   * The specified amount is typically an instance of `Period`.
   * Other types are interpreted using {@link Period#from(TemporalAmount)}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `Period` based on this period with the requested period subtracted, not null
   * @throws DateTimeException if the specified amount has a non-ISO chronology or
   *  contains an invalid unit
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): Period;
  /**
   * Returns a copy of this period with the specified years subtracted.
   * 
   * This subtracts the amount from the years unit in a copy of this period.
   * The months and days units are unaffected.
   * For example, "1 year, 6 months and 3 days" minus 2 years returns "-1 years, 6 months and 3 days".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToSubtract  the years to subtract, positive or negative
   * @return a `Period` based on this period with the specified years subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusYears(yearsToSubtract: number): Period;
  /**
   * Returns a copy of this period with the specified months subtracted.
   * 
   * This subtracts the amount from the months unit in a copy of this period.
   * The years and days units are unaffected.
   * For example, "1 year, 6 months and 3 days" minus 2 months returns "1 year, 4 months and 3 days".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param monthsToSubtract  the years to subtract, positive or negative
   * @return a `Period` based on this period with the specified months subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusMonths(monthsToSubtract: number): Period;
  /**
   * Returns a copy of this period with the specified days subtracted.
   * 
   * This subtracts the amount from the days unit in a copy of this period.
   * The years and months units are unaffected.
   * For example, "1 year, 6 months and 3 days" minus 2 days returns "1 year, 6 months and 1 day".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToSubtract  the months to subtract, positive or negative
   * @return a `Period` based on this period with the specified days subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusDays(daysToSubtract: number): Period;
  /**
   * Returns a new instance with each element in this period multiplied
   * by the specified scalar.
   * 
   * This returns a period with each of the years, months and days units
   * individually multiplied.
   * For example, a period of "2 years, -3 months and 4 days" multiplied by
   * 3 will return "6 years, -9 months and 12 days".
   * No normalization is performed.
   *
   * @param scalar  the scalar to multiply by, not null
   * @return a `Period` based on this period with the amounts multiplied by the scalar, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  multipliedBy(scalar: number): Period;
  /**
   * Returns a new instance with each amount in this period negated.
   * 
   * This returns a period with each of the years, months and days units
   * individually negated.
   * For example, a period of "2 years, -3 months and 4 days" will be
   * negated to "-2 years, 3 months and -4 days".
   * No normalization is performed.
   *
   * @return a `Period` based on this period with the amounts negated, not null
   * @throws ArithmeticException if numeric overflow occurs, which only happens if
   *  one of the units has the value `Integer.MIN_VALUE`
  */
  negated(): Period;
  /**
   * Returns a copy of this period with the years and months normalized.
   * 
   * This normalizes the years and months units, leaving the days unit unchanged.
   * The months unit is adjusted to have an absolute value less than 12,
   * with the years unit being adjusted to compensate. For example, a period of
   * "1 Year and 15 months" will be normalized to "2 years and 3 months".
   * 
   * The sign of the years and months units will be the same after normalization.
   * For example, a period of "1 year and -25 months" will be normalized to
   * "-1 year and -1 month".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `Period` based on this period with excess months normalized to years, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  normalized(): Period;
  /**
   * Gets the total number of months in this period.
   * 
   * This returns the total number of months in the period by multiplying the
   * number of years by 12 and adding the number of months.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the total number of months in the period, may be negative
  */
  toTotalMonths(): number;
  /**
   * Adds this period to the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this period added.
   * If the temporal has a chronology, it must be the ISO chronology.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#plus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisPeriod.addTo(dateTime);
   *   dateTime = dateTime.plus(thisPeriod);
   * 
   * 
   * The calculation operates as follows.
   * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.
   * Second, if the months are zero, the years are added if non-zero, otherwise
   * the combination of years and months is added if non-zero.
   * Finally, any days are added.
   * 
   * This approach ensures that a partial period can be added to a partial date.
   * For example, a period of years and/or months can be added to a `YearMonth`,
   * but a period including days cannot.
   * The approach also adds years and months together when necessary, which ensures
   * correct behaviour at the end of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to add
   * @throws ArithmeticException if numeric overflow occurs
  */
  addTo(temporal: Temporal): Temporal;
  /**
   * Subtracts this period from the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this period subtracted.
   * If the temporal has a chronology, it must be the ISO chronology.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#minus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisPeriod.subtractFrom(dateTime);
   *   dateTime = dateTime.minus(thisPeriod);
   * 
   * 
   * The calculation operates as follows.
   * First, the chronology of the temporal is checked to ensure it is ISO chronology or null.
   * Second, if the months are zero, the years are subtracted if non-zero, otherwise
   * the combination of years and months is subtracted if non-zero.
   * Finally, any days are subtracted.
   * 
   * This approach ensures that a partial period can be subtracted from a partial date.
   * For example, a period of years and/or months can be subtracted from a `YearMonth`,
   * but a period including days cannot.
   * The approach also subtracts years and months together when necessary, which ensures
   * correct behaviour at the end of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to subtract
   * @throws ArithmeticException if numeric overflow occurs
  */
  subtractFrom(temporal: Temporal): Temporal;
  /**
   * Checks if this period is equal to another period.
   * 
   * The comparison is based on the type `Period` and each of the three amounts.
   * To be equal, the years, months and days units must be individually equal.
   * Note that this means that a period of "15 Months" is not equal to a period
   * of "1 Year and 3 Months".
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other period
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this period.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this period as a `String`, such as `P6Y3M1D`.
   * 
   * The output will be in the ISO-8601 period format.
   * A zero period will be represented as zero days, 'P0D'.
   *
   * @return a string representation of this period, not null
  */
  toString(): string;
  /**
   * Obtains a `ChronoPeriod` consisting of amount of time between two dates.
   * 
   * The start date is included, but the end date is not.
   * The period is calculated using {@link ChronoLocalDate#until(ChronoLocalDate)}.
   * As such, the calculation is chronology specific.
   * 
   * The chronology of the first date is used.
   * The chronology of the second date is ignored, with the date being converted
   * to the target chronology system before the calculation starts.
   * 
   * The result of this method can be a negative period if the end is before the start.
   * In most cases, the positive/negative sign will be the same in each of the supported fields.
   *
   * @param startDateInclusive  the start date, inclusive, specifying the chronology of the calculation, not null
   * @param endDateExclusive  the end date, exclusive, in any chronology, not null
   * @return the period between this date and the end date, not null
   * @see ChronoLocalDate#until(ChronoLocalDate)
  */
  static between(startDateInclusive: ChronoLocalDate, endDateExclusive: ChronoLocalDate): ChronoPeriod;
}
export interface Period extends ChronoPeriod, Serializable {}
/**
 * A month-of-year, such as 'July'.
 * 
 * `Month` is an enum representing the 12 months of the year -
 * January, February, March, April, May, June, July, August, September, October,
 * November and December.
 * 
 * In addition to the textual enum name, each month-of-year has an `int` value.
 * The `int` value follows normal usage and the ISO-8601 standard,
 * from 1 (January) to 12 (December). It is recommended that applications use the enum
 * rather than the `int` value to ensure code clarity.
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `Month`.
 * Use `getValue()` instead.
 * 
 * This enum represents a common concept that is found in many calendar systems.
 * As such, this enum may be used by any calendar system that has the month-of-year
 * concept defined exactly equivalent to the ISO-8601 calendar system.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class Month extends Enum<Month> {
  /**
   * The singleton instance for the month of January with 31 days.
   * This has the numeric value of `1`.
  */
  static readonly JANUARY: Month;
  /**
   * The singleton instance for the month of February with 28 days, or 29 in a leap year.
   * This has the numeric value of `2`.
  */
  static readonly FEBRUARY: Month;
  /**
   * The singleton instance for the month of March with 31 days.
   * This has the numeric value of `3`.
  */
  static readonly MARCH: Month;
  /**
   * The singleton instance for the month of April with 30 days.
   * This has the numeric value of `4`.
  */
  static readonly APRIL: Month;
  /**
   * The singleton instance for the month of May with 31 days.
   * This has the numeric value of `5`.
  */
  static readonly MAY: Month;
  /**
   * The singleton instance for the month of June with 30 days.
   * This has the numeric value of `6`.
  */
  static readonly JUNE: Month;
  /**
   * The singleton instance for the month of July with 31 days.
   * This has the numeric value of `7`.
  */
  static readonly JULY: Month;
  /**
   * The singleton instance for the month of August with 31 days.
   * This has the numeric value of `8`.
  */
  static readonly AUGUST: Month;
  /**
   * The singleton instance for the month of September with 30 days.
   * This has the numeric value of `9`.
  */
  static readonly SEPTEMBER: Month;
  /**
   * The singleton instance for the month of October with 31 days.
   * This has the numeric value of `10`.
  */
  static readonly OCTOBER: Month;
  /**
   * The singleton instance for the month of November with 30 days.
   * This has the numeric value of `11`.
  */
  static readonly NOVEMBER: Month;
  /**
   * The singleton instance for the month of December with 31 days.
   * This has the numeric value of `12`.
  */
  static readonly DECEMBER: Month;
  static valueOf(name: string): Month;
  static values(): Month[];
  /**
   * Obtains an instance of `Month` from an `int` value.
   * 
   * `Month` is an enum representing the 12 months of the year.
   * This factory allows the enum to be obtained from the `int` value.
   * The `int` value follows the ISO-8601 standard, from 1 (January) to 12 (December).
   *
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @return the month-of-year, not null
   * @throws DateTimeException if the month-of-year is invalid
  */
  static of(month: number): Month;
  /**
   * Obtains an instance of `Month` from a temporal object.
   * 
   * This obtains a month based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `Month`.
   * 
   * The conversion extracts the {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} field.
   * The extraction is only permitted if the temporal object has an ISO
   * chronology, or can be converted to a `LocalDate`.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `Month::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the month-of-year, not null
   * @throws DateTimeException if unable to convert to a `Month`
  */
  static from(temporal: TemporalAccessor): Month;
  /**
   * Gets the month-of-year `int` value.
   * 
   * The values are numbered following the ISO-8601 standard,
   * from 1 (January) to 12 (December).
   *
   * @return the month-of-year, from 1 (January) to 12 (December)
  */
  get value(): number;
  /**
   * Gets the textual representation, such as 'Jan' or 'December'.
   * 
   * This returns the textual name used to identify the month-of-year,
   * suitable for presentation to the user.
   * The parameters control the style of the returned text and the locale.
   * 
   * If no textual mapping is found then the {@link #getValue() numeric value} is returned.
   *
   * @param style  the length of the text required, not null
   * @param locale  the locale to use, not null
   * @return the text value of the month-of-year, not null
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this month-of-year can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then
   * this method returns true.
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this month-of-year, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This month is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then the
   * range of the month-of-year, from 1 to 12, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this month-of-year as an `int`.
   * 
   * This queries this month for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then the
   * value of the month-of-year, from 1 to 12, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field, within the valid range of values
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this month-of-year as a `long`.
   * 
   * This queries this month for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} then the
   * value of the month-of-year, from 1 to 12, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Returns the month-of-year that is the specified number of months after this one.
   * 
   * The calculation rolls around the end of the year from December to January.
   * The specified period may be negative.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to add, positive or negative
   * @return the resulting month, not null
  */
  plus(months: number): Month;
  /**
   * Returns the month-of-year that is the specified number of months before this one.
   * 
   * The calculation rolls around the start of the year from January to December.
   * The specified period may be negative.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to subtract, positive or negative
   * @return the resulting month, not null
  */
  minus(months: number): Month;
  /**
   * Gets the length of this month in days.
   * 
   * This takes a flag to determine whether to return the length for a leap year or not.
   * 
   * February has 28 days in a standard year and 29 days in a leap year.
   * April, June, September and November have 30 days.
   * All other months have 31 days.
   *
   * @param leapYear  true if the length is required for a leap year
   * @return the length of this month in days, from 28 to 31
  */
  length(leapYear: boolean): number;
  /**
   * Gets the minimum length of this month in days.
   * 
   * February has a minimum length of 28 days.
   * April, June, September and November have 30 days.
   * All other months have 31 days.
   *
   * @return the minimum length of this month in days, from 28 to 31
  */
  minLength(): number;
  /**
   * Gets the maximum length of this month in days.
   * 
   * February has a maximum length of 29 days.
   * April, June, September and November have 30 days.
   * All other months have 31 days.
   *
   * @return the maximum length of this month in days, from 29 to 31
  */
  maxLength(): number;
  /**
   * Gets the day-of-year corresponding to the first day of this month.
   * 
   * This returns the day-of-year that this month begins on, using the leap
   * year flag to determine the length of February.
   *
   * @param leapYear  true if the length is required for a leap year
   * @return the day of year corresponding to the first day of this month, from 1 to 336
  */
  firstDayOfYear(leapYear: boolean): number;
  /**
   * Gets the month corresponding to the first month of this quarter.
   * 
   * The year can be divided into four quarters.
   * This method returns the first month of the quarter for the base month.
   * January, February and March return January.
   * April, May and June return April.
   * July, August and September return July.
   * October, November and December return October.
   *
   * @return the first month of the quarter corresponding to this month, not null
  */
  firstMonthOfQuarter(): Month;
  /**
   * Queries this month-of-year using the specified query.
   * 
   * This queries this month-of-year using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this month-of-year.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the month-of-year changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#MONTH_OF_YEAR} as the field.
   * If the specified temporal object does not use the ISO calendar system then
   * a `DateTimeException` is thrown.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisMonth.adjustInto(temporal);
   *   temporal = temporal.with(thisMonth);
   * 
   * 
   * For example, given a date in May, the following are output:
   *      *   dateInMay.with(JANUARY);    // four months earlier
   *   dateInMay.with(APRIL);      // one months earlier
   *   dateInMay.with(MAY);        // same date
   *   dateInMay.with(JUNE);       // one month later
   *   dateInMay.with(DECEMBER);   // seven months later
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
}
/**
 * A time without a time-zone in the ISO-8601 calendar system,
 * such as `10:15:30`.
 * 
 * `LocalTime` is an immutable date-time object that represents a time,
 * often viewed as hour-minute-second.
 * Time is represented to nanosecond precision.
 * For example, the value "13:45.30.123456789" can be stored in a `LocalTime`.
 * 
 * This class does not store or represent a date or time-zone.
 * Instead, it is a description of the local time as seen on a wall clock.
 * It cannot represent an instant on the time-line without additional information
 * such as an offset or time-zone.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. This API assumes that all calendar systems use the same
 * representation, this class, for time-of-day.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class LocalTime extends Temporal {
  /**
   * The minimum supported `LocalTime`, '00:00'.
   * This is the time of midnight at the start of the day.
  */
  static readonly MIN: LocalTime;
  /**
   * The maximum supported `LocalTime`, '23:59:59.999999999'.
   * This is the time just before midnight at the end of the day.
  */
  static readonly MAX: LocalTime;
  /**
   * The time of midnight at the start of the day, '00:00'.
  */
  static readonly MIDNIGHT: LocalTime;
  /**
   * The time of noon in the middle of the day, '12:00'.
  */
  static readonly NOON: LocalTime;
  /**
   * Obtains the current time from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current time.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current time using the system clock and default time-zone, not null
  */
  static now(): LocalTime;
  /**
   * Obtains the current time from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current time.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current time using the system clock, not null
  */
  static now(zone: ZoneId): LocalTime;
  /**
   * Obtains the current time from the specified clock.
   * 
   * This will query the specified clock to obtain the current time.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current time, not null
  */
  static now(clock: Clock): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from an hour and minute.
   * 
   * This returns a `LocalTime` with the specified hour and minute.
   * The second and nanosecond fields will be set to zero.
   *
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @return the local time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  static of(hour: number, minute: number): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from an hour, minute and second.
   * 
   * This returns a `LocalTime` with the specified hour, minute and second.
   * The nanosecond field will be set to zero.
   *
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @return the local time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  static of(hour: number, minute: number, second: number): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from an hour, minute, second and nanosecond.
   * 
   * This returns a `LocalTime` with the specified hour, minute, second and nanosecond.
   *
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @return the local time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  static of(hour: number, minute: number, second: number, nanoOfSecond: number): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from an `Instant` and zone ID.
   * 
   * This creates a local time based on the specified instant.
   * First, the offset from UTC/Greenwich is obtained using the zone ID and instant,
   * which is simple as there is only one valid offset for each instant.
   * Then, the instant and offset are used to calculate the local time.
   *
   * @param instant  the instant to create the time from, not null
   * @param zone  the time-zone, which may be an offset, not null
   * @return the local time, not null
   * @since 9
  */
  static ofInstant(instant: Instant, zone: ZoneId): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from a second-of-day value.
   * 
   * This returns a `LocalTime` with the specified second-of-day.
   * The nanosecond field will be set to zero.
   *
   * @param secondOfDay  the second-of-day, from `0` to `24 * 60 * 60 - 1`
   * @return the local time, not null
   * @throws DateTimeException if the second-of-day value is invalid
  */
  static ofSecondOfDay(secondOfDay: number): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from a nanos-of-day value.
   * 
   * This returns a `LocalTime` with the specified nanosecond-of-day.
   *
   * @param nanoOfDay  the nano of day, from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`
   * @return the local time, not null
   * @throws DateTimeException if the nanos of day value is invalid
  */
  static ofNanoOfDay(nanoOfDay: number): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from a temporal object.
   * 
   * This obtains a local time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `LocalTime`.
   * 
   * The conversion uses the {@link TemporalQueries#localTime()} query, which relies
   * on extracting the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY} field.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `LocalTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the local time, not null
   * @throws DateTimeException if unable to convert to a `LocalTime`
  */
  static from(temporal: TemporalAccessor): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from a text string such as `10:15`.
   * 
   * The string must represent a valid time and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_LOCAL_TIME}.
   *
   * @param text  the text to parse such as "10:15:30", not null
   * @return the parsed local time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): LocalTime;
  /**
   * Obtains an instance of `LocalTime` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a time.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed local time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): LocalTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `NANO_OF_DAY`
   * `MICRO_OF_SECOND`
   * `MICRO_OF_DAY`
   * `MILLI_OF_SECOND`
   * `MILLI_OF_DAY`
   * `SECOND_OF_MINUTE`
   * `SECOND_OF_DAY`
   * `MINUTE_OF_HOUR`
   * `MINUTE_OF_DAY`
   * `HOUR_OF_AMPM`
   * `CLOCK_HOUR_OF_AMPM`
   * `HOUR_OF_DAY`
   * `CLOCK_HOUR_OF_DAY`
   * `AMPM_OF_DAY`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this time, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This time is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this time as an `int`.
   * 
   * This queries this time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this time, except `NANO_OF_DAY` and `MICRO_OF_DAY`
   * which are too large to fit in an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this time as a `long`.
   * 
   * This queries this time for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the hour-of-day field.
   *
   * @return the hour-of-day, from 0 to 23
  */
  get hour(): number;
  /**
   * Gets the minute-of-hour field.
   *
   * @return the minute-of-hour, from 0 to 59
  */
  get minute(): number;
  /**
   * Gets the second-of-minute field.
   *
   * @return the second-of-minute, from 0 to 59
  */
  get second(): number;
  /**
   * Gets the nano-of-second field.
   *
   * @return the nano-of-second, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this time.
   * 
   * This returns a `LocalTime`, based on this one, with the time adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the hour field.
   * A more complex adjuster might set the time to the last hour of the day.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `LocalTime` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): LocalTime;
  /**
   * Returns a copy of this time with the specified field set to a new value.
   * 
   * This returns a `LocalTime`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the hour, minute or second.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The supported fields behave as follows:
   * 
   * `NANO_OF_SECOND` -
   *  Returns a `LocalTime` with the specified nano-of-second.
   *  The hour, minute and second will be unchanged.
   * `NANO_OF_DAY` -
   *  Returns a `LocalTime` with the specified nano-of-day.
   *  This completely replaces the time and is equivalent to {@link #ofNanoOfDay(long)}.
   * `MICRO_OF_SECOND` -
   *  Returns a `LocalTime` with the nano-of-second replaced by the specified
   *  micro-of-second multiplied by 1,000.
   *  The hour, minute and second will be unchanged.
   * `MICRO_OF_DAY` -
   *  Returns a `LocalTime` with the specified micro-of-day.
   *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
   *  with the micro-of-day multiplied by 1,000.
   * `MILLI_OF_SECOND` -
   *  Returns a `LocalTime` with the nano-of-second replaced by the specified
   *  milli-of-second multiplied by 1,000,000.
   *  The hour, minute and second will be unchanged.
   * `MILLI_OF_DAY` -
   *  Returns a `LocalTime` with the specified milli-of-day.
   *  This completely replaces the time and is equivalent to using {@link #ofNanoOfDay(long)}
   *  with the milli-of-day multiplied by 1,000,000.
   * `SECOND_OF_MINUTE` -
   *  Returns a `LocalTime` with the specified second-of-minute.
   *  The hour, minute and nano-of-second will be unchanged.
   * `SECOND_OF_DAY` -
   *  Returns a `LocalTime` with the specified second-of-day.
   *  The nano-of-second will be unchanged.
   * `MINUTE_OF_HOUR` -
   *  Returns a `LocalTime` with the specified minute-of-hour.
   *  The hour, second-of-minute and nano-of-second will be unchanged.
   * `MINUTE_OF_DAY` -
   *  Returns a `LocalTime` with the specified minute-of-day.
   *  The second-of-minute and nano-of-second will be unchanged.
   * `HOUR_OF_AMPM` -
   *  Returns a `LocalTime` with the specified hour-of-am-pm.
   *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
   * `CLOCK_HOUR_OF_AMPM` -
   *  Returns a `LocalTime` with the specified clock-hour-of-am-pm.
   *  The AM/PM, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
   * `HOUR_OF_DAY` -
   *  Returns a `LocalTime` with the specified hour-of-day.
   *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
   * `CLOCK_HOUR_OF_DAY` -
   *  Returns a `LocalTime` with the specified clock-hour-of-day.
   *  The minute-of-hour, second-of-minute and nano-of-second will be unchanged.
   * `AMPM_OF_DAY` -
   *  Returns a `LocalTime` with the specified AM/PM.
   *  The hour-of-am-pm, minute-of-hour, second-of-minute and nano-of-second will be unchanged.
   * 
   * 
   * In all cases, if the new value is outside the valid range of values for the field
   * then a `DateTimeException` will be thrown.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `LocalTime` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the hour-of-day altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hour  the hour-of-day to set in the result, from 0 to 23
   * @return a `LocalTime` based on this time with the requested hour, not null
   * @throws DateTimeException if the hour value is invalid
  */
  withHour(hour: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the minute-of-hour altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minute  the minute-of-hour to set in the result, from 0 to 59
   * @return a `LocalTime` based on this time with the requested minute, not null
   * @throws DateTimeException if the minute value is invalid
  */
  withMinute(minute: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the second-of-minute altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param second  the second-of-minute to set in the result, from 0 to 59
   * @return a `LocalTime` based on this time with the requested second, not null
   * @throws DateTimeException if the second value is invalid
  */
  withSecond(second: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the nano-of-second altered.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
   * @return a `LocalTime` based on this time with the requested nanosecond, not null
   * @throws DateTimeException if the nanos value is invalid
  */
  withNano(nanoOfSecond: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the time truncated.
   * 
   * Truncation returns a copy of the original time with fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
   * will set the second-of-minute and nano-of-second field to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return a `LocalTime` based on this time with the time truncated, not null
   * @throws DateTimeException if unable to truncate
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): LocalTime;
  /**
   * Returns a copy of this time with the specified amount added.
   * 
   * This returns a `LocalTime`, based on this one, with the specified amount added.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `LocalTime` based on this time with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): LocalTime;
  /**
   * Returns a copy of this time with the specified amount added.
   * 
   * This returns a `LocalTime`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The supported fields behave as follows:
   * 
   * `NANOS` -
   *  Returns a `LocalTime` with the specified number of nanoseconds added.
   *  This is equivalent to {@link #plusNanos(long)}.
   * `MICROS` -
   *  Returns a `LocalTime` with the specified number of microseconds added.
   *  This is equivalent to {@link #plusNanos(long)} with the amount
   *  multiplied by 1,000.
   * `MILLIS` -
   *  Returns a `LocalTime` with the specified number of milliseconds added.
   *  This is equivalent to {@link #plusNanos(long)} with the amount
   *  multiplied by 1,000,000.
   * `SECONDS` -
   *  Returns a `LocalTime` with the specified number of seconds added.
   *  This is equivalent to {@link #plusSeconds(long)}.
   * `MINUTES` -
   *  Returns a `LocalTime` with the specified number of minutes added.
   *  This is equivalent to {@link #plusMinutes(long)}.
   * `HOURS` -
   *  Returns a `LocalTime` with the specified number of hours added.
   *  This is equivalent to {@link #plusHours(long)}.
   * `HALF_DAYS` -
   *  Returns a `LocalTime` with the specified number of half-days added.
   *  This is equivalent to {@link #plusHours(long)} with the amount
   *  multiplied by 12.
   * 
   * 
   * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `LocalTime` based on this time with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of hours added.
   * 
   * This adds the specified number of hours to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hoursToAdd  the hours to add, may be negative
   * @return a `LocalTime` based on this time with the hours added, not null
  */
  plusHours(hoursToAdd: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of minutes added.
   * 
   * This adds the specified number of minutes to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutesToAdd  the minutes to add, may be negative
   * @return a `LocalTime` based on this time with the minutes added, not null
  */
  plusMinutes(minutesToAdd: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of seconds added.
   * 
   * This adds the specified number of seconds to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondstoAdd  the seconds to add, may be negative
   * @return a `LocalTime` based on this time with the seconds added, not null
  */
  plusSeconds(secondstoAdd: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of nanoseconds added.
   * 
   * This adds the specified number of nanoseconds to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToAdd  the nanos to add, may be negative
   * @return a `LocalTime` based on this time with the nanoseconds added, not null
  */
  plusNanos(nanosToAdd: number): LocalTime;
  /**
   * Returns a copy of this time with the specified amount subtracted.
   * 
   * This returns a `LocalTime`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `LocalTime` based on this time with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): LocalTime;
  /**
   * Returns a copy of this time with the specified amount subtracted.
   * 
   * This returns a `LocalTime`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `LocalTime` based on this time with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of hours subtracted.
   * 
   * This subtracts the specified number of hours from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hoursToSubtract  the hours to subtract, may be negative
   * @return a `LocalTime` based on this time with the hours subtracted, not null
  */
  minusHours(hoursToSubtract: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of minutes subtracted.
   * 
   * This subtracts the specified number of minutes from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutesToSubtract  the minutes to subtract, may be negative
   * @return a `LocalTime` based on this time with the minutes subtracted, not null
  */
  minusMinutes(minutesToSubtract: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of seconds subtracted.
   * 
   * This subtracts the specified number of seconds from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondsToSubtract  the seconds to subtract, may be negative
   * @return a `LocalTime` based on this time with the seconds subtracted, not null
  */
  minusSeconds(secondsToSubtract: number): LocalTime;
  /**
   * Returns a copy of this `LocalTime` with the specified number of nanoseconds subtracted.
   * 
   * This subtracts the specified number of nanoseconds from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToSubtract  the nanos to subtract, may be negative
   * @return a `LocalTime` based on this time with the nanoseconds subtracted, not null
  */
  minusNanos(nanosToSubtract: number): LocalTime;
  /**
   * Queries this time using the specified query.
   * 
   * This queries this time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same time as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the time changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#NANO_OF_DAY} as the field.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisLocalTime.adjustInto(temporal);
   *   temporal = temporal.with(thisLocalTime);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another time in terms of the specified unit.
   * 
   * This calculates the amount of time between two `LocalTime`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified time.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `LocalTime` using {@link #from(TemporalAccessor)}.
   * For example, the amount in hours between two times can be calculated
   * using `startTime.until(endTime, HOURS)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two times.
   * For example, the amount in hours between 11:30 and 13:29 will only
   * be one hour as it is one minute short of two hours.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MINUTES);
   *   amount = MINUTES.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS` and `HALF_DAYS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end time, exclusive, which is converted to a `LocalTime`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this time and the end time
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `LocalTime`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this time using the specified formatter.
   * 
   * This time will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this time with a date to create a `LocalDateTime`.
   * 
   * This returns a `LocalDateTime` formed from this time at the specified date.
   * All possible combinations of date and time are valid.
   *
   * @param date  the date to combine with, not null
   * @return the local date-time formed from this time and the specified date, not null
  */
  atDate(date: LocalDate): LocalDateTime;
  /**
   * Combines this time with an offset to create an `OffsetTime`.
   * 
   * This returns an `OffsetTime` formed from this time at the specified offset.
   * All possible combinations of time and offset are valid.
   *
   * @param offset  the offset to combine with, not null
   * @return the offset time formed from this time and the specified offset, not null
  */
  atOffset(offset: ZoneOffset): OffsetTime;
  /**
   * Extracts the time as seconds of day,
   * from `0` to `24 * 60 * 60 - 1`.
   *
   * @return the second-of-day equivalent to this time
  */
  toSecondOfDay(): number;
  /**
   * Extracts the time as nanos of day,
   * from `0` to `24 * 60 * 60 * 1,000,000,000 - 1`.
   *
   * @return the nano of day equivalent to this time
  */
  toNanoOfDay(): number;
  /**
   * Converts this `LocalTime` to the number of seconds since the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * This combines this local time with the specified date and
   * offset to calculate the epoch-second value, which is the
   * number of elapsed seconds from 1970-01-01T00:00:00Z.
   * Instants on the time-line after the epoch are positive, earlier
   * are negative.
   *
   * @param date the local date, not null
   * @param offset the zone offset, not null
   * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
   * @since 9
  */
  toEpochSecond(date: LocalDate, offset: ZoneOffset): number;
  /**
   * Compares this time to another time.
   * 
   * The comparison is based on the time-line position of the local times within a day.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other time to compare to, not null
   * @return the comparator value, that is less than zero if this is before `other`,
   *          zero if they are equal, or greater than zero if this is after `other`
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: LocalTime): number;
  /**
   * Checks if this time is after the specified time.
   * 
   * The comparison is based on the time-line position of the time within a day.
   *
   * @param other  the other time to compare to, not null
   * @return true if this is after the specified time
  */
  isAfter(other: LocalTime): boolean;
  /**
   * Checks if this time is before the specified time.
   * 
   * The comparison is based on the time-line position of the time within a day.
   *
   * @param other  the other time to compare to, not null
   * @return true if this point is before the specified time
  */
  isBefore(other: LocalTime): boolean;
  /**
   * Checks if this time is equal to another time.
   * 
   * The comparison is based on the time-line position of the time within a day.
   * 
   * Only objects of type `LocalTime` are compared, other types return false.
   * To compare the date of two `TemporalAccessor` instances, use
   * {@link ChronoField#NANO_OF_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this time as a `String`, such as `10:15`.
   * 
   * The output will be one of the following ISO-8601 formats:
   * 
   * `HH:mm`
   * `HH:mm:ss`
   * `HH:mm:ss.SSS`
   * `HH:mm:ss.SSSSSS`
   * `HH:mm:ss.SSSSSSSSS`
   * 
   * The format used will be the shortest that outputs the full value of
   * the time where the omitted parts are implied to be zero.
   *
   * @return a string representation of this time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface LocalTime extends Temporal, TemporalAdjuster, Comparable<LocalTime>, Serializable {}
/**
 * Exception used to indicate a problem while calculating a date-time.
 * 
 * This exception is used to indicate problems with creating, querying
 * and manipulating date-time objects.
 *
 * @implSpec
 * This class is intended for use in a single thread.
 *
 * @since 1.8
*/
export class DateTimeException extends RuntimeException {
  /**
   * Constructs a new date-time exception with the specified message.
   *
   * @param message  the message to use for this exception, may be null
  */
  constructor(message: string);
  /**
   * Constructs a new date-time exception with the specified message and cause.
   *
   * @param message  the message to use for this exception, may be null
   * @param cause  the cause of the exception, may be null
  */
  constructor(message: string, cause: Throwable);
}
/**
 * A time with an offset from UTC/Greenwich in the ISO-8601 calendar system,
 * such as `10:15:30+01:00`.
 * 
 * `OffsetTime` is an immutable date-time object that represents a time, often
 * viewed as hour-minute-second-offset.
 * This class stores all time fields, to a precision of nanoseconds,
 * as well as a zone offset.
 * For example, the value "13:45:30.123456789+02:00" can be stored
 * in an `OffsetTime`.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class OffsetTime extends Temporal {
  /**
   * The minimum supported `OffsetTime`, '00:00:00+18:00'.
   * This is the time of midnight at the start of the day in the maximum offset
   * (larger offsets are earlier on the time-line).
   * This combines {@link LocalTime#MIN} and {@link ZoneOffset#MAX}.
   * This could be used by an application as a "far past" date.
  */
  static readonly MIN: OffsetTime;
  /**
   * The maximum supported `OffsetTime`, '23:59:59.999999999-18:00'.
   * This is the time just before midnight at the end of the day in the minimum offset
   * (larger negative offsets are later on the time-line).
   * This combines {@link LocalTime#MAX} and {@link ZoneOffset#MIN}.
   * This could be used by an application as a "far future" date.
  */
  static readonly MAX: OffsetTime;
  /**
   * Obtains the current time from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current time.
   * The offset will be calculated from the time-zone in the clock.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current time using the system clock and default time-zone, not null
  */
  static now(): OffsetTime;
  /**
   * Obtains the current time from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current time.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * The offset will be calculated from the specified time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current time using the system clock, not null
  */
  static now(zone: ZoneId): OffsetTime;
  /**
   * Obtains the current time from the specified clock.
   * 
   * This will query the specified clock to obtain the current time.
   * The offset will be calculated from the time-zone in the clock.
   * 
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current time, not null
  */
  static now(clock: Clock): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from a local time and an offset.
   *
   * @param time  the local time, not null
   * @param offset  the zone offset, not null
   * @return the offset time, not null
  */
  static of(time: LocalTime, offset: ZoneOffset): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from an hour, minute, second and nanosecond.
   * 
   * This creates an offset time with the four specified fields.
   * 
   * This method exists primarily for writing test cases.
   * Non test-code will typically use other methods to create an offset time.
   * `LocalTime` has two additional convenience variants of the
   * equivalent factory method taking fewer arguments.
   * They are not provided here to reduce the footprint of the API.
   *
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @param offset  the zone offset, not null
   * @return the offset time, not null
   * @throws DateTimeException if the value of any field is out of range
  */
  static of(hour: number, minute: number, second: number, nanoOfSecond: number, offset: ZoneOffset): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from an `Instant` and zone ID.
   * 
   * This creates an offset time with the same instant as that specified.
   * Finding the offset from UTC/Greenwich is simple as there is only one valid
   * offset for each instant.
   * 
   * The date component of the instant is dropped during the conversion.
   * This means that the conversion can never fail due to the instant being
   * out of the valid range of dates.
   *
   * @param instant  the instant to create the time from, not null
   * @param zone  the time-zone, which may be an offset, not null
   * @return the offset time, not null
  */
  static ofInstant(instant: Instant, zone: ZoneId): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from a temporal object.
   * 
   * This obtains an offset time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `OffsetTime`.
   * 
   * The conversion extracts and combines the `ZoneOffset` and the
   * `LocalTime` from the temporal object.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `OffsetTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the offset time, not null
   * @throws DateTimeException if unable to convert to an `OffsetTime`
  */
  static from(temporal: TemporalAccessor): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from a text string such as `10:15:30+01:00`.
   * 
   * The string must represent a valid time and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_TIME}.
   *
   * @param text  the text to parse such as "10:15:30+01:00", not null
   * @return the parsed local time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): OffsetTime;
  /**
   * Obtains an instance of `OffsetTime` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a time.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed offset time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): OffsetTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `NANO_OF_DAY`
   * `MICRO_OF_SECOND`
   * `MICRO_OF_DAY`
   * `MILLI_OF_SECOND`
   * `MILLI_OF_DAY`
   * `SECOND_OF_MINUTE`
   * `SECOND_OF_DAY`
   * `MINUTE_OF_HOUR`
   * `MINUTE_OF_DAY`
   * `HOUR_OF_AMPM`
   * `CLOCK_HOUR_OF_AMPM`
   * `HOUR_OF_DAY`
   * `CLOCK_HOUR_OF_DAY`
   * `AMPM_OF_DAY`
   * `OFFSET_SECONDS`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this time, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this offset-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This time is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this time as an `int`.
   * 
   * This queries this time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this time, except `NANO_OF_DAY` and `MICRO_OF_DAY`
   * which are too large to fit in an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this time as a `long`.
   * 
   * This queries this time for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the zone offset, such as '+01:00'.
   * 
   * This is the offset of the local time from UTC/Greenwich.
   *
   * @return the zone offset, not null
  */
  get offset(): ZoneOffset;
  /**
   * Returns a copy of this `OffsetTime` with the specified offset ensuring
   * that the result has the same local time.
   * 
   * This method returns an object with the same `LocalTime` and the specified `ZoneOffset`.
   * No calculation is needed or performed.
   * For example, if this time represents `10:30+02:00` and the offset specified is
   * `+03:00`, then this method will return `10:30+03:00`.
   * 
   * To take into account the difference between the offsets, and adjust the time fields,
   * use {@link #withOffsetSameInstant}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param offset  the zone offset to change to, not null
   * @return an `OffsetTime` based on this time with the requested offset, not null
  */
  withOffsetSameLocal(offset: ZoneOffset): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified offset ensuring
   * that the result is at the same instant on an implied day.
   * 
   * This method returns an object with the specified `ZoneOffset` and a `LocalTime`
   * adjusted by the difference between the two offsets.
   * This will result in the old and new objects representing the same instant on an implied day.
   * This is useful for finding the local time in a different offset.
   * For example, if this time represents `10:30+02:00` and the offset specified is
   * `+03:00`, then this method will return `11:30+03:00`.
   * 
   * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param offset  the zone offset to change to, not null
   * @return an `OffsetTime` based on this time with the requested offset, not null
  */
  withOffsetSameInstant(offset: ZoneOffset): OffsetTime;
  /**
   * Gets the `LocalTime` part of this date-time.
   * 
   * This returns a `LocalTime` with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Gets the hour-of-day field.
   *
   * @return the hour-of-day, from 0 to 23
  */
  get hour(): number;
  /**
   * Gets the minute-of-hour field.
   *
   * @return the minute-of-hour, from 0 to 59
  */
  get minute(): number;
  /**
   * Gets the second-of-minute field.
   *
   * @return the second-of-minute, from 0 to 59
  */
  get second(): number;
  /**
   * Gets the nano-of-second field.
   *
   * @return the nano-of-second, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this time.
   * 
   * This returns an `OffsetTime`, based on this one, with the time adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the hour field.
   * A more complex adjuster might set the time to the last hour of the day.
   * 
   * The classes {@link LocalTime} and {@link ZoneOffset} implement `TemporalAdjuster`,
   * thus this method can be used to change the time or offset:
   *      *  result = offsetTime.with(time);
   *  result = offsetTime.with(offset);
   * 
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return an `OffsetTime` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): OffsetTime;
  /**
   * Returns a copy of this time with the specified field set to a new value.
   * 
   * This returns an `OffsetTime`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the hour, minute or second.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * 
   * The `OFFSET_SECONDS` field will return a time with the specified offset.
   * The local time is unaltered. If the new offset value is outside the valid range
   * then a `DateTimeException` will be thrown.
   * 
   * The other {@link #isSupported(TemporalField) supported fields} will behave as per
   * the matching method on {@link LocalTime#with(TemporalField, long)} LocalTime}.
   * In this case, the offset is not part of the calculation and will be unchanged.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return an `OffsetTime` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the hour-of-day altered.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hour  the hour-of-day to set in the result, from 0 to 23
   * @return an `OffsetTime` based on this time with the requested hour, not null
   * @throws DateTimeException if the hour value is invalid
  */
  withHour(hour: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the minute-of-hour altered.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minute  the minute-of-hour to set in the result, from 0 to 59
   * @return an `OffsetTime` based on this time with the requested minute, not null
   * @throws DateTimeException if the minute value is invalid
  */
  withMinute(minute: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the second-of-minute altered.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param second  the second-of-minute to set in the result, from 0 to 59
   * @return an `OffsetTime` based on this time with the requested second, not null
   * @throws DateTimeException if the second value is invalid
  */
  withSecond(second: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the nano-of-second altered.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
   * @return an `OffsetTime` based on this time with the requested nanosecond, not null
   * @throws DateTimeException if the nanos value is invalid
  */
  withNano(nanoOfSecond: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the time truncated.
   * 
   * Truncation returns a copy of the original time with fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
   * will set the second-of-minute and nano-of-second field to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return an `OffsetTime` based on this time with the time truncated, not null
   * @throws DateTimeException if unable to truncate
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): OffsetTime;
  /**
   * Returns a copy of this time with the specified amount added.
   * 
   * This returns an `OffsetTime`, based on this one, with the specified amount added.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return an `OffsetTime` based on this time with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): OffsetTime;
  /**
   * Returns a copy of this time with the specified amount added.
   * 
   * This returns an `OffsetTime`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented by
   * {@link LocalTime#plus(long, TemporalUnit)}.
   * The offset is not part of the calculation and will be unchanged in the result.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return an `OffsetTime` based on this time with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of hours added.
   * 
   * This adds the specified number of hours to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to add, may be negative
   * @return an `OffsetTime` based on this time with the hours added, not null
  */
  plusHours(hours: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of minutes added.
   * 
   * This adds the specified number of minutes to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to add, may be negative
   * @return an `OffsetTime` based on this time with the minutes added, not null
  */
  plusMinutes(minutes: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of seconds added.
   * 
   * This adds the specified number of seconds to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to add, may be negative
   * @return an `OffsetTime` based on this time with the seconds added, not null
  */
  plusSeconds(seconds: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of nanoseconds added.
   * 
   * This adds the specified number of nanoseconds to this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to add, may be negative
   * @return an `OffsetTime` based on this time with the nanoseconds added, not null
  */
  plusNanos(nanos: number): OffsetTime;
  /**
   * Returns a copy of this time with the specified amount subtracted.
   * 
   * This returns an `OffsetTime`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return an `OffsetTime` based on this time with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): OffsetTime;
  /**
   * Returns a copy of this time with the specified amount subtracted.
   * 
   * This returns an `OffsetTime`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return an `OffsetTime` based on this time with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of hours subtracted.
   * 
   * This subtracts the specified number of hours from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to subtract, may be negative
   * @return an `OffsetTime` based on this time with the hours subtracted, not null
  */
  minusHours(hours: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of minutes subtracted.
   * 
   * This subtracts the specified number of minutes from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to subtract, may be negative
   * @return an `OffsetTime` based on this time with the minutes subtracted, not null
  */
  minusMinutes(minutes: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of seconds subtracted.
   * 
   * This subtracts the specified number of seconds from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to subtract, may be negative
   * @return an `OffsetTime` based on this time with the seconds subtracted, not null
  */
  minusSeconds(seconds: number): OffsetTime;
  /**
   * Returns a copy of this `OffsetTime` with the specified number of nanoseconds subtracted.
   * 
   * This subtracts the specified number of nanoseconds from this time, returning a new time.
   * The calculation wraps around midnight.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to subtract, may be negative
   * @return an `OffsetTime` based on this time with the nanoseconds subtracted, not null
  */
  minusNanos(nanos: number): OffsetTime;
  /**
   * Queries this time using the specified query.
   * 
   * This queries this time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same offset and time
   * as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the offset and time changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * twice, passing {@link ChronoField#NANO_OF_DAY} and
   * {@link ChronoField#OFFSET_SECONDS} as the fields.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisOffsetTime.adjustInto(temporal);
   *   temporal = temporal.with(thisOffsetTime);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another time in terms of the specified unit.
   * 
   * This calculates the amount of time between two `OffsetTime`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified time.
   * The result will be negative if the end is before the start.
   * For example, the amount in hours between two times can be calculated
   * using `startTime.until(endTime, HOURS)`.
   * 
   * The `Temporal` passed to this method is converted to a
   * `OffsetTime` using {@link #from(TemporalAccessor)}.
   * If the offset differs between the two times, then the specified
   * end time is normalized to have the same offset as this time.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two times.
   * For example, the amount in hours between 11:30Z and 13:29Z will only
   * be one hour as it is one minute short of two hours.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MINUTES);
   *   amount = MINUTES.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS` and `HALF_DAYS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end time, exclusive, which is converted to an `OffsetTime`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this time and the end time
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to an `OffsetTime`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this time using the specified formatter.
   * 
   * This time will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this time with a date to create an `OffsetDateTime`.
   * 
   * This returns an `OffsetDateTime` formed from this time and the specified date.
   * All possible combinations of date and time are valid.
   *
   * @param date  the date to combine with, not null
   * @return the offset date-time formed from this time and the specified date, not null
  */
  atDate(date: LocalDate): OffsetDateTime;
  /**
   * Converts this `OffsetTime` to the number of seconds since the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * This combines this offset time with the specified date to calculate the
   * epoch-second value, which is the number of elapsed seconds from
   * 1970-01-01T00:00:00Z.
   * Instants on the time-line after the epoch are positive, earlier
   * are negative.
   *
   * @param date the localdate, not null
   * @return the number of seconds since the epoch of 1970-01-01T00:00:00Z, may be negative
   * @since 9
  */
  toEpochSecond(date: LocalDate): number;
  /**
   * Compares this `OffsetTime` to another time.
   * 
   * The comparison is based first on the UTC equivalent instant, then on the local time.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * For example, the following is the comparator order:
   * 
   * `10:30+01:00`
   * `11:00+01:00`
   * `12:00+02:00`
   * `11:30+01:00`
   * `12:00+01:00`
   * `12:30+01:00`
   * 
   * Values #2 and #3 represent the same instant on the time-line.
   * When two values represent the same instant, the local time is compared
   * to distinguish them. This step is needed to make the ordering
   * consistent with `equals()`.
   * 
   * To compare the underlying local time of two `TemporalAccessor` instances,
   * use {@link ChronoField#NANO_OF_DAY} as a comparator.
   *
   * @param other  the other time to compare to, not null
   * @return the comparator value, that is the comparison of the UTC equivalent `other` instant,
   *          if they are not equal, and if the UTC equivalent `other` instant is equal,
   *          the comparison of this local time with `other` local time
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: OffsetTime): number;
  /**
   * Checks if the instant of this `OffsetTime` is after that of the
   * specified time applying both times to a common date.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the instant of the time. This is equivalent to converting both
   * times to an instant using the same date and comparing the instants.
   *
   * @param other  the other time to compare to, not null
   * @return true if this is after the instant of the specified time
  */
  isAfter(other: OffsetTime): boolean;
  /**
   * Checks if the instant of this `OffsetTime` is before that of the
   * specified time applying both times to a common date.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the instant of the time. This is equivalent to converting both
   * times to an instant using the same date and comparing the instants.
   *
   * @param other  the other time to compare to, not null
   * @return true if this is before the instant of the specified time
  */
  isBefore(other: OffsetTime): boolean;
  /**
   * Checks if the instant of this `OffsetTime` is equal to that of the
   * specified time applying both times to a common date.
   * 
   * This method differs from the comparison in {@link #compareTo} and {@link #equals}
   * in that it only compares the instant of the time. This is equivalent to converting both
   * times to an instant using the same date and comparing the instants.
   *
   * @param other  the other time to compare to, not null
   * @return true if this is equal to the instant of the specified time
  */
  isEqual(other: OffsetTime): boolean;
  /**
   * Checks if this time is equal to another time.
   * 
   * The comparison is based on the local-time and the offset.
   * To compare for the same instant on the time-line, use {@link #isEqual(OffsetTime)}.
   * 
   * Only objects of type `OffsetTime` are compared, other types return false.
   * To compare the underlying local time of two `TemporalAccessor` instances,
   * use {@link ChronoField#NANO_OF_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this time as a `String`, such as `10:15:30+01:00`.
   * 
   * The output will be one of the following ISO-8601 formats:
   * 
   * `HH:mmXXXXX`
   * `HH:mm:ssXXXXX`
   * `HH:mm:ss.SSSXXXXX`
   * `HH:mm:ss.SSSSSSXXXXX`
   * `HH:mm:ss.SSSSSSSSSXXXXX`
   * 
   * The format used will be the shortest that outputs the full value of
   * the time where the omitted parts are implied to be zero.
   *
   * @return a string representation of this time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface OffsetTime extends Temporal, TemporalAdjuster, Comparable<OffsetTime>, Serializable {}
/**
 * A date-time with a time-zone in the ISO-8601 calendar system,
 * such as `2007-12-03T10:15:30+01:00 Europe/Paris`.
 * 
 * `ZonedDateTime` is an immutable representation of a date-time with a time-zone.
 * This class stores all date and time fields, to a precision of nanoseconds,
 * and a time-zone, with a zone offset used to handle ambiguous local date-times.
 * For example, the value
 * "2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone"
 * can be stored in a `ZonedDateTime`.
 * 
 * This class handles conversion from the local time-line of `LocalDateTime`
 * to the instant time-line of `Instant`.
 * The difference between the two time-lines is the offset from UTC/Greenwich,
 * represented by a `ZoneOffset`.
 * 
 * Converting between the two time-lines involves calculating the offset using the
 * {@link ZoneRules rules} accessed from the `ZoneId`.
 * Obtaining the offset for an instant is simple, as there is exactly one valid
 * offset for each instant. By contrast, obtaining the offset for a local date-time
 * is not straightforward. There are three cases:
 * 
 * Normal, with one valid offset. For the vast majority of the year, the normal
 *  case applies, where there is a single valid offset for the local date-time.
 * Gap, with zero valid offsets. This is when clocks jump forward typically
 *  due to the spring daylight savings change from "winter" to "summer".
 *  In a gap there are local date-time values with no valid offset.
 * Overlap, with two valid offsets. This is when clocks are set back typically
 *  due to the autumn daylight savings change from "summer" to "winter".
 *  In an overlap there are local date-time values with two valid offsets.
 * 
 * 
 * Any method that converts directly or implicitly from a local date-time to an
 * instant by obtaining the offset has the potential to be complicated.
 * 
 * For Gaps, the general strategy is that if the local date-time falls in the
 * middle of a Gap, then the resulting zoned date-time will have a local date-time
 * shifted forwards by the length of the Gap, resulting in a date-time in the later
 * offset, typically "summer" time.
 * 
 * For Overlaps, the general strategy is that if the local date-time falls in the
 * middle of an Overlap, then the previous offset will be retained. If there is no
 * previous offset, or the previous offset is invalid, then the earlier offset is
 * used, typically "summer" time.. Two additional methods,
 * {@link #withEarlierOffsetAtOverlap()} and {@link #withLaterOffsetAtOverlap()},
 * help manage the case of an overlap.
 * 
 * In terms of design, this class should be viewed primarily as the combination
 * of a `LocalDateTime` and a `ZoneId`. The `ZoneOffset` is
 * a vital, but secondary, piece of information, used to ensure that the class
 * represents an instant, especially during a daylight savings overlap.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * A `ZonedDateTime` holds state equivalent to three separate objects,
 * a `LocalDateTime`, a `ZoneId` and the resolved `ZoneOffset`.
 * The offset and local date-time are used to define an instant when necessary.
 * The zone ID is used to obtain the rules for how and when the offset changes.
 * The offset cannot be freely set, as the zone controls which offsets are valid.
 * 
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ZonedDateTime extends Temporal {
  /**
   * Obtains the current date-time from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date-time.
   * The zone and offset will be set based on the time-zone in the clock.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date-time using the system clock, not null
  */
  static now(): ZonedDateTime;
  /**
   * Obtains the current date-time from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * The offset will be calculated from the specified time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date-time using the system clock, not null
  */
  static now(zone: ZoneId): ZonedDateTime;
  /**
   * Obtains the current date-time from the specified clock.
   * 
   * This will query the specified clock to obtain the current date-time.
   * The zone and offset will be set based on the time-zone in the clock.
   * 
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date-time, not null
  */
  static now(clock: Clock): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a local date and time.
   * 
   * This creates a zoned date-time matching the input local date and time as closely as possible.
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may be adjusted.
   * 
   * The local date time and first combined to form a local date-time.
   * The local date-time is then resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, when clocks are set back, there are two valid offsets.
   * This method uses the earlier offset typically corresponding to "summer".
   * 
   * In the case of a gap, when clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   *
   * @param date  the local date, not null
   * @param time  the local time, not null
   * @param zone  the time-zone, not null
   * @return the offset date-time, not null
  */
  static of(date: LocalDate, time: LocalTime, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a local date-time.
   * 
   * This creates a zoned date-time matching the input local date-time as closely as possible.
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may be adjusted.
   * 
   * The local date-time is resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, when clocks are set back, there are two valid offsets.
   * This method uses the earlier offset typically corresponding to "summer".
   * 
   * In the case of a gap, when clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   *
   * @param localDateTime  the local date-time, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
  */
  static of(localDateTime: LocalDateTime, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a year, month, day,
   * hour, minute, second, nanosecond and time-zone.
   * 
   * This creates a zoned date-time matching the local date-time of the seven
   * specified fields as closely as possible.
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may be adjusted.
   * 
   * The local date-time is resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, when clocks are set back, there are two valid offsets.
   * This method uses the earlier offset typically corresponding to "summer".
   * 
   * In the case of a gap, when clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   * 
   * This method exists primarily for writing test cases.
   * Non test-code will typically use other methods to create an offset time.
   * `LocalDateTime` has five additional convenience variants of the
   * equivalent factory method taking fewer arguments.
   * They are not provided here to reduce the footprint of the API.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @param zone  the time-zone, not null
   * @return the offset date-time, not null
   * @throws DateTimeException if the value of any field is out of range, or
   *  if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, nanoOfSecond: number, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a local date-time
   * using the preferred offset if possible.
   * 
   * The local date-time is resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, where clocks are set back, there are two valid offsets.
   * If the preferred offset is one of the valid offsets then it is used.
   * Otherwise the earlier valid offset is used, typically corresponding to "summer".
   * 
   * In the case of a gap, where clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   *
   * @param localDateTime  the local date-time, not null
   * @param zone  the time-zone, not null
   * @param preferredOffset  the zone offset, null if no preference
   * @return the zoned date-time, not null
  */
  static ofLocal(localDateTime: LocalDateTime, zone: ZoneId, preferredOffset: ZoneOffset): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from an `Instant`.
   * 
   * This creates a zoned date-time with the same instant as that specified.
   * Calling {@link #toInstant()} will return an instant equal to the one used here.
   * 
   * Converting an instant to a zoned date-time is simple as there is only one valid
   * offset for each instant.
   *
   * @param instant  the instant to create the date-time from, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  static ofInstant(instant: Instant, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from the instant formed by combining
   * the local date-time and offset.
   * 
   * This creates a zoned date-time by {@link LocalDateTime#toInstant(ZoneOffset) combining}
   * the `LocalDateTime` and `ZoneOffset`.
   * This combination uniquely specifies an instant without ambiguity.
   * 
   * Converting an instant to a zoned date-time is simple as there is only one valid
   * offset for each instant. If the valid offset is different to the offset specified,
   * then the date-time and offset of the zoned date-time will differ from those specified.
   * 
   * If the `ZoneId` to be used is a `ZoneOffset`, this method is equivalent
   * to {@link #of(LocalDateTime, ZoneId)}.
   *
   * @param localDateTime  the local date-time, not null
   * @param offset  the zone offset, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
  */
  static ofInstant(localDateTime: LocalDateTime, offset: ZoneOffset, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` strictly validating the
   * combination of local date-time, offset and zone ID.
   * 
   * This creates a zoned date-time ensuring that the offset is valid for the
   * local date-time according to the rules of the specified zone.
   * If the offset is invalid, an exception is thrown.
   *
   * @param localDateTime  the local date-time, not null
   * @param offset  the zone offset, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
   * @throws DateTimeException if the combination of arguments is invalid
  */
  static ofStrict(localDateTime: LocalDateTime, offset: ZoneOffset, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a temporal object.
   * 
   * This obtains a zoned date-time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ZonedDateTime`.
   * 
   * The conversion will first obtain a `ZoneId` from the temporal object,
   * falling back to a `ZoneOffset` if necessary. It will then try to obtain
   * an `Instant`, falling back to a `LocalDateTime` if necessary.
   * The result will be either the combination of `ZoneId` or `ZoneOffset`
   * with `Instant` or `LocalDateTime`.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ZonedDateTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the zoned date-time, not null
   * @throws DateTimeException if unable to convert to an `ZonedDateTime`
  */
  static from(temporal: TemporalAccessor): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a text string such as
   * `2007-12-03T10:15:30+01:00[Europe/Paris]`.
   * 
   * The string must represent a valid date-time and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_ZONED_DATE_TIME}.
   *
   * @param text  the text to parse such as "2007-12-03T10:15:30+01:00[Europe/Paris]", not null
   * @return the parsed zoned date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): ZonedDateTime;
  /**
   * Obtains an instance of `ZonedDateTime` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a date-time.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed zoned date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): ZonedDateTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this date-time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `NANO_OF_DAY`
   * `MICRO_OF_SECOND`
   * `MICRO_OF_DAY`
   * `MILLI_OF_SECOND`
   * `MILLI_OF_DAY`
   * `SECOND_OF_MINUTE`
   * `SECOND_OF_DAY`
   * `MINUTE_OF_HOUR`
   * `MINUTE_OF_DAY`
   * `HOUR_OF_AMPM`
   * `CLOCK_HOUR_OF_AMPM`
   * `HOUR_OF_DAY`
   * `CLOCK_HOUR_OF_DAY`
   * `AMPM_OF_DAY`
   * `DAY_OF_WEEK`
   * `ALIGNED_DAY_OF_WEEK_IN_MONTH`
   * `ALIGNED_DAY_OF_WEEK_IN_YEAR`
   * `DAY_OF_MONTH`
   * `DAY_OF_YEAR`
   * `EPOCH_DAY`
   * `ALIGNED_WEEK_OF_MONTH`
   * `ALIGNED_WEEK_OF_YEAR`
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * `INSTANT_SECONDS`
   * `OFFSET_SECONDS`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this date-time, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * `DAYS`
   * `WEEKS`
   * `MONTHS`
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This date-time is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this date-time as an `int`.
   * 
   * This queries this date-time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time, except `NANO_OF_DAY`, `MICRO_OF_DAY`,
   * `EPOCH_DAY`, `PROLEPTIC_MONTH` and `INSTANT_SECONDS` which are too
   * large to fit in an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this date-time as a `long`.
   * 
   * This queries this date-time for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the zone offset, such as '+01:00'.
   * 
   * This is the offset of the local date-time from UTC/Greenwich.
   *
   * @return the zone offset, not null
  */
  get offset(): ZoneOffset;
  /**
   * Returns a copy of this date-time changing the zone offset to the
   * earlier of the two valid offsets at a local time-line overlap.
   * 
   * This method only has any effect when the local time-line overlaps, such as
   * at an autumn daylight savings cutover. In this scenario, there are two
   * valid offsets for the local date-time. Calling this method will return
   * a zoned date-time with the earlier of the two selected.
   * 
   * If this method is called when it is not an overlap, `this`
   * is returned.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `ZonedDateTime` based on this date-time with the earlier offset, not null
  */
  withEarlierOffsetAtOverlap(): ZonedDateTime;
  /**
   * Returns a copy of this date-time changing the zone offset to the
   * later of the two valid offsets at a local time-line overlap.
   * 
   * This method only has any effect when the local time-line overlaps, such as
   * at an autumn daylight savings cutover. In this scenario, there are two
   * valid offsets for the local date-time. Calling this method will return
   * a zoned date-time with the later of the two selected.
   * 
   * If this method is called when it is not an overlap, `this`
   * is returned.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `ZonedDateTime` based on this date-time with the later offset, not null
  */
  withLaterOffsetAtOverlap(): ZonedDateTime;
  /**
   * Gets the time-zone, such as 'Europe/Paris'.
   * 
   * This returns the zone ID. This identifies the time-zone {@link ZoneRules rules}
   * that determine when and how the offset from UTC/Greenwich changes.
   * 
   * The zone ID may be same as the {@linkplain #getOffset() offset}.
   * If this is true, then any future calculations, such as addition or subtraction,
   * have no complex edge cases due to time-zone rules.
   * See also {@link #withFixedOffsetZone()}.
   *
   * @return the time-zone, not null
  */
  get zone(): ZoneId;
  /**
   * Returns a copy of this date-time with a different time-zone,
   * retaining the local date-time if possible.
   * 
   * This method changes the time-zone and retains the local date-time.
   * The local date-time is only changed if it is invalid for the new zone,
   * determined using the same approach as
   * {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}.
   * 
   * To change the zone and adjust the local date-time,
   * use {@link #withZoneSameInstant(ZoneId)}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param zone  the time-zone to change to, not null
   * @return a `ZonedDateTime` based on this date-time with the requested zone, not null
  */
  withZoneSameLocal(zone: ZoneId): ZonedDateTime;
  /**
   * Returns a copy of this date-time with a different time-zone,
   * retaining the instant.
   * 
   * This method changes the time-zone and retains the instant.
   * This normally results in a change to the local date-time.
   * 
   * This method is based on retaining the same instant, thus gaps and overlaps
   * in the local time-line have no effect on the result.
   * 
   * To change the offset while keeping the local time,
   * use {@link #withZoneSameLocal(ZoneId)}.
   *
   * @param zone  the time-zone to change to, not null
   * @return a `ZonedDateTime` based on this date-time with the requested zone, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  withZoneSameInstant(zone: ZoneId): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the zone ID set to the offset.
   * 
   * This returns a zoned date-time where the zone ID is the same as {@link #getOffset()}.
   * The local date-time, offset and instant of the result will be the same as in this date-time.
   * 
   * Setting the date-time to a fixed single offset means that any future
   * calculations, such as addition or subtraction, have no complex edge cases
   * due to time-zone rules.
   * This might also be useful when sending a zoned date-time across a network,
   * as most protocols, such as ISO-8601, only handle offsets,
   * and not region-based zone IDs.
   * 
   * This is equivalent to `ZonedDateTime.of(zdt.toLocalDateTime(), zdt.getOffset())`.
   *
   * @return a `ZonedDateTime` with the zone ID set to the offset, not null
  */
  withFixedOffsetZone(): ZonedDateTime;
  /**
   * Gets the `LocalDateTime` part of this date-time.
   * 
   * This returns a `LocalDateTime` with the same year, month, day and time
   * as this date-time.
   *
   * @return the local date-time part of this date-time, not null
  */
  toLocalDateTime(): LocalDateTime;
  /**
   * Gets the `LocalDate` part of this date-time.
   * 
   * This returns a `LocalDate` with the same year, month and day
   * as this date-time.
   *
   * @return the date part of this date-time, not null
  */
  toLocalDate(): LocalDate;
  /**
   * Gets the year field.
   * 
   * This method returns the primitive `int` value for the year.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.
   *
   * @return the year, from MIN_YEAR to MAX_YEAR
  */
  get year(): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Gets the day-of-month field.
   * 
   * This method returns the primitive `int` value for the day-of-month.
   *
   * @return the day-of-month, from 1 to 31
  */
  get dayOfMonth(): number;
  /**
   * Gets the day-of-year field.
   * 
   * This method returns the primitive `int` value for the day-of-year.
   *
   * @return the day-of-year, from 1 to 365, or 366 in a leap year
  */
  get dayOfYear(): number;
  /**
   * Gets the day-of-week field, which is an enum `DayOfWeek`.
   * 
   * This method returns the enum {@link DayOfWeek} for the day-of-week.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link DayOfWeek#getValue() int value}.
   * 
   * Additional information can be obtained from the `DayOfWeek`.
   * This includes textual names of the values.
   *
   * @return the day-of-week, not null
  */
  get dayOfWeek(): DayOfWeek;
  /**
   * Gets the `LocalTime` part of this date-time.
   * 
   * This returns a `LocalTime` with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Gets the hour-of-day field.
   *
   * @return the hour-of-day, from 0 to 23
  */
  get hour(): number;
  /**
   * Gets the minute-of-hour field.
   *
   * @return the minute-of-hour, from 0 to 59
  */
  get minute(): number;
  /**
   * Gets the second-of-minute field.
   *
   * @return the second-of-minute, from 0 to 59
  */
  get second(): number;
  /**
   * Gets the nano-of-second field.
   *
   * @return the nano-of-second, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this date-time.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the date-time adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the date to the last day of the month.
   * A selection of common adjustments is provided in
   * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
   * These include finding the "last day of the month" and "next Wednesday".
   * Key date-time classes also implement the `TemporalAdjuster` interface,
   * such as {@link Month} and {@link java.time.MonthDay MonthDay}.
   * The adjuster is responsible for handling special cases, such as the varying
   * lengths of month and leap years.
   * 
   * For example this code returns a date on the last day of July:
   *      *  import static java.time.Month.*;
   *  import static java.time.temporal.TemporalAdjusters.*;
   *
   *  result = zonedDateTime.with(JULY).with(lastDayOfMonth());
   * 
   * 
   * The classes {@link LocalDate} and {@link LocalTime} implement `TemporalAdjuster`,
   * thus this method can be used to change the date, time or offset:
   *      *  result = zonedDateTime.with(date);
   *  result = zonedDateTime.with(time);
   * 
   * 
   * {@link ZoneOffset} also implements `TemporalAdjuster` however using it
   * as an argument typically has no effect. The offset of a `ZonedDateTime` is
   * controlled primarily by the time-zone. As such, changing the offset does not generally
   * make sense, because there is only one valid offset for the local date-time and zone.
   * If the zoned date-time is in a daylight savings overlap, then the offset is used
   * to switch between the two valid offsets. In all other cases, the offset is ignored.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `ZonedDateTime` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the specified field set to a new value.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the year, month or day-of-month.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * In some cases, changing the specified field can cause the resulting date-time to become invalid,
   * such as changing the month from 31st January to February would make the day-of-month invalid.
   * In cases like this, the field is responsible for resolving the date. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * 
   * The `INSTANT_SECONDS` field will return a date-time with the specified instant.
   * The zone and nano-of-second are unchanged.
   * The result will have an offset derived from the new instant and original zone.
   * If the new instant value is outside the valid range then a `DateTimeException` will be thrown.
   * 
   * The `OFFSET_SECONDS` field will typically be ignored.
   * The offset of a `ZonedDateTime` is controlled primarily by the time-zone.
   * As such, changing the offset does not generally make sense, because there is only
   * one valid offset for the local date-time and zone.
   * If the zoned date-time is in a daylight savings overlap, then the offset is used
   * to switch between the two valid offsets. In all other cases, the offset is ignored.
   * If the new offset value is outside the valid range then a `DateTimeException` will be thrown.
   * 
   * The other {@link #isSupported(TemporalField) supported fields} will behave as per
   * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.
   * The zone is not part of the calculation and will be unchanged.
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `ZonedDateTime` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the year altered.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#withYear(int) changing the year} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR
   * @return a `ZonedDateTime` based on this date-time with the requested year, not null
   * @throws DateTimeException if the year value is invalid
  */
  withYear(year: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the month-of-year altered.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#withMonth(int) changing the month} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)
   * @return a `ZonedDateTime` based on this date-time with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the day-of-month altered.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#withDayOfMonth(int) changing the day-of-month} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31
   * @return a `ZonedDateTime` based on this date-time with the requested day, not null
   * @throws DateTimeException if the day-of-month value is invalid,
   *  or if the day-of-month is invalid for the month-year
  */
  withDayOfMonth(dayOfMonth: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the day-of-year altered.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#withDayOfYear(int) changing the day-of-year} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366
   * @return a `ZonedDateTime` based on this date with the requested day, not null
   * @throws DateTimeException if the day-of-year value is invalid,
   *  or if the day-of-year is invalid for the year
  */
  withDayOfYear(dayOfYear: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the hour-of-day altered.
   * 
   * This operates on the local time-line,
   * {@linkplain LocalDateTime#withHour(int) changing the time} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hour  the hour-of-day to set in the result, from 0 to 23
   * @return a `ZonedDateTime` based on this date-time with the requested hour, not null
   * @throws DateTimeException if the hour value is invalid
  */
  withHour(hour: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the minute-of-hour altered.
   * 
   * This operates on the local time-line,
   * {@linkplain LocalDateTime#withMinute(int) changing the time} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minute  the minute-of-hour to set in the result, from 0 to 59
   * @return a `ZonedDateTime` based on this date-time with the requested minute, not null
   * @throws DateTimeException if the minute value is invalid
  */
  withMinute(minute: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the second-of-minute altered.
   * 
   * This operates on the local time-line,
   * {@linkplain LocalDateTime#withSecond(int) changing the time} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param second  the second-of-minute to set in the result, from 0 to 59
   * @return a `ZonedDateTime` based on this date-time with the requested second, not null
   * @throws DateTimeException if the second value is invalid
  */
  withSecond(second: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the nano-of-second altered.
   * 
   * This operates on the local time-line,
   * {@linkplain LocalDateTime#withNano(int) changing the time} of the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
   * @return a `ZonedDateTime` based on this date-time with the requested nanosecond, not null
   * @throws DateTimeException if the nano value is invalid
  */
  withNano(nanoOfSecond: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the time truncated.
   * 
   * Truncation returns a copy of the original date-time with fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
   * will set the second-of-minute and nano-of-second field to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#truncatedTo(TemporalUnit) truncating}
   * the underlying local date-time. This is then converted back to a
   * `ZonedDateTime`, using the zone ID to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return a `ZonedDateTime` based on this date-time with the time truncated, not null
   * @throws DateTimeException if unable to truncate
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `ZonedDateTime` based on this date-time with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The zone is not part of the calculation and will be unchanged in the result.
   * The calculation for date and time units differ.
   * 
   * Date units operate on the local time-line.
   * The period is first added to the local date-time, then converted back
   * to a zoned date-time using the zone ID.
   * The conversion uses {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}
   * with the offset before the addition.
   * 
   * Time units operate on the instant time-line.
   * The period is first added to the local date-time, then converted back to
   * a zoned date-time using the zone ID.
   * The conversion uses {@link #ofInstant(LocalDateTime, ZoneOffset, ZoneId)}
   * with the offset before the addition.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `ZonedDateTime` based on this date-time with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of years added.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#plusYears(long) adding years} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the years added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusYears(years: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of months added.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#plusMonths(long) adding months} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the months added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMonths(months: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of weeks added.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#plusWeeks(long) adding weeks} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the weeks added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusWeeks(weeks: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of days added.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#plusDays(long) adding days} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the days added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusDays(days: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of hours added.
   * 
   * This operates on the instant time-line, such that adding one hour will
   * always be a duration of one hour later.
   * This may cause the local date-time to change by an amount other than one hour.
   * Note that this is a different approach to that used by days, months and years,
   * thus adding one day is not the same as adding 24 hours.
   * 
   * For example, consider a time-zone, such as 'Europe/Paris', where the
   * Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
   * changing from offset +02:00 in summer to +01:00 in winter.
   * 
   * Adding one hour to 01:30+02:00 will result in 02:30+02:00
   *     (both in summer time)
   * Adding one hour to 02:30+02:00 will result in 02:30+01:00
   *     (moving from summer to winter time)
   * Adding one hour to 02:30+01:00 will result in 03:30+01:00
   *     (both in winter time)
   * Adding three hours to 01:30+02:00 will result in 03:30+01:00
   *     (moving from summer to winter time)
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the hours added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusHours(hours: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of minutes added.
   * 
   * This operates on the instant time-line, such that adding one minute will
   * always be a duration of one minute later.
   * This may cause the local date-time to change by an amount other than one minute.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the minutes added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMinutes(minutes: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of seconds added.
   * 
   * This operates on the instant time-line, such that adding one second will
   * always be a duration of one second later.
   * This may cause the local date-time to change by an amount other than one second.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the seconds added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusSeconds(seconds: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of nanoseconds added.
   * 
   * This operates on the instant time-line, such that adding one nano will
   * always be a duration of one nano later.
   * This may cause the local date-time to change by an amount other than one nano.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to add, may be negative
   * @return a `ZonedDateTime` based on this date-time with the nanoseconds added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusNanos(nanos: number): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `ZonedDateTime` based on this date-time with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): ZonedDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns a `ZonedDateTime`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * The calculation for date and time units differ.
   * 
   * Date units operate on the local time-line.
   * The period is first subtracted from the local date-time, then converted back
   * to a zoned date-time using the zone ID.
   * The conversion uses {@link #ofLocal(LocalDateTime, ZoneId, ZoneOffset)}
   * with the offset before the subtraction.
   * 
   * Time units operate on the instant time-line.
   * The period is first subtracted from the local date-time, then converted back to
   * a zoned date-time using the zone ID.
   * The conversion uses {@link #ofInstant(LocalDateTime, ZoneOffset, ZoneId)}
   * with the offset before the subtraction.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `ZonedDateTime` based on this date-time with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of years subtracted.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#minusYears(long) subtracting years} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the years subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusYears(years: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of months subtracted.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#minusMonths(long) subtracting months} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the months subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMonths(months: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of weeks subtracted.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#minusWeeks(long) subtracting weeks} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the weeks subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusWeeks(weeks: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of days subtracted.
   * 
   * This operates on the local time-line,
   * {@link LocalDateTime#minusDays(long) subtracting days} to the local date-time.
   * This is then converted back to a `ZonedDateTime`, using the zone ID
   * to obtain the offset.
   * 
   * When converting back to `ZonedDateTime`, if the local date-time is in an overlap,
   * then the offset will be retained if possible, otherwise the earlier offset will be used.
   * If in a gap, the local date-time will be adjusted forward by the length of the gap.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the days subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusDays(days: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of hours subtracted.
   * 
   * This operates on the instant time-line, such that subtracting one hour will
   * always be a duration of one hour earlier.
   * This may cause the local date-time to change by an amount other than one hour.
   * Note that this is a different approach to that used by days, months and years,
   * thus subtracting one day is not the same as adding 24 hours.
   * 
   * For example, consider a time-zone, such as 'Europe/Paris', where the
   * Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
   * changing from offset +02:00 in summer to +01:00 in winter.
   * 
   * Subtracting one hour from 03:30+01:00 will result in 02:30+01:00
   *     (both in winter time)
   * Subtracting one hour from 02:30+01:00 will result in 02:30+02:00
   *     (moving from winter to summer time)
   * Subtracting one hour from 02:30+02:00 will result in 01:30+02:00
   *     (both in summer time)
   * Subtracting three hours from 03:30+01:00 will result in 01:30+02:00
   *     (moving from winter to summer time)
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the hours subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusHours(hours: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of minutes subtracted.
   * 
   * This operates on the instant time-line, such that subtracting one minute will
   * always be a duration of one minute earlier.
   * This may cause the local date-time to change by an amount other than one minute.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the minutes subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMinutes(minutes: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of seconds subtracted.
   * 
   * This operates on the instant time-line, such that subtracting one second will
   * always be a duration of one second earlier.
   * This may cause the local date-time to change by an amount other than one second.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the seconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusSeconds(seconds: number): ZonedDateTime;
  /**
   * Returns a copy of this `ZonedDateTime` with the specified number of nanoseconds subtracted.
   * 
   * This operates on the instant time-line, such that subtracting one nano will
   * always be a duration of one nano earlier.
   * This may cause the local date-time to change by an amount other than one nano.
   * Note that this is a different approach to that used by days, months and years.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to subtract, may be negative
   * @return a `ZonedDateTime` based on this date-time with the nanoseconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusNanos(nanos: number): ZonedDateTime;
  /**
   * Queries this date-time using the specified query.
   * 
   * This queries this date-time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Calculates the amount of time until another date-time in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ZonedDateTime`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date-time.
   * The result will be negative if the end is before the start.
   * For example, the amount in days between two date-times can be calculated
   * using `startDateTime.until(endDateTime, DAYS)`.
   * 
   * The `Temporal` passed to this method is converted to a
   * `ZonedDateTime` using {@link #from(TemporalAccessor)}.
   * If the time-zone differs between the two zoned date-times, the specified
   * end date-time is normalized to have the same zone as this date-time.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two date-times.
   * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z
   * will only be one month as it is one minute short of two months.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS` and `HALF_DAYS`, `DAYS`,
   * `WEEKS`, `MONTHS`, `YEARS`, `DECADES`,
   * `CENTURIES`, `MILLENNIA` and `ERAS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * The calculation for date and time units differ.
   * 
   * Date units operate on the local time-line, using the local date-time.
   * For example, the period from noon on day 1 to noon the following day
   * in days will always be counted as exactly one day, irrespective of whether
   * there was a daylight savings change or not.
   * 
   * Time units operate on the instant time-line.
   * The calculation effectively converts both zoned date-times to instants
   * and then calculates the period between the instants.
   * For example, the period from noon on day 1 to noon the following day
   * in hours may be 23, 24 or 25 hours (or some other amount) depending on
   * whether there was a daylight savings change or not.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a `ZonedDateTime`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date-time and the end date-time
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ZonedDateTime`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this date-time using the specified formatter.
   * 
   * This date-time will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date-time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Converts this date-time to an `OffsetDateTime`.
   * 
   * This creates an offset date-time using the local date-time and offset.
   * The zone ID is ignored.
   *
   * @return an offset date-time representing the same local date-time and offset, not null
  */
  toOffsetDateTime(): OffsetDateTime;
  /**
   * Checks if this date-time is equal to another date-time.
   * 
   * The comparison is based on the offset date-time and the zone.
   * Only objects of type `ZonedDateTime` are compared, other types return false.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date-time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date-time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date-time as a `String`, such as
   * `2007-12-03T10:15:30+01:00[Europe/Paris]`.
   * 
   * The format consists of the `LocalDateTime` followed by the `ZoneOffset`.
   * If the `ZoneId` is not the same as the offset, then the ID is output.
   * The output is compatible with ISO-8601 if the offset and ID are the same,
   * and the seconds in the offset are zero.
   *
   * @return a string representation of this date-time, not null
  */
  toString(): string;
}
export interface ZonedDateTime extends Temporal, ChronoZonedDateTime<LocalDate>, Serializable {}
/**
 * A time-based amount of time, such as '34.5 seconds'.
 * 
 * This class models a quantity or amount of time in terms of seconds and nanoseconds.
 * It can be accessed using other duration-based units, such as minutes and hours.
 * In addition, the {@link ChronoUnit#DAYS DAYS} unit can be used and is treated as
 * exactly equal to 24 hours, thus ignoring daylight savings effects.
 * See {@link Period} for the date-based equivalent to this class.
 * 
 * A physical duration could be of infinite length.
 * For practicality, the duration is stored with constraints similar to {@link Instant}.
 * The duration uses nanosecond resolution with a maximum value of the seconds that can
 * be held in a `long`. This is greater than the current estimated age of the universe.
 * 
 * The range of a duration requires the storage of a number larger than a `long`.
 * To achieve this, the class stores a `long` representing seconds and an `int`
 * representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 * The model is of a directed duration, meaning that the duration may be negative.
 * 
 * The duration is measured in "seconds", but these are not necessarily identical to
 * the scientific "SI second" definition based on atomic clocks.
 * This difference only impacts durations measured near a leap-second and should not affect
 * most applications.
 * See {@link Instant} for a discussion as to the meaning of the second and time-scales.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class Duration extends TemporalAmount {
  /**
   * Constant for a duration of zero.
  */
  static readonly ZERO: Duration;
  /**
   * Obtains a `Duration` representing a number of standard 24 hour days.
   * 
   * The seconds are calculated based on the standard definition of a day,
   * where each day is 86400 seconds which implies a 24 hour day.
   * The nanosecond in second field is set to zero.
   *
   * @param days  the number of days, positive or negative
   * @return a `Duration`, not null
   * @throws ArithmeticException if the input days exceeds the capacity of `Duration`
  */
  static ofDays(days: number): Duration;
  /**
   * Obtains a `Duration` representing a number of standard hours.
   * 
   * The seconds are calculated based on the standard definition of an hour,
   * where each hour is 3600 seconds.
   * The nanosecond in second field is set to zero.
   *
   * @param hours  the number of hours, positive or negative
   * @return a `Duration`, not null
   * @throws ArithmeticException if the input hours exceeds the capacity of `Duration`
  */
  static ofHours(hours: number): Duration;
  /**
   * Obtains a `Duration` representing a number of standard minutes.
   * 
   * The seconds are calculated based on the standard definition of a minute,
   * where each minute is 60 seconds.
   * The nanosecond in second field is set to zero.
   *
   * @param minutes  the number of minutes, positive or negative
   * @return a `Duration`, not null
   * @throws ArithmeticException if the input minutes exceeds the capacity of `Duration`
  */
  static ofMinutes(minutes: number): Duration;
  /**
   * Obtains a `Duration` representing a number of seconds.
   * 
   * The nanosecond in second field is set to zero.
   *
   * @param seconds  the number of seconds, positive or negative
   * @return a `Duration`, not null
  */
  static ofSeconds(seconds: number): Duration;
  /**
   * Obtains a `Duration` representing a number of seconds and an
   * adjustment in nanoseconds.
   * 
   * This method allows an arbitrary number of nanoseconds to be passed in.
   * The factory will alter the values of the second and nanosecond in order
   * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
   * For example, the following will result in exactly the same duration:
   *      *  Duration.ofSeconds(3, 1);
   *  Duration.ofSeconds(4, -999_999_999);
   *  Duration.ofSeconds(2, 1000_000_001);
   * 
   *
   * @param seconds  the number of seconds, positive or negative
   * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
   * @return a `Duration`, not null
   * @throws ArithmeticException if the adjustment causes the seconds to exceed the capacity of `Duration`
  */
  static ofSeconds(seconds: number, nanoAdjustment: number): Duration;
  /**
   * Obtains a `Duration` representing a number of milliseconds.
   * 
   * The seconds and nanoseconds are extracted from the specified milliseconds.
   *
   * @param millis  the number of milliseconds, positive or negative
   * @return a `Duration`, not null
  */
  static ofMillis(millis: number): Duration;
  /**
   * Obtains a `Duration` representing a number of nanoseconds.
   * 
   * The seconds and nanoseconds are extracted from the specified nanoseconds.
   *
   * @param nanos  the number of nanoseconds, positive or negative
   * @return a `Duration`, not null
  */
  static ofNanos(nanos: number): Duration;
  /**
   * Obtains a `Duration` representing an amount in the specified unit.
   * 
   * The parameters represent the two parts of a phrase like '6 Hours'. For example:
   *      *  Duration.of(3, SECONDS);
   *  Duration.of(465, HOURS);
   * 
   * Only a subset of units are accepted by this method.
   * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
   * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
   *
   * @param amount  the amount of the duration, measured in terms of the unit, positive or negative
   * @param unit  the unit that the duration is measured in, must have an exact duration, not null
   * @return a `Duration`, not null
   * @throws DateTimeException if the period unit has an estimated duration
   * @throws ArithmeticException if a numeric overflow occurs
  */
  static of(amount: number, unit: TemporalUnit): Duration;
  /**
   * Obtains an instance of `Duration` from a temporal amount.
   * 
   * This obtains a duration based on the specified amount.
   * A `TemporalAmount` represents an  amount of time, which may be
   * date-based or time-based, which this factory extracts to a duration.
   * 
   * The conversion loops around the set of units from the amount and uses
   * the {@linkplain TemporalUnit#getDuration() duration} of the unit to
   * calculate the total `Duration`.
   * Only a subset of units are accepted by this method. The unit must either
   * have an {@linkplain TemporalUnit#isDurationEstimated() exact duration}
   * or be {@link ChronoUnit#DAYS} which is treated as 24 hours.
   * If any other units are found then an exception is thrown.
   *
   * @param amount  the temporal amount to convert, not null
   * @return the equivalent duration, not null
   * @throws DateTimeException if unable to convert to a `Duration`
   * @throws ArithmeticException if numeric overflow occurs
  */
  static from(amount: TemporalAmount): Duration;
  /**
   * Obtains a `Duration` from a text string such as `PnDTnHnMn.nS`.
   * 
   * This will parse a textual representation of a duration, including the
   * string produced by `toString()`. The formats accepted are based
   * on the ISO-8601 duration format `PnDTnHnMn.nS` with days
   * considered to be exactly 24 hours.
   * 
   * The string starts with an optional sign, denoted by the ASCII negative
   * or positive symbol. If negative, the whole period is negated.
   * The ASCII letter "P" is next in upper or lower case.
   * There are then four sections, each consisting of a number and a suffix.
   * The sections have suffixes in ASCII of "D", "H", "M" and "S" for
   * days, hours, minutes and seconds, accepted in upper or lower case.
   * The suffixes must occur in order. The ASCII letter "T" must occur before
   * the first occurrence, if any, of an hour, minute or second section.
   * At least one of the four sections must be present, and if "T" is present
   * there must be at least one section after the "T".
   * The number part of each section must consist of one or more ASCII digits.
   * The number may be prefixed by the ASCII negative or positive symbol.
   * The number of days, hours and minutes must parse to a `long`.
   * The number of seconds must parse to a `long` with optional fraction.
   * The decimal point may be either a dot or a comma.
   * The fractional part may have from zero to 9 digits.
   * 
   * The leading plus/minus sign, and negative values for other units are
   * not part of the ISO-8601 standard.
   * 
   * Examples:
   *      *    "PT20.345S" -- parses as "20.345 seconds"
   *    "PT15M"     -- parses as "15 minutes" (where a minute is 60 seconds)
   *    "PT10H"     -- parses as "10 hours" (where an hour is 3600 seconds)
   *    "P2D"       -- parses as "2 days" (where a day is 24 hours or 86400 seconds)
   *    "P2DT3H4M"  -- parses as "2 days, 3 hours and 4 minutes"
   *    "PT-6H3M"    -- parses as "-6 hours and +3 minutes"
   *    "-PT6H3M"    -- parses as "-6 hours and -3 minutes"
   *    "-PT-6H+3M"  -- parses as "+6 hours and -3 minutes"
   * 
   *
   * @param text  the text to parse, not null
   * @return the parsed duration, not null
   * @throws DateTimeParseException if the text cannot be parsed to a duration
  */
  static parse(text: CharSequence): Duration;
  /**
   * Obtains a `Duration` representing the duration between two temporal objects.
   * 
   * This calculates the duration between two temporal objects. If the objects
   * are of different types, then the duration is calculated based on the type
   * of the first object. For example, if the first argument is a `LocalTime`
   * then the second argument is converted to a `LocalTime`.
   * 
   * The specified temporal objects must support the {@link ChronoUnit#SECONDS SECONDS} unit.
   * For full accuracy, either the {@link ChronoUnit#NANOS NANOS} unit or the
   * {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} field should be supported.
   * 
   * The result of this method can be a negative period if the end is before the start.
   * To guarantee to obtain a positive duration call {@link #abs()} on the result.
   *
   * @param startInclusive  the start instant, inclusive, not null
   * @param endExclusive  the end instant, exclusive, not null
   * @return a `Duration`, not null
   * @throws DateTimeException if the seconds between the temporals cannot be obtained
   * @throws ArithmeticException if the calculation exceeds the capacity of `Duration`
  */
  static between(startInclusive: Temporal, endExclusive: Temporal): Duration;
  /**
   * Gets the value of the requested unit.
   * 
   * This returns a value for each of the two supported units,
   * {@link ChronoUnit#SECONDS SECONDS} and {@link ChronoUnit#NANOS NANOS}.
   * All other units throw an exception.
   *
   * @param unit the `TemporalUnit` for which to return the value
   * @return the long value of the unit
   * @throws DateTimeException if the unit is not supported
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  get(unit: TemporalUnit): number;
  /**
   * Gets the set of units supported by this duration.
   * 
   * The supported units are {@link ChronoUnit#SECONDS SECONDS},
   * and {@link ChronoUnit#NANOS NANOS}.
   * They are returned in the order seconds, nanos.
   * 
   * This set can be used in conjunction with {@link #get(TemporalUnit)}
   * to access the entire state of the duration.
   *
   * @return a list containing the seconds and nanos units, not null
  */
  get units(): TemporalUnit[];
  /**
   * Checks if this duration is positive, excluding zero.
   * 
   * A `Duration` represents a directed distance between two points on
   * the time-line and can therefore be positive, zero or negative.
   * This method checks whether the length is greater than zero.
   *
   * @return true if this duration has a total length greater than zero
   * @since 18
  */
  isPositive(): boolean;
  /**
   * Checks if this duration is zero length.
   * 
   * A `Duration` represents a directed distance between two points on
   * the time-line and can therefore be positive, zero or negative.
   * This method checks whether the length is zero.
   *
   * @return true if this duration has a total length equal to zero
  */
  isZero(): boolean;
  /**
   * Checks if this duration is negative, excluding zero.
   * 
   * A `Duration` represents a directed distance between two points on
   * the time-line and can therefore be positive, zero or negative.
   * This method checks whether the length is less than zero.
   *
   * @return true if this duration has a total length less than zero
  */
  isNegative(): boolean;
  /**
   * Gets the number of seconds in this duration.
   * 
   * The length of the duration is stored using two fields - seconds and nanoseconds.
   * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
   * the length in seconds.
   * The total duration is defined by calling this method and {@link #getNano()}.
   * 
   * A `Duration` represents a directed distance between two points on the time-line.
   * A negative duration is expressed by the negative sign of the seconds part.
   * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
   *
   * @return the whole seconds part of the length of the duration, positive or negative
  */
  get seconds(): number;
  /**
   * Gets the number of nanoseconds within the second in this duration.
   * 
   * The length of the duration is stored using two fields - seconds and nanoseconds.
   * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
   * the length in seconds.
   * The total duration is defined by calling this method and {@link #getSeconds()}.
   * 
   * A `Duration` represents a directed distance between two points on the time-line.
   * A negative duration is expressed by the negative sign of the seconds part.
   * A duration of -1 nanosecond is stored as -1 seconds plus 999,999,999 nanoseconds.
   *
   * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns a copy of this duration with the specified amount of seconds.
   * 
   * This returns a duration with the specified seconds, retaining the
   * nano-of-second part of this duration.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to represent, may be negative
   * @return a `Duration` based on this period with the requested seconds, not null
  */
  withSeconds(seconds: number): Duration;
  /**
   * Returns a copy of this duration with the specified nano-of-second.
   * 
   * This returns a duration with the specified nano-of-second, retaining the
   * seconds part of this duration.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @return a `Duration` based on this period with the requested nano-of-second, not null
   * @throws DateTimeException if the nano-of-second is invalid
  */
  withNanos(nanoOfSecond: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param duration  the duration to add, positive or negative, not null
   * @return a `Duration` based on this duration with the specified duration added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(duration: Duration): Duration;
  /**
   * Returns a copy of this duration with the specified duration added.
   * 
   * The duration amount is measured in terms of the specified unit.
   * Only a subset of units are accepted by this method.
   * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
   * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, measured in terms of the unit, positive or negative
   * @param unit  the unit that the amount is measured in, must have an exact duration, not null
   * @return a `Duration` based on this duration with the specified duration added, not null
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): Duration;
  /**
   * Returns a copy of this duration with the specified duration in standard 24 hour days added.
   * 
   * The number of days is multiplied by 86400 to obtain the number of seconds to add.
   * This is based on the standard definition of a day as 24 hours.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToAdd  the days to add, positive or negative
   * @return a `Duration` based on this duration with the specified days added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusDays(daysToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in hours added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hoursToAdd  the hours to add, positive or negative
   * @return a `Duration` based on this duration with the specified hours added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusHours(hoursToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in minutes added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutesToAdd  the minutes to add, positive or negative
   * @return a `Duration` based on this duration with the specified minutes added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusMinutes(minutesToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in seconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondsToAdd  the seconds to add, positive or negative
   * @return a `Duration` based on this duration with the specified seconds added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusSeconds(secondsToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in milliseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param millisToAdd  the milliseconds to add, positive or negative
   * @return a `Duration` based on this duration with the specified milliseconds added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusMillis(millisToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in nanoseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToAdd  the nanoseconds to add, positive or negative
   * @return a `Duration` based on this duration with the specified nanoseconds added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusNanos(nanosToAdd: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param duration  the duration to subtract, positive or negative, not null
   * @return a `Duration` based on this duration with the specified duration subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(duration: Duration): Duration;
  /**
   * Returns a copy of this duration with the specified duration subtracted.
   * 
   * The duration amount is measured in terms of the specified unit.
   * Only a subset of units are accepted by this method.
   * The unit must either have an {@linkplain TemporalUnit#isDurationEstimated() exact duration} or
   * be {@link ChronoUnit#DAYS} which is treated as 24 hours. Other units throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, measured in terms of the unit, positive or negative
   * @param unit  the unit that the amount is measured in, must have an exact duration, not null
   * @return a `Duration` based on this duration with the specified duration subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): Duration;
  /**
   * Returns a copy of this duration with the specified duration in standard 24 hour days subtracted.
   * 
   * The number of days is multiplied by 86400 to obtain the number of seconds to subtract.
   * This is based on the standard definition of a day as 24 hours.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param daysToSubtract  the days to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified days subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusDays(daysToSubtract: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in hours subtracted.
   * 
   * The number of hours is multiplied by 3600 to obtain the number of seconds to subtract.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hoursToSubtract  the hours to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified hours subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusHours(hoursToSubtract: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in minutes subtracted.
   * 
   * The number of hours is multiplied by 60 to obtain the number of seconds to subtract.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutesToSubtract  the minutes to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified minutes subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusMinutes(minutesToSubtract: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in seconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondsToSubtract  the seconds to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified seconds subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusSeconds(secondsToSubtract: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in milliseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param millisToSubtract  the milliseconds to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified milliseconds subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusMillis(millisToSubtract: number): Duration;
  /**
   * Returns a copy of this duration with the specified duration in nanoseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
   * @return a `Duration` based on this duration with the specified nanoseconds subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusNanos(nanosToSubtract: number): Duration;
  /**
   * Returns a copy of this duration multiplied by the scalar.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param multiplicand  the value to multiply the duration by, positive or negative
   * @return a `Duration` based on this duration multiplied by the specified scalar, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  multipliedBy(multiplicand: number): Duration;
  /**
   * Returns a copy of this duration divided by the specified value.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param divisor  the value to divide the duration by, positive or negative, not zero
   * @return a `Duration` based on this duration divided by the specified divisor, not null
   * @throws ArithmeticException if the divisor is zero or if numeric overflow occurs
  */
  dividedBy(divisor: number): Duration;
  /**
   * Returns number of whole times a specified Duration occurs within this Duration.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param divisor the value to divide the duration by, positive or negative, not null
   * @return number of whole times, rounded toward zero, a specified
   *         `Duration` occurs within this Duration, may be negative
   * @throws ArithmeticException if the divisor is zero, or if numeric overflow occurs
   * @since 9
  */
  dividedBy(divisor: Duration): number;
  /**
   * Returns a copy of this duration with the length negated.
   * 
   * This method swaps the sign of the total length of this duration.
   * For example, `PT1.3S` will be returned as `PT-1.3S`.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `Duration` based on this duration with the amount negated, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  negated(): Duration;
  /**
   * Returns a copy of this duration with a positive length.
   * 
   * This method returns a positive duration by effectively removing the sign from any negative total length.
   * For example, `PT-1.3S` will be returned as `PT1.3S`.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `Duration` based on this duration with an absolute length, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  abs(): Duration;
  /**
   * Adds this duration to the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this duration added.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#plus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisDuration.addTo(dateTime);
   *   dateTime = dateTime.plus(thisDuration);
   * 
   * 
   * The calculation will add the seconds, then nanos.
   * Only non-zero amounts will be added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to add
   * @throws ArithmeticException if numeric overflow occurs
  */
  addTo(temporal: Temporal): Temporal;
  /**
   * Subtracts this duration from the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this duration subtracted.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#minus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisDuration.subtractFrom(dateTime);
   *   dateTime = dateTime.minus(thisDuration);
   * 
   * 
   * The calculation will subtract the seconds, then nanos.
   * Only non-zero amounts will be added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to subtract
   * @throws ArithmeticException if numeric overflow occurs
  */
  subtractFrom(temporal: Temporal): Temporal;
  /**
   * Gets the number of days in this duration.
   * 
   * This returns the total number of days in the duration by dividing the
   * number of seconds by 86400.
   * This is based on the standard definition of a day as 24 hours.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of days in the duration, may be negative
  */
  toDays(): number;
  /**
   * Gets the number of hours in this duration.
   * 
   * This returns the total number of hours in the duration by dividing the
   * number of seconds by 3600.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of hours in the duration, may be negative
  */
  toHours(): number;
  /**
   * Gets the number of minutes in this duration.
   * 
   * This returns the total number of minutes in the duration by dividing the
   * number of seconds by 60.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of minutes in the duration, may be negative
  */
  toMinutes(): number;
  /**
   * Gets the number of seconds in this duration.
   * 
   * This returns the total number of whole seconds in the duration.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the whole seconds part of the length of the duration, positive or negative
   * @since 9
  */
  toSeconds(): number;
  /**
   * Converts this duration to the total length in milliseconds.
   * 
   * If this duration is too large to fit in a `long` milliseconds, then an
   * exception is thrown.
   * 
   * If this duration has greater than millisecond precision, then the conversion
   * will drop any excess precision information as though the amount in nanoseconds
   * was subject to integer division by one million.
   *
   * @return the total length of the duration in milliseconds
   * @throws ArithmeticException if numeric overflow occurs
  */
  toMillis(): number;
  /**
   * Converts this duration to the total length in nanoseconds expressed as a `long`.
   * 
   * If this duration is too large to fit in a `long` nanoseconds, then an
   * exception is thrown.
   *
   * @return the total length of the duration in nanoseconds
   * @throws ArithmeticException if numeric overflow occurs
  */
  toNanos(): number;
  /**
   * Extracts the number of days in the duration.
   * 
   * This returns the total number of days in the duration by dividing the
   * number of seconds by 86400.
   * This is based on the standard definition of a day as 24 hours.
   * 
   * This instance is immutable and unaffected by this method call.
   * @apiNote
   * This method behaves exactly the same way as {@link #toDays()}.
   *
   * @return the number of days in the duration, may be negative
   * @since 9
  */
  toDaysPart(): number;
  /**
   * Extracts the number of hours part in the duration.
   * 
   * This returns the number of remaining hours when dividing {@link #toHours}
   * by hours in a day.
   * This is based on the standard definition of a day as 24 hours.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of hours part in the duration, may be negative
   * @since 9
  */
  toHoursPart(): number;
  /**
   * Extracts the number of minutes part in the duration.
   * 
   * This returns the number of remaining minutes when dividing {@link #toMinutes}
   * by minutes in an hour.
   * This is based on the standard definition of an hour as 60 minutes.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of minutes parts in the duration, may be negative
   * @since 9
  */
  toMinutesPart(): number;
  /**
   * Extracts the number of seconds part in the duration.
   * 
   * This returns the remaining seconds when dividing {@link #toSeconds}
   * by seconds in a minute.
   * This is based on the standard definition of a minute as 60 seconds.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of seconds parts in the duration, may be negative
   * @since 9
  */
  toSecondsPart(): number;
  /**
   * Extracts the number of milliseconds part of the duration.
   * 
   * This returns the milliseconds part by dividing the number of nanoseconds by 1,000,000.
   * The length of the duration is stored using two fields - seconds and nanoseconds.
   * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
   * the length in seconds.
   * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the number of milliseconds part of the duration.
   * @since 9
  */
  toMillisPart(): number;
  /**
   * Get the nanoseconds part within seconds of the duration.
   * 
   * The length of the duration is stored using two fields - seconds and nanoseconds.
   * The nanoseconds part is a value from 0 to 999,999,999 that is an adjustment to
   * the length in seconds.
   * The total duration is defined by calling {@link #getNano()} and {@link #getSeconds()}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return the nanoseconds within the second part of the length of the duration, from 0 to 999,999,999
   * @since 9
  */
  toNanosPart(): number;
  /**
   * Returns a copy of this `Duration` truncated to the specified unit.
   * 
   * Truncating the duration returns a copy of the original with conceptual fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
   * round down towards zero to the nearest minute, setting the seconds and
   * nanoseconds to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all
   * {@linkplain ChronoUnit#isTimeBased() time-based units on `ChronoUnit`}
   * and {@link ChronoUnit#DAYS DAYS}. Other ChronoUnits throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit the unit to truncate to, not null
   * @return a `Duration` based on this duration with the time truncated, not null
   * @throws DateTimeException if the unit is invalid for truncation
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @since 9
  */
  truncatedTo(unit: TemporalUnit): Duration;
  /**
   * Compares this duration to the specified `Duration`.
   * 
   * The comparison is based on the total length of the durations.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param otherDuration the other duration to compare to, not null
   * @return the comparator value, that is less than zero if this duration is less than `otherDuration`,
   *          zero if they are equal, greater than zero if this duration is greater than `otherDuration`
  */
  compareTo(otherDuration: Duration): number;
  /**
   * Checks if this duration is equal to the specified `Duration`.
   * 
   * The comparison is based on the total length of the durations.
   *
   * @param other the other duration, null returns false
   * @return true if the other duration is equal to this one
  */
  equals(other: any): boolean;
  /**
   * A hash code for this duration.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * A string representation of this duration using ISO-8601 seconds
   * based representation, such as `PT8H6M12.345S`.
   * 
   * The format of the returned string will be `PTnHnMnS`, where n is
   * the relevant hours, minutes or seconds part of the duration.
   * Any fractional seconds are placed after a decimal point in the seconds section.
   * If a section has a zero value, it is omitted.
   * The hours, minutes and seconds will all have the same sign.
   * 
   * Examples:
   *      *    "20.345 seconds"                 -- "PT20.345S
   *    "15 minutes" (15 * 60 seconds)   -- "PT15M"
   *    "10 hours" (10 * 3600 seconds)   -- "PT10H"
   *    "2 days" (2 * 86400 seconds)     -- "PT48H"
   * 
   * Note that multiples of 24 hours are not output as days to avoid confusion
   * with `Period`.
   *
   * @return an ISO-8601 representation of this duration, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface Duration extends TemporalAmount, Comparable<Duration>, Serializable {}
/**
 * A time-zone offset from Greenwich/UTC, such as `+02:00`.
 * 
 * A time-zone offset is the amount of time that a time-zone differs from Greenwich/UTC.
 * This is usually a fixed number of hours and minutes.
 * 
 * Different parts of the world have different time-zone offsets.
 * The rules for how offsets vary by place and time of year are captured in the
 * {@link ZoneId} class.
 * 
 * For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours
 * ahead in summer. The `ZoneId` instance for Paris will reference two
 * `ZoneOffset` instances - a `+01:00` instance for winter,
 * and a `+02:00` instance for summer.
 * 
 * In 2008, time-zone offsets around the world extended from -12:00 to +14:00.
 * To prevent any problems with that range being extended, yet still provide
 * validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.
 * 
 * This class is designed for use with the ISO calendar system.
 * The fields of hours, minutes and seconds make assumptions that are valid for the
 * standard ISO definitions of those fields. This class may be used with other
 * calendar systems providing the definition of the time fields matches those
 * of the ISO calendar system.
 * 
 * Instances of `ZoneOffset` must be compared using {@link #equals}.
 * Implementations may choose to cache certain common offsets, however
 * applications must not rely on such caching.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ZoneOffset extends ZoneId {
  /**
   * The time-zone offset for UTC, with an ID of 'Z'.
  */
  static readonly UTC: ZoneOffset;
  /**
   * Constant for the minimum supported offset.
  */
  static readonly MIN: ZoneOffset;
  /**
   * Constant for the maximum supported offset.
  */
  static readonly MAX: ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` using the ID.
   * 
   * This method parses the string ID of a `ZoneOffset` to
   * return an instance. The parsing accepts all the formats generated by
   * {@link #getId()}, plus some additional formats:
   * 
   * `Z` - for UTC
   * `+h`
   * `+hh`
   * `+hh:mm`
   * `-hh:mm`
   * `+hhmm`
   * `-hhmm`
   * `+hh:mm:ss`
   * `-hh:mm:ss`
   * `+hhmmss`
   * `-hhmmss`
   * 
   * Note that  means either the plus or minus symbol.
   * 
   * The ID of the returned offset will be normalized to one of the formats
   * described by {@link #getId()}.
   * 
   * The maximum supported range is from +18:00 to -18:00 inclusive.
   *
   * @param offsetId  the offset ID, not null
   * @return the zone-offset, not null
   * @throws DateTimeException if the offset ID is invalid
  */
  static of(offsetId: string): ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` using an offset in hours.
   *
   * @param hours  the time-zone offset in hours, from -18 to +18
   * @return the zone-offset, not null
   * @throws DateTimeException if the offset is not in the required range
  */
  static ofHours(hours: number): ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` using an offset in
   * hours and minutes.
   * 
   * The sign of the hours and minutes components must match.
   * Thus, if the hours is negative, the minutes must be negative or zero.
   * If the hours is zero, the minutes may be positive, negative or zero.
   *
   * @param hours  the time-zone offset in hours, from -18 to +18
   * @param minutes  the time-zone offset in minutes, from 0 to 59, sign matches hours
   * @return the zone-offset, not null
   * @throws DateTimeException if the offset is not in the required range
  */
  static ofHoursMinutes(hours: number, minutes: number): ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` using an offset in
   * hours, minutes and seconds.
   * 
   * The sign of the hours, minutes and seconds components must match.
   * Thus, if the hours is negative, the minutes and seconds must be negative or zero.
   *
   * @param hours  the time-zone offset in hours, from -18 to +18
   * @param minutes  the time-zone offset in minutes, from 0 to 59, sign matches hours and seconds
   * @param seconds  the time-zone offset in seconds, from 0 to 59, sign matches hours and minutes
   * @return the zone-offset, not null
   * @throws DateTimeException if the offset is not in the required range
  */
  static ofHoursMinutesSeconds(hours: number, minutes: number, seconds: number): ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` from a temporal object.
   * 
   * This obtains an offset based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ZoneOffset`.
   * 
   * A `TemporalAccessor` represents some form of date and time information.
   * This factory converts the arbitrary temporal object to an instance of `ZoneOffset`.
   * 
   * The conversion uses the {@link TemporalQueries#offset()} query, which relies
   * on extracting the {@link ChronoField#OFFSET_SECONDS OFFSET_SECONDS} field.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ZoneOffset::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the zone-offset, not null
   * @throws DateTimeException if unable to convert to an `ZoneOffset`
  */
  static from(temporal: TemporalAccessor): ZoneOffset;
  /**
   * Obtains an instance of `ZoneOffset` specifying the total offset in seconds
   * 
   * The offset must be in the range `-18:00` to `+18:00`, which corresponds to -64800 to +64800.
   *
   * @param totalSeconds  the total time-zone offset in seconds, from -64800 to +64800
   * @return the ZoneOffset, not null
   * @throws DateTimeException if the offset is not in the required range
  */
  static ofTotalSeconds(totalSeconds: number): ZoneOffset;
  /**
   * Gets the total zone offset in seconds.
   * 
   * This is the primary way to access the offset amount.
   * It returns the total of the hours, minutes and seconds fields as a
   * single offset that can be added to a time.
   *
   * @return the total zone offset amount in seconds
  */
  get totalSeconds(): number;
  /**
   * Gets the normalized zone offset ID.
   * 
   * The ID is minor variation to the standard ISO-8601 formatted string
   * for the offset. There are three formats:
   * 
   * `Z` - for UTC (ISO-8601)
   * `+hh:mm` or `-hh:mm` - if the seconds are zero (ISO-8601)
   * `+hh:mm:ss` or `-hh:mm:ss` - if the seconds are non-zero (not ISO-8601)
   * 
   *
   * @return the zone offset ID, not null
  */
  get id(): string;
  /**
   * Gets the associated time-zone rules.
   * 
   * The rules will always return this offset when queried.
   * The implementation class is immutable, thread-safe and serializable.
   *
   * @return the rules, not null
  */
  get rules(): ZoneRules;
  normalized(): ZoneId;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this offset can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `OFFSET_SECONDS` field returns true.
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this offset, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This offset is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this offset as an `int`.
   * 
   * This queries this offset for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `OFFSET_SECONDS` field returns the value of the offset.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this offset as a `long`.
   * 
   * This queries this offset for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `OFFSET_SECONDS` field returns the value of the offset.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Queries this offset using the specified query.
   * 
   * This queries this offset using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same offset as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the offset changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#OFFSET_SECONDS} as the field.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisOffset.adjustInto(temporal);
   *   temporal = temporal.with(thisOffset);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Compares this offset to another offset in descending order.
   * 
   * The offsets are compared in the order that they occur for the same time
   * of day around the world. Thus, an offset of `+10:00` comes before an
   * offset of `+09:00` and so on down to `-18:00`.
   * 
   * The comparison is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other date to compare to, not null
   * @return the comparator value, that is less than zero if this totalSeconds is
   *          less than `other` totalSeconds, zero if they are equal,
   *          greater than zero if this totalSeconds is greater than `other` totalSeconds
   * @throws NullPointerException if `other` is null
  */
  compareTo(other: ZoneOffset): number;
  /**
   * Checks if this offset is equal to another offset.
   * 
   * The comparison is based on the amount of the offset in seconds.
   * This is equivalent to a comparison by ID.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other offset
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this offset.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this offset as a `String`, using the normalized ID.
   *
   * @return a string representation of this offset, not null
  */
  toString(): string;
  /**
   * Obtains an instance of `ZoneId` using its ID using a map
   * of aliases to supplement the standard zone IDs.
   * 
   * Many users of time-zones use short abbreviations, such as PST for
   * 'Pacific Standard Time' and PDT for 'Pacific Daylight Time'.
   * These abbreviations are not unique, and so cannot be used as IDs.
   * This method allows a map of string to time-zone to be setup and reused
   * within an application.
   *
   * @param zoneId  the time-zone ID, not null
   * @param aliasMap  a map of alias zone IDs (typically abbreviations) to real zone IDs, not null
   * @return the zone ID, not null
   * @throws DateTimeException if the zone ID has an invalid format
   * @throws ZoneRulesException if the zone ID is a region ID that cannot be found
  */
  static of(zoneId: string, aliasMap: Map<string,string>): ZoneId;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface ZoneOffset extends ZoneId, TemporalAccessor, TemporalAdjuster, Comparable<ZoneOffset>, Serializable {}
/**
 * A time-zone ID, such as `Europe/Paris`.
 * 
 * A `ZoneId` is used to identify the rules used to convert between
 * an {@link Instant} and a {@link LocalDateTime}.
 * There are two distinct types of ID:
 * 
 * Fixed offsets - a fully resolved offset from UTC/Greenwich, that uses
 *  the same offset for all local date-times
 * Geographical regions - an area where a specific set of rules for finding
 *  the offset from UTC/Greenwich apply
 * 
 * Most fixed offsets are represented by {@link ZoneOffset}.
 * Calling {@link #normalized()} on any `ZoneId` will ensure that a
 * fixed offset ID will be represented as a `ZoneOffset`.
 * 
 * The actual rules, describing when and how the offset changes, are defined by {@link ZoneRules}.
 * This class is simply an ID used to obtain the underlying rules.
 * This approach is taken because rules are defined by governments and change
 * frequently, whereas the ID is stable.
 * 
 * The distinction has other effects. Serializing the `ZoneId` will only send
 * the ID, whereas serializing the rules sends the entire data set.
 * Similarly, a comparison of two IDs only examines the ID, whereas
 * a comparison of two rules examines the entire data set.
 *
 * Time-zone IDs
 * The ID is unique within the system.
 * There are three types of ID.
 * 
 * The simplest type of ID is that from `ZoneOffset`.
 * This consists of 'Z' and IDs starting with '+' or '-'.
 * 
 * The next type of ID are offset-style IDs with some form of prefix,
 * such as 'GMT+2' or 'UTC+01:00'.
 * The recognised prefixes are 'UTC', 'GMT' and 'UT'.
 * The offset is the suffix and will be normalized during creation.
 * These IDs can be normalized to a `ZoneOffset` using `normalized()`.
 * 
 * The third type of ID are region-based IDs. A region-based ID must be of
 * two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'.
 * Region-based IDs are defined by configuration, see {@link ZoneRulesProvider}.
 * The configuration focuses on providing the lookup from the ID to the
 * underlying `ZoneRules`.
 * 
 * Time-zone rules are defined by governments and change frequently.
 * There are a number of organizations, known here as groups, that monitor
 * time-zone changes and collate them.
 * The default group is the IANA Time Zone Database (TZDB).
 * Other organizations include IATA (the airline industry body) and Microsoft.
 * 
 * Each group defines its own format for the region ID it provides.
 * The TZDB group defines IDs such as 'Europe/London' or 'America/New_York'.
 * TZDB IDs take precedence over other groups.
 * 
 * It is strongly recommended that the group name is included in all IDs supplied by
 * groups other than TZDB to avoid conflicts. For example, IATA airline time-zone
 * region IDs are typically the same as the three letter airport code.
 * However, the airport of Utrecht has the code 'UTC', which is obviously a conflict.
 * The recommended format for region IDs from groups other than TZDB is 'group~region'.
 * Thus if IATA data were defined, Utrecht airport would be 'IATA~UTC'.
 *
 * Serialization
 * This class can be serialized and stores the string zone ID in the external form.
 * The `ZoneOffset` subclass uses a dedicated format that only stores the
 * offset from UTC/Greenwich.
 * 
 * A `ZoneId` can be deserialized in a Java Runtime where the ID is unknown.
 * For example, if a server-side Java Runtime has been updated with a new zone ID, but
 * the client-side Java Runtime has not been updated. In this case, the `ZoneId`
 * object will exist, and can be queried using `getId`, `equals`,
 * `hashCode`, `toString`, `getDisplayName` and `normalized`.
 * However, any call to `getRules` will fail with `ZoneRulesException`.
 * This approach is designed to allow a {@link ZonedDateTime} to be loaded and
 * queried, but not modified, on a Java Runtime with incomplete time-zone information.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This abstract class permits two implementations, both of which are immutable and
 * thread-safe. One implementation models region-based IDs, the other is `ZoneOffset`
 * modelling offset-based IDs. This difference is visible in serialization.
 *
 * @since 1.8
 * @sealedGraph
*/
export class ZoneId extends Serializable {
  /**
   * A map of zone overrides to enable the short time-zone names to be used.
   * 
   * Use of short zone IDs has been deprecated in `java.util.TimeZone`.
   * This map allows the IDs to continue to be used via the
   * {@link #of(String, Map)} factory method.
   * 
   * This map contains a mapping of the IDs that is in line with TZDB 2005r and
   * later, where 'EST', 'MST' and 'HST' map to IDs which do not include daylight
   * savings.
   * 
   * This maps as follows:
   * 
   * EST - -05:00
   * HST - -10:00
   * MST - -07:00
   * ACT - Australia/Darwin
   * AET - Australia/Sydney
   * AGT - America/Argentina/Buenos_Aires
   * ART - Africa/Cairo
   * AST - America/Anchorage
   * BET - America/Sao_Paulo
   * BST - Asia/Dhaka
   * CAT - Africa/Harare
   * CNT - America/St_Johns
   * CST - America/Chicago
   * CTT - Asia/Shanghai
   * EAT - Africa/Addis_Ababa
   * ECT - Europe/Paris
   * IET - America/Indiana/Indianapolis
   * IST - Asia/Kolkata
   * JST - Asia/Tokyo
   * MIT - Pacific/Apia
   * NET - Asia/Yerevan
   * NST - Pacific/Auckland
   * PLT - Asia/Karachi
   * PNT - America/Phoenix
   * PRT - America/Puerto_Rico
   * PST - America/Los_Angeles
   * SST - Pacific/Guadalcanal
   * VST - Asia/Ho_Chi_Minh
   * 
   * The map is unmodifiable.
  */
  static readonly SHORT_IDS: Map<string,string>;
  /**
   * Gets the system default time-zone.
   * 
   * This queries {@link TimeZone#getDefault()} to find the default time-zone
   * and converts it to a `ZoneId`. If the system default time-zone is changed,
   * then the result of this method will also change.
   *
   * @return the zone ID, not null
   * @throws DateTimeException if the converted zone ID has an invalid format
   * @throws ZoneRulesException if the converted zone region ID cannot be found
  */
  static systemDefault(): ZoneId;
  /**
   * Gets the set of available zone IDs.
   * 
   * This set includes the string form of all available region-based IDs.
   * Offset-based zone IDs are not included in the returned set.
   * The ID can be passed to {@link #of(String)} to create a `ZoneId`.
   * 
   * The set of zone IDs can increase over time, although in a typical application
   * the set of IDs is fixed. Each call to this method is thread-safe.
   *
   * @return a modifiable copy of the set of zone IDs, not null
  */
  static get availableZoneIds(): Set<string>;
  /**
   * Obtains an instance of `ZoneId` using its ID using a map
   * of aliases to supplement the standard zone IDs.
   * 
   * Many users of time-zones use short abbreviations, such as PST for
   * 'Pacific Standard Time' and PDT for 'Pacific Daylight Time'.
   * These abbreviations are not unique, and so cannot be used as IDs.
   * This method allows a map of string to time-zone to be setup and reused
   * within an application.
   *
   * @param zoneId  the time-zone ID, not null
   * @param aliasMap  a map of alias zone IDs (typically abbreviations) to real zone IDs, not null
   * @return the zone ID, not null
   * @throws DateTimeException if the zone ID has an invalid format
   * @throws ZoneRulesException if the zone ID is a region ID that cannot be found
  */
  static of(zoneId: string, aliasMap: Map<string,string>): ZoneId;
  /**
   * Obtains an instance of `ZoneId` from an ID ensuring that the
   * ID is valid and available for use.
   * 
   * This method parses the ID producing a `ZoneId` or `ZoneOffset`.
   * A `ZoneOffset` is returned if the ID is 'Z', or starts with '+' or '-'.
   * The result will always be a valid ID for which {@link ZoneRules} can be obtained.
   * 
   * Parsing matches the zone ID step by step as follows.
   * 
   * If the zone ID equals 'Z', the result is `ZoneOffset.UTC`.
   * If the zone ID consists of a single letter, the zone ID is invalid
   *  and `DateTimeException` is thrown.
   * If the zone ID starts with '+' or '-', the ID is parsed as a
   *  `ZoneOffset` using {@link ZoneOffset#of(String)}.
   * If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a `ZoneId`
   *  with the same ID and rules equivalent to `ZoneOffset.UTC`.
   * If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'
   *  then the ID is a prefixed offset-based ID. The ID is split in two, with
   *  a two or three letter prefix and a suffix starting with the sign.
   *  The suffix is parsed as a {@link ZoneOffset#of(String) ZoneOffset}.
   *  The result will be a `ZoneId` with the specified UTC/GMT/UT prefix
   *  and the normalized offset ID as per {@link ZoneOffset#getId()}.
   *  The rules of the returned `ZoneId` will be equivalent to the
   *  parsed `ZoneOffset`.
   * All other IDs are parsed as region-based zone IDs. Region IDs must
   *  match the regular expression `[A-Za-z][A-Za-z0-9~/._+-]+`
   *  otherwise a `DateTimeException` is thrown. If the zone ID is not
   *  in the configured set of IDs, `ZoneRulesException` is thrown.
   *  The detailed format of the region ID depends on the group supplying the data.
   *  The default set of data is supplied by the IANA Time Zone Database (TZDB).
   *  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.
   *  This is compatible with most IDs from {@link java.util.TimeZone}.
   * 
   *
   * @param zoneId  the time-zone ID, not null
   * @return the zone ID, not null
   * @throws DateTimeException if the zone ID has an invalid format
   * @throws ZoneRulesException if the zone ID is a region ID that cannot be found
  */
  static of(zoneId: string): ZoneId;
  /**
   * Obtains an instance of `ZoneId` wrapping an offset.
   * 
   * If the prefix is "GMT", "UTC", or "UT" a `ZoneId`
   * with the prefix and the non-zero offset is returned.
   * If the prefix is empty `""` the `ZoneOffset` is returned.
   *
   * @param prefix  the time-zone ID, not null
   * @param offset  the offset, not null
   * @return the zone ID, not null
   * @throws IllegalArgumentException if the prefix is not one of
   *     "GMT", "UTC", or "UT", or ""
  */
  static ofOffset(prefix: string, offset: ZoneOffset): ZoneId;
  /**
   * Obtains an instance of `ZoneId` from a temporal object.
   * 
   * This obtains a zone based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ZoneId`.
   * 
   * A `TemporalAccessor` represents some form of date and time information.
   * This factory converts the arbitrary temporal object to an instance of `ZoneId`.
   * 
   * The conversion will try to obtain the zone in a way that favours region-based
   * zones over offset-based zones using {@link TemporalQueries#zone()}.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ZoneId::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the zone ID, not null
   * @throws DateTimeException if unable to convert to a `ZoneId`
  */
  static from(temporal: TemporalAccessor): ZoneId;
  /**
   * Gets the unique time-zone ID.
   * 
   * This ID uniquely defines this object.
   * The format of an offset based ID is defined by {@link ZoneOffset#getId()}.
   *
   * @return the time-zone unique ID, not null
  */
  get id(): string;
  /**
   * Gets the textual representation of the zone, such as 'British Time' or
   * '+02:00'.
   * 
   * This returns the textual name used to identify the time-zone ID,
   * suitable for presentation to the user.
   * The parameters control the style of the returned text and the locale.
   * 
   * If no textual mapping is found then the {@link #getId() full ID} is returned.
   *
   * @param style  the length of the text required, not null
   * @param locale  the locale to use, not null
   * @return the text value of the zone, not null
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
  /**
   * Gets the time-zone rules for this ID allowing calculations to be performed.
   * 
   * The rules provide the functionality associated with a time-zone,
   * such as finding the offset for a given instant or local date-time.
   * 
   * A time-zone can be invalid if it is deserialized in a Java Runtime which
   * does not have the same rules loaded as the Java Runtime that stored it.
   * In this case, calling this method will throw a `ZoneRulesException`.
   * 
   * The rules are supplied by {@link ZoneRulesProvider}. An advanced provider may
   * support dynamic updates to the rules without restarting the Java Runtime.
   * If so, then the result of this method may change over time.
   * Each individual call will be still remain thread-safe.
   * 
   * {@link ZoneOffset} will always return a set of rules where the offset never changes.
   *
   * @return the rules, not null
   * @throws ZoneRulesException if no rules are available for this ID
  */
  get rules(): ZoneRules;
  /**
   * Normalizes the time-zone ID, returning a `ZoneOffset` where possible.
   * 
   * The returns a normalized `ZoneId` that can be used in place of this ID.
   * The result will have `ZoneRules` equivalent to those returned by this object,
   * however the ID returned by `getId()` may be different.
   * 
   * The normalization checks if the rules of this `ZoneId` have a fixed offset.
   * If they do, then the `ZoneOffset` equal to that offset is returned.
   * Otherwise `this` is returned.
   *
   * @return the time-zone unique ID, not null
  */
  normalized(): ZoneId;
  /**
   * Checks if this time-zone ID is equal to another time-zone ID.
   * 
   * The comparison is based on the ID.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other time-zone ID
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this time-zone ID.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this zone as a `String`, using the ID.
   *
   * @return a string representation of this time-zone ID, not null
  */
  toString(): string;
}
/**
 * A day-of-week, such as 'Tuesday'.
 * 
 * `DayOfWeek` is an enum representing the 7 days of the week -
 * Monday, Tuesday, Wednesday, Thursday, Friday, Saturday and Sunday.
 * 
 * In addition to the textual enum name, each day-of-week has an `int` value.
 * The `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).
 * It is recommended that applications use the enum rather than the `int` value
 * to ensure code clarity.
 * 
 * This enum provides access to the localized textual form of the day-of-week.
 * Some locales also assign different numeric values to the days, declaring
 * Sunday to have the value 1, however this class provides no support for this.
 * See {@link WeekFields} for localized week-numbering.
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `DayOfWeek`.
 * Use `getValue()` instead.
 * 
 * This enum represents a common concept that is found in many calendar systems.
 * As such, this enum may be used by any calendar system that has the day-of-week
 * concept defined exactly equivalent to the ISO calendar system.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class DayOfWeek extends Enum<DayOfWeek> {
  /**
   * The singleton instance for the day-of-week of Monday.
   * This has the numeric value of `1`.
  */
  static readonly MONDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Tuesday.
   * This has the numeric value of `2`.
  */
  static readonly TUESDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Wednesday.
   * This has the numeric value of `3`.
  */
  static readonly WEDNESDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Thursday.
   * This has the numeric value of `4`.
  */
  static readonly THURSDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Friday.
   * This has the numeric value of `5`.
  */
  static readonly FRIDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Saturday.
   * This has the numeric value of `6`.
  */
  static readonly SATURDAY: DayOfWeek;
  /**
   * The singleton instance for the day-of-week of Sunday.
   * This has the numeric value of `7`.
  */
  static readonly SUNDAY: DayOfWeek;
  static valueOf(name: string): DayOfWeek;
  static values(): DayOfWeek[];
  /**
   * Obtains an instance of `DayOfWeek` from an `int` value.
   * 
   * `DayOfWeek` is an enum representing the 7 days of the week.
   * This factory allows the enum to be obtained from the `int` value.
   * The `int` value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).
   *
   * @param dayOfWeek  the day-of-week to represent, from 1 (Monday) to 7 (Sunday)
   * @return the day-of-week singleton, not null
   * @throws DateTimeException if the day-of-week is invalid
  */
  static of(dayOfWeek: number): DayOfWeek;
  /**
   * Obtains an instance of `DayOfWeek` from a temporal object.
   * 
   * This obtains a day-of-week based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `DayOfWeek`.
   * 
   * The conversion extracts the {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} field.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `DayOfWeek::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the day-of-week, not null
   * @throws DateTimeException if unable to convert to a `DayOfWeek`
  */
  static from(temporal: TemporalAccessor): DayOfWeek;
  /**
   * Gets the day-of-week `int` value.
   * 
   * The values are numbered following the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).
   * See {@link java.time.temporal.WeekFields#dayOfWeek()} for localized week-numbering.
   *
   * @return the day-of-week, from 1 (Monday) to 7 (Sunday)
  */
  get value(): number;
  /**
   * Gets the textual representation, such as 'Mon' or 'Friday'.
   * 
   * This returns the textual name used to identify the day-of-week,
   * suitable for presentation to the user.
   * The parameters control the style of the returned text and the locale.
   * 
   * If no textual mapping is found then the {@link #getValue() numeric value} is returned.
   *
   * @param style  the length of the text required, not null
   * @param locale  the locale to use, not null
   * @return the text value of the day-of-week, not null
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this day-of-week can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then
   * this method returns true.
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this day-of-week, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This day-of-week is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the
   * range of the day-of-week, from 1 to 7, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this day-of-week as an `int`.
   * 
   * This queries this day-of-week for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the
   * value of the day-of-week, from 1 to 7, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field, within the valid range of values
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this day-of-week as a `long`.
   * 
   * This queries this day-of-week for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} then the
   * value of the day-of-week, from 1 to 7, will be returned.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Returns the day-of-week that is the specified number of days after this one.
   * 
   * The calculation rolls around the end of the week from Sunday to Monday.
   * The specified period may be negative.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to add, positive or negative
   * @return the resulting day-of-week, not null
  */
  plus(days: number): DayOfWeek;
  /**
   * Returns the day-of-week that is the specified number of days before this one.
   * 
   * The calculation rolls around the start of the year from Monday to Sunday.
   * The specified period may be negative.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to subtract, positive or negative
   * @return the resulting day-of-week, not null
  */
  minus(days: number): DayOfWeek;
  /**
   * Queries this day-of-week using the specified query.
   * 
   * This queries this day-of-week using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this day-of-week.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the day-of-week changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#DAY_OF_WEEK} as the field.
   * Note that this adjusts forwards or backwards within a Monday to Sunday week.
   * See {@link java.time.temporal.WeekFields#dayOfWeek()} for localized week start days.
   * See `TemporalAdjuster` for other adjusters with more control,
   * such as `next(MONDAY)`.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisDayOfWeek.adjustInto(temporal);
   *   temporal = temporal.with(thisDayOfWeek);
   * 
   * 
   * For example, given a date that is a Wednesday, the following are output:
   *      *   dateOnWed.with(MONDAY);     // two days earlier
   *   dateOnWed.with(TUESDAY);    // one day earlier
   *   dateOnWed.with(WEDNESDAY);  // same date
   *   dateOnWed.with(THURSDAY);   // one day later
   *   dateOnWed.with(FRIDAY);     // two days later
   *   dateOnWed.with(SATURDAY);   // three days later
   *   dateOnWed.with(SUNDAY);     // four days later
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
}
/**
 * An instantaneous point on the time-line.
 * 
 * This class models a single instantaneous point on the time-line.
 * This might be used to class event time-stamps in the application.
 * 
 * The range of an instant requires the storage of a number larger than a `long`.
 * To achieve this, the class stores a `long` representing epoch-seconds and an
 * `int` representing nanosecond-of-second, which will always be between 0 and 999,999,999.
 * The epoch-seconds are measured from the standard Java epoch of `1970-01-01T00:00:00Z`
 * where instants after the epoch have positive values, and earlier instants have negative values.
 * For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
 * than a smaller value.
 *
 * Time-scale
 * 
 * The length of the solar day is the standard way that humans measure time.
 * This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
 * forming a 86400 second day.
 * 
 * Modern timekeeping is based on atomic clocks which precisely define an SI second
 * relative to the transitions of a Caesium atom. The length of an SI second was defined
 * to be very close to the 86400th fraction of a day.
 * 
 * Unfortunately, as the Earth rotates the length of the day varies.
 * In addition, over time the average length of the day is getting longer as the Earth slows.
 * As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
 * The actual length of any given day and the amount by which the Earth is slowing
 * are not predictable and can only be determined by measurement.
 * The UT1 time-scale captures the accurate length of day, but is only available some
 * time after the day has completed.
 * 
 * The UTC time-scale is a standard approach to bundle up all the additional fractions
 * of a second from UT1 into whole seconds, known as leap-seconds.
 * A leap-second may be added or removed depending on the Earth's rotational changes.
 * As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where
 * necessary in order to keep the day aligned with the Sun.
 * 
 * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
 * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
 * alterations to the length of the notional second. As of 2012, discussions are underway
 * to change the definition of UTC again, with the potential to remove leap seconds or
 * introduce other changes.
 * 
 * Given the complexity of accurate timekeeping described above, this Java API defines
 * its own time-scale, the Java Time-Scale.
 * 
 * The Java Time-Scale divides each calendar day into exactly 86400
 * subdivisions, known as seconds.  These seconds may differ from the
 * SI second.  It closely matches the de facto international civil time
 * scale, the definition of which changes from time to time.
 * 
 * The Java Time-Scale has slightly different definitions for different
 * segments of the time-line, each based on the consensus international
 * time scale that is used as the basis for civil time. Whenever the
 * internationally-agreed time scale is modified or replaced, a new
 * segment of the Java Time-Scale must be defined for it.  Each segment
 * must meet these requirements:
 * 
 * the Java Time-Scale shall closely match the underlying international
 *  civil time scale;
 * the Java Time-Scale shall exactly match the international civil
 *  time scale at noon each day;
 * the Java Time-Scale shall have a precisely-defined relationship to
 *  the international civil time scale.
 * 
 * There are currently, as of 2013, two segments in the Java time-scale.
 * 
 * For the segment from 1972-11-03 (exact boundary discussed below) until
 * further notice, the consensus international time scale is UTC (with
 * leap seconds).  In this segment, the Java Time-Scale is identical to
 * UTC-SLS.
 * This is identical to UTC on days that do not have a leap second.
 * On days that do have a leap second, the leap second is spread equally
 * over the last 1000 seconds of the day, maintaining the appearance of
 * exactly 86400 seconds per day.
 * 
 * For the segment prior to 1972-11-03, extending back arbitrarily far,
 * the consensus international time scale is defined to be UT1, applied
 * proleptically, which is equivalent to the (mean) solar time on the
 * prime meridian (Greenwich). In this segment, the Java Time-Scale is
 * identical to the consensus international time scale. The exact
 * boundary between the two segments is the instant where UT1 = UTC
 * between 1972-11-03T00:00 and 1972-11-04T12:00.
 * 
 * Implementations of the Java time-scale using the JSR-310 API are not
 * required to provide any clock that is sub-second accurate, or that
 * progresses monotonically or smoothly. Implementations are therefore
 * not required to actually perform the UTC-SLS slew or to otherwise be
 * aware of leap seconds. JSR-310 does, however, require that
 * implementations must document the approach they use when defining a
 * clock representing the current instant.
 * See {@link Clock} for details on the available clocks.
 * 
 * The Java time-scale is used for all date-time classes.
 * This includes `Instant`, `LocalDate`, `LocalTime`, `OffsetDateTime`,
 * `ZonedDateTime` and `Duration`.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class Instant extends Temporal {
  /**
   * Constant for the 1970-01-01T00:00:00Z epoch instant.
  */
  static readonly EPOCH: Instant;
  /**
   * The minimum supported `Instant`, '-1000000000-01-01T00:00Z'.
   * This could be used by an application as a "far past" instant.
   * 
   * This is one year earlier than the minimum `LocalDateTime`.
   * This provides sufficient values to handle the range of `ZoneOffset`
   * which affect the instant in addition to the local date-time.
   * The value is also chosen such that the value of the year fits in
   * an `int`.
  */
  static readonly MIN: Instant;
  /**
   * The maximum supported `Instant`, '1000000000-12-31T23:59:59.999999999Z'.
   * This could be used by an application as a "far future" instant.
   * 
   * This is one year later than the maximum `LocalDateTime`.
   * This provides sufficient values to handle the range of `ZoneOffset`
   * which affect the instant in addition to the local date-time.
   * The value is also chosen such that the value of the year fits in
   * an `int`.
  */
  static readonly MAX: Instant;
  /**
   * Obtains the current instant from the system clock.
   * 
   * This will query the {@link Clock#systemUTC() system UTC clock} to
   * obtain the current instant.
   * 
   * Using this method will prevent the ability to use an alternate time-source for
   * testing because the clock is effectively hard-coded.
   *
   * @return the current instant using the system clock, not null
  */
  static now(): Instant;
  /**
   * Obtains the current instant from the specified clock.
   * 
   * This will query the specified clock to obtain the current time.
   * 
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current instant, not null
  */
  static now(clock: Clock): Instant;
  /**
   * Obtains an instance of `Instant` using seconds from the
   * epoch of 1970-01-01T00:00:00Z.
   * 
   * The nanosecond field is set to zero.
   *
   * @param epochSecond  the number of seconds from 1970-01-01T00:00:00Z
   * @return an instant, not null
   * @throws DateTimeException if the instant exceeds the maximum or minimum instant
  */
  static ofEpochSecond(epochSecond: number): Instant;
  /**
   * Obtains an instance of `Instant` using seconds from the
   * epoch of 1970-01-01T00:00:00Z and nanosecond fraction of second.
   * 
   * This method allows an arbitrary number of nanoseconds to be passed in.
   * The factory will alter the values of the second and nanosecond in order
   * to ensure that the stored nanosecond is in the range 0 to 999,999,999.
   * For example, the following will result in exactly the same instant:
   *      *  Instant.ofEpochSecond(3, 1);
   *  Instant.ofEpochSecond(4, -999_999_999);
   *  Instant.ofEpochSecond(2, 1000_000_001);
   * 
   *
   * @param epochSecond  the number of seconds from 1970-01-01T00:00:00Z
   * @param nanoAdjustment  the nanosecond adjustment to the number of seconds, positive or negative
   * @return an instant, not null
   * @throws DateTimeException if the instant exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  static ofEpochSecond(epochSecond: number, nanoAdjustment: number): Instant;
  /**
   * Obtains an instance of `Instant` using milliseconds from the
   * epoch of 1970-01-01T00:00:00Z.
   * 
   * The seconds and nanoseconds are extracted from the specified milliseconds.
   *
   * @param epochMilli  the number of milliseconds from 1970-01-01T00:00:00Z
   * @return an instant, not null
  */
  static ofEpochMilli(epochMilli: number): Instant;
  /**
   * Obtains an instance of `Instant` from a temporal object.
   * 
   * This obtains an instant based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `Instant`.
   * 
   * The conversion extracts the {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
   * and {@link ChronoField#NANO_OF_SECOND NANO_OF_SECOND} fields.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `Instant::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the instant, not null
   * @throws DateTimeException if unable to convert to an `Instant`
  */
  static from(temporal: TemporalAccessor): Instant;
  /**
   * Obtains an instance of `Instant` from a text string such as
   * `2007-12-03T10:15:30.00Z`.
   * 
   * The string must represent a valid instant in UTC and is parsed using
   * {@link DateTimeFormatter#ISO_INSTANT}.
   *
   * @param text  the text to parse, not null
   * @return the parsed instant, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): Instant;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this instant can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `MICRO_OF_SECOND`
   * `MILLI_OF_SECOND`
   * `INSTANT_SECONDS`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this instant, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * `DAYS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This instant is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this instant as an `int`.
   * 
   * This queries this instant for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time, except `INSTANT_SECONDS` which is too
   * large to fit in an `int` and throws a `DateTimeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this instant as a `long`.
   * 
   * This queries this instant for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.
   * 
   * The epoch second count is a simple incrementing count of seconds where
   * second 0 is 1970-01-01T00:00:00Z.
   * The nanosecond part is returned by {@link #getNano}.
   *
   * @return the seconds from the epoch of 1970-01-01T00:00:00Z
  */
  get epochSecond(): number;
  /**
   * Gets the number of nanoseconds, later along the time-line, from the start
   * of the second.
   * 
   * The nanosecond-of-second value measures the total number of nanoseconds from
   * the second returned by {@link #getEpochSecond}.
   *
   * @return the nanoseconds within the second, always positive, never exceeds 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this instant.
   * 
   * This returns an `Instant`, based on this one, with the instant adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return an `Instant` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): Instant;
  /**
   * Returns a copy of this instant with the specified field set to a new value.
   * 
   * This returns an `Instant`, based on this one, with the value
   * for the specified field changed.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The supported fields behave as follows:
   * 
   * `NANO_OF_SECOND` -
   *  Returns an `Instant` with the specified nano-of-second.
   *  The epoch-second will be unchanged.
   * `MICRO_OF_SECOND` -
   *  Returns an `Instant` with the nano-of-second replaced by the specified
   *  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.
   * `MILLI_OF_SECOND` -
   *  Returns an `Instant` with the nano-of-second replaced by the specified
   *  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.
   * `INSTANT_SECONDS` -
   *  Returns an `Instant` with the specified epoch-second.
   *  The nano-of-second will be unchanged.
   * 
   * 
   * In all cases, if the new value is outside the valid range of values for the field
   * then a `DateTimeException` will be thrown.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return an `Instant` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): Instant;
  /**
   * Returns a copy of this `Instant` truncated to the specified unit.
   * 
   * Truncating the instant returns a copy of the original with fields
   * smaller than the specified unit set to zero.
   * The fields are calculated on the basis of using a UTC offset as seen
   * in `toString`.
   * For example, truncating with the {@link ChronoUnit#MINUTES MINUTES} unit will
   * round down to the nearest minute, setting the seconds and nanoseconds to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return an `Instant` based on this instant with the time truncated, not null
   * @throws DateTimeException if the unit is invalid for truncation
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): Instant;
  /**
   * Returns a copy of this instant with the specified amount added.
   * 
   * This returns an `Instant`, based on this one, with the specified amount added.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return an `Instant` based on this instant with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): Instant;
  /**
   * Returns a copy of this instant with the specified amount added.
   * 
   * This returns an `Instant`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The supported fields behave as follows:
   * 
   * `NANOS` -
   *  Returns an `Instant` with the specified number of nanoseconds added.
   *  This is equivalent to {@link #plusNanos(long)}.
   * `MICROS` -
   *  Returns an `Instant` with the specified number of microseconds added.
   *  This is equivalent to {@link #plusNanos(long)} with the amount
   *  multiplied by 1,000.
   * `MILLIS` -
   *  Returns an `Instant` with the specified number of milliseconds added.
   *  This is equivalent to {@link #plusNanos(long)} with the amount
   *  multiplied by 1,000,000.
   * `SECONDS` -
   *  Returns an `Instant` with the specified number of seconds added.
   *  This is equivalent to {@link #plusSeconds(long)}.
   * `MINUTES` -
   *  Returns an `Instant` with the specified number of minutes added.
   *  This is equivalent to {@link #plusSeconds(long)} with the amount
   *  multiplied by 60.
   * `HOURS` -
   *  Returns an `Instant` with the specified number of hours added.
   *  This is equivalent to {@link #plusSeconds(long)} with the amount
   *  multiplied by 3,600.
   * `HALF_DAYS` -
   *  Returns an `Instant` with the specified number of half-days added.
   *  This is equivalent to {@link #plusSeconds(long)} with the amount
   *  multiplied by 43,200 (12 hours).
   * `DAYS` -
   *  Returns an `Instant` with the specified number of days added.
   *  This is equivalent to {@link #plusSeconds(long)} with the amount
   *  multiplied by 86,400 (24 hours).
   * 
   * 
   * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return an `Instant` based on this instant with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): Instant;
  /**
   * Returns a copy of this instant with the specified duration in seconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondsToAdd  the seconds to add, positive or negative
   * @return an `Instant` based on this instant with the specified seconds added, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusSeconds(secondsToAdd: number): Instant;
  /**
   * Returns a copy of this instant with the specified duration in milliseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param millisToAdd  the milliseconds to add, positive or negative
   * @return an `Instant` based on this instant with the specified milliseconds added, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusMillis(millisToAdd: number): Instant;
  /**
   * Returns a copy of this instant with the specified duration in nanoseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToAdd  the nanoseconds to add, positive or negative
   * @return an `Instant` based on this instant with the specified nanoseconds added, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  plusNanos(nanosToAdd: number): Instant;
  /**
   * Returns a copy of this instant with the specified amount subtracted.
   * 
   * This returns an `Instant`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Duration} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return an `Instant` based on this instant with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): Instant;
  /**
   * Returns a copy of this instant with the specified amount subtracted.
   * 
   * This returns an `Instant`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return an `Instant` based on this instant with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): Instant;
  /**
   * Returns a copy of this instant with the specified duration in seconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param secondsToSubtract  the seconds to subtract, positive or negative
   * @return an `Instant` based on this instant with the specified seconds subtracted, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusSeconds(secondsToSubtract: number): Instant;
  /**
   * Returns a copy of this instant with the specified duration in milliseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param millisToSubtract  the milliseconds to subtract, positive or negative
   * @return an `Instant` based on this instant with the specified milliseconds subtracted, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusMillis(millisToSubtract: number): Instant;
  /**
   * Returns a copy of this instant with the specified duration in nanoseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanosToSubtract  the nanoseconds to subtract, positive or negative
   * @return an `Instant` based on this instant with the specified nanoseconds subtracted, not null
   * @throws DateTimeException if the result exceeds the maximum or minimum instant
   * @throws ArithmeticException if numeric overflow occurs
  */
  minusNanos(nanosToSubtract: number): Instant;
  /**
   * Queries this instant using the specified query.
   * 
   * This queries this instant using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this instant.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the instant changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * twice, passing {@link ChronoField#INSTANT_SECONDS} and
   * {@link ChronoField#NANO_OF_SECOND} as the fields.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisInstant.adjustInto(temporal);
   *   temporal = temporal.with(thisInstant);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another instant in terms of the specified unit.
   * 
   * This calculates the amount of time between two `Instant`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified instant.
   * The result will be negative if the end is before the start.
   * The calculation returns a whole number, representing the number of
   * complete units between the two instants.
   * The `Temporal` passed to this method is converted to a
   * `Instant` using {@link #from(TemporalAccessor)}.
   * For example, the amount in seconds between two dates can be calculated
   * using `startInstant.until(endInstant, SECONDS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, SECONDS);
   *   amount = SECONDS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS`, `HALF_DAYS` and `DAYS`
   * are supported. Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to an `Instant`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this instant and the end instant
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to an `Instant`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Combines this instant with an offset to create an `OffsetDateTime`.
   * 
   * This returns an `OffsetDateTime` formed from this instant at the
   * specified offset from UTC/Greenwich. An exception will be thrown if the
   * instant is too large to fit into an offset date-time.
   * 
   * This method is equivalent to
   * {@link OffsetDateTime#ofInstant(Instant, ZoneId) OffsetDateTime.ofInstant(this, offset)}.
   *
   * @param offset  the offset to combine with, not null
   * @return the offset date-time formed from this instant and the specified offset, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  atOffset(offset: ZoneOffset): OffsetDateTime;
  /**
   * Combines this instant with a time-zone to create a `ZonedDateTime`.
   * 
   * This returns an `ZonedDateTime` formed from this instant at the
   * specified time-zone. An exception will be thrown if the instant is too
   * large to fit into a zoned date-time.
   * 
   * This method is equivalent to
   * {@link ZonedDateTime#ofInstant(Instant, ZoneId) ZonedDateTime.ofInstant(this, zone)}.
   *
   * @param zone  the zone to combine with, not null
   * @return the zoned date-time formed from this instant and the specified zone, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  atZone(zone: ZoneId): ZonedDateTime;
  /**
   * Converts this instant to the number of milliseconds from the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * If this instant represents a point on the time-line too far in the future
   * or past to fit in a `long` milliseconds, then an exception is thrown.
   * 
   * If this instant has greater than millisecond precision, then the conversion
   * will drop any excess precision information as though the amount in nanoseconds
   * was subject to integer division by one million.
   *
   * @return the number of milliseconds since the epoch of 1970-01-01T00:00:00Z
   * @throws ArithmeticException if numeric overflow occurs
  */
  toEpochMilli(): number;
  /**
   * Compares this instant to the specified instant.
   * 
   * The comparison is based on the time-line position of the instants.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param otherInstant  the other instant to compare to, not null
   * @return the comparator value, that is less than zero if this instant is before `otherInstant`,
   *          zero if they are equal, or greater than zero if this instant is after `otherInstant`
   * @throws NullPointerException if otherInstant is null
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(otherInstant: Instant): number;
  /**
   * Checks if this instant is after the specified instant.
   * 
   * The comparison is based on the time-line position of the instants.
   *
   * @param otherInstant  the other instant to compare to, not null
   * @return true if this instant is after the specified instant
   * @throws NullPointerException if otherInstant is null
  */
  isAfter(otherInstant: Instant): boolean;
  /**
   * Checks if this instant is before the specified instant.
   * 
   * The comparison is based on the time-line position of the instants.
   *
   * @param otherInstant  the other instant to compare to, not null
   * @return true if this instant is before the specified instant
   * @throws NullPointerException if otherInstant is null
  */
  isBefore(otherInstant: Instant): boolean;
  /**
   * Checks if this instant is equal to the specified instant.
   * 
   * The comparison is based on the time-line position of the instants.
   *
   * @param other  the other instant, null returns false
   * @return true if the other instant is equal to this one
  */
  equals(other: any): boolean;
  /**
   * Returns a hash code for this instant.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * A string representation of this instant using ISO-8601 representation.
   * 
   * The format used is the same as {@link DateTimeFormatter#ISO_INSTANT}.
   *
   * @return an ISO-8601 representation of this instant, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface Instant extends Temporal, TemporalAdjuster, Comparable<Instant>, Serializable {}
/**
 * A year in the ISO-8601 calendar system, such as `2007`.
 * 
 * `Year` is an immutable date-time object that represents a year.
 * Any field that can be derived from a year can be obtained.
 * 
 * Note that years in the ISO chronology only align with years in the
 * Gregorian-Julian system for modern years. Parts of Russia did not switch to the
 * modern Gregorian/ISO rules until 1920.
 * As such, historical years must be treated with caution.
 * 
 * This class does not store or represent a month, day, time or time-zone.
 * For example, the value "2007" can be stored in a `Year`.
 * 
 * Years represented by this class follow the ISO-8601 standard and use
 * the proleptic numbering system. Year 1 is preceded by year 0, then by year -1.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * For most applications written today, the ISO-8601 rules are entirely suitable.
 * However, any application that makes use of historical dates, and requires them
 * to be accurate will find the ISO-8601 approach unsuitable.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class Year extends Temporal {
  /**
   * The minimum supported year, '-999,999,999'.
  */
  static readonly MIN_VALUE: number;
  /**
   * The maximum supported year, '+999,999,999'.
  */
  static readonly MAX_VALUE: number;
  /**
   * Obtains the current year from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current year.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current year using the system clock and default time-zone, not null
  */
  static now(): Year;
  /**
   * Obtains the current year from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current year.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current year using the system clock, not null
  */
  static now(zone: ZoneId): Year;
  /**
   * Obtains the current year from the specified clock.
   * 
   * This will query the specified clock to obtain the current year.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current year, not null
  */
  static now(clock: Clock): Year;
  /**
   * Obtains an instance of `Year`.
   * 
   * This method accepts a year value from the proleptic ISO calendar system.
   * 
   * The year 2AD/CE is represented by 2.
   * The year 1AD/CE is represented by 1.
   * The year 1BC/BCE is represented by 0.
   * The year 2BC/BCE is represented by -1.
   *
   * @param isoYear  the ISO proleptic year to represent, from `MIN_VALUE` to `MAX_VALUE`
   * @return the year, not null
   * @throws DateTimeException if the field is invalid
  */
  static of(isoYear: number): Year;
  /**
   * Obtains an instance of `Year` from a temporal object.
   * 
   * This obtains a year based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `Year`.
   * 
   * The conversion extracts the {@link ChronoField#YEAR year} field.
   * The extraction is only permitted if the temporal object has an ISO
   * chronology, or can be converted to a `LocalDate`.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `Year::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the year, not null
   * @throws DateTimeException if unable to convert to a `Year`
  */
  static from(temporal: TemporalAccessor): Year;
  /**
   * Obtains an instance of `Year` from a text string such as `2007`.
   * 
   * The string must represent a valid year.
   *
   * @param text  the text to parse such as "2007", not null
   * @return the parsed year, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): Year;
  /**
   * Obtains an instance of `Year` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a year.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed year, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): Year;
  /**
   * Checks if the year is a leap year, according to the ISO proleptic
   * calendar system rules.
   * 
   * This method applies the current rules for leap years across the whole time-line.
   * In general, a year is a leap year if it is divisible by four without
   * remainder. However, years divisible by 100, are not leap years, with
   * the exception of years divisible by 400 which are.
   * 
   * For example, 1904 is a leap year it is divisible by 4.
   * 1900 was not a leap year as it is divisible by 100, however 2000 was a
   * leap year as it is divisible by 400.
   * 
   * The calculation is proleptic - applying the same rules into the far future and far past.
   * This is historically inaccurate, but is correct for the ISO-8601 standard.
   *
   * @param year  the year to check
   * @return true if the year is leap, false otherwise
  */
  static isLeap(year: number): boolean;
  /**
   * Gets the year value.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   *
   * @return the year, `MIN_VALUE` to `MAX_VALUE`
  */
  get value(): number;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this year can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this year, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this year.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This year is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this year as an `int`.
   * 
   * This queries this year for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this year.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this year as a `long`.
   * 
   * This queries this year for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this year.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Checks if the year is a leap year, according to the ISO proleptic
   * calendar system rules.
   * 
   * This method applies the current rules for leap years across the whole time-line.
   * In general, a year is a leap year if it is divisible by four without
   * remainder. However, years divisible by 100, are not leap years, with
   * the exception of years divisible by 400 which are.
   * 
   * For example, 1904 is a leap year it is divisible by 4.
   * 1900 was not a leap year as it is divisible by 100, however 2000 was a
   * leap year as it is divisible by 400.
   * 
   * The calculation is proleptic - applying the same rules into the far future and far past.
   * This is historically inaccurate, but is correct for the ISO-8601 standard.
   *
   * @return true if the year is leap, false otherwise
  */
  isLeap(): boolean;
  /**
   * Checks if the month-day is valid for this year.
   * 
   * This method checks whether this year and the input month and day form
   * a valid date.
   *
   * @param monthDay  the month-day to validate, null returns false
   * @return true if the month and day are valid for this year
  */
  isValidMonthDay(monthDay: MonthDay): boolean;
  /**
   * Gets the length of this year in days.
   *
   * @return the length of this year in days, 365 or 366
  */
  length(): number;
  /**
   * Returns an adjusted copy of this year.
   * 
   * This returns a `Year`, based on this one, with the year adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return a `Year` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): Year;
  /**
   * Returns a copy of this year with the specified field set to a new value.
   * 
   * This returns a `Year`, based on this one, with the value
   * for the specified field changed.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * The supported fields behave as follows:
   * 
   * `YEAR_OF_ERA` -
   *  Returns a `Year` with the specified year-of-era
   *  The era will be unchanged.
   * `YEAR` -
   *  Returns a `Year` with the specified year.
   *  This completely replaces the date and is equivalent to {@link #of(int)}.
   * `ERA` -
   *  Returns a `Year` with the specified era.
   *  The year-of-era will be unchanged.
   * 
   * 
   * In all cases, if the new value is outside the valid range of values for the field
   * then a `DateTimeException` will be thrown.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return a `Year` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): Year;
  /**
   * Returns a copy of this year with the specified amount added.
   * 
   * This returns a `Year`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return a `Year` based on this year with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): Year;
  /**
   * Returns a copy of this year with the specified amount added.
   * 
   * This returns a `Year`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented here.
   * The supported fields behave as follows:
   * 
   * `YEARS` -
   *  Returns a `Year` with the specified number of years added.
   *  This is equivalent to {@link #plusYears(long)}.
   * `DECADES` -
   *  Returns a `Year` with the specified number of decades added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 10.
   * `CENTURIES` -
   *  Returns a `Year` with the specified number of centuries added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 100.
   * `MILLENNIA` -
   *  Returns a `Year` with the specified number of millennia added.
   *  This is equivalent to calling {@link #plusYears(long)} with the amount
   *  multiplied by 1,000.
   * `ERAS` -
   *  Returns a `Year` with the specified number of eras added.
   *  Only two eras are supported so the amount must be one, zero or minus one.
   *  If the amount is non-zero then the year is changed such that the year-of-era
   *  is unchanged.
   * 
   * 
   * All other `ChronoUnit` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return a `Year` based on this year with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): Year;
  /**
   * Returns a copy of this `Year` with the specified number of years added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToAdd  the years to add, may be negative
   * @return a `Year` based on this year with the years added, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  plusYears(yearsToAdd: number): Year;
  /**
   * Returns a copy of this year with the specified amount subtracted.
   * 
   * This returns a `Year`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} but may be any other type implementing
   * the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return a `Year` based on this year with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): Year;
  /**
   * Returns a copy of this year with the specified amount subtracted.
   * 
   * This returns a `Year`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return a `Year` based on this year with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): Year;
  /**
   * Returns a copy of this `Year` with the specified number of years subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param yearsToSubtract  the years to subtract, may be negative
   * @return a `Year` based on this year with the year subtracted, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  minusYears(yearsToSubtract: number): Year;
  /**
   * Queries this year using the specified query.
   * 
   * This queries this year using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this year.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the year changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#YEAR} as the field.
   * If the specified temporal object does not use the ISO calendar system then
   * a `DateTimeException` is thrown.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisYear.adjustInto(temporal);
   *   temporal = temporal.with(thisYear);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another year in terms of the specified unit.
   * 
   * This calculates the amount of time between two `Year`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified year.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `Year` using {@link #from(TemporalAccessor)}.
   * For example, the amount in decades between two year can be calculated
   * using `startYear.until(endYear, DECADES)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two years.
   * For example, the amount in decades between 2012 and 2031
   * will only be one decade as it is one year short of two decades.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, YEARS);
   *   amount = YEARS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `YEARS`, `DECADES`, `CENTURIES`,
   * `MILLENNIA` and `ERAS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a `Year`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this year and the end year
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `Year`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this year using the specified formatter.
   * 
   * This year will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted year string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this year with a day-of-year to create a `LocalDate`.
   * 
   * This returns a `LocalDate` formed from this year and the specified day-of-year.
   * 
   * The day-of-year value 366 is only valid in a leap year.
   *
   * @param dayOfYear  the day-of-year to use, from 1 to 365-366
   * @return the local date formed from this year and the specified date of year, not null
   * @throws DateTimeException if the day of year is zero or less, 366 or greater or equal
   *  to 366 and this is not a leap year
  */
  atDay(dayOfYear: number): LocalDate;
  /**
   * Combines this year with a month to create a `YearMonth`.
   * 
   * This returns a `YearMonth` formed from this year and the specified month.
   * All possible combinations of year and month are valid.
   * 
   * This method can be used as part of a chain to produce a date:
   *      *  LocalDate date = year.atMonth(month).atDay(day);
   * 
   *
   * @param month  the month-of-year to use, not null
   * @return the year-month formed from this year and the specified month, not null
  */
  atMonth(month: Month): YearMonth;
  /**
   * Combines this year with a month to create a `YearMonth`.
   * 
   * This returns a `YearMonth` formed from this year and the specified month.
   * All possible combinations of year and month are valid.
   * 
   * This method can be used as part of a chain to produce a date:
   *      *  LocalDate date = year.atMonth(month).atDay(day);
   * 
   *
   * @param month  the month-of-year to use, from 1 (January) to 12 (December)
   * @return the year-month formed from this year and the specified month, not null
   * @throws DateTimeException if the month is invalid
  */
  atMonth(month: number): YearMonth;
  /**
   * Combines this year with a month-day to create a `LocalDate`.
   * 
   * This returns a `LocalDate` formed from this year and the specified month-day.
   * 
   * A month-day of February 29th will be adjusted to February 28th in the resulting
   * date if the year is not a leap year.
   *
   * @param monthDay  the month-day to use, not null
   * @return the local date formed from this year and the specified month-day, not null
  */
  atMonthDay(monthDay: MonthDay): LocalDate;
  /**
   * Compares this year to another year.
   * 
   * The comparison is based on the value of the year.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other year to compare to, not null
   * @return the comparator value, that is less than zero if this is before `other`,
   *          zero if they are equal, or greater than zero if this is after `other`
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: Year): number;
  /**
   * Checks if this year is after the specified year.
   *
   * @param other  the other year to compare to, not null
   * @return true if this is after the specified year
  */
  isAfter(other: Year): boolean;
  /**
   * Checks if this year is before the specified year.
   *
   * @param other  the other year to compare to, not null
   * @return true if this point is before the specified year
  */
  isBefore(other: Year): boolean;
  /**
   * Checks if this year is equal to another year.
   * 
   * The comparison is based on the time-line position of the years.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other year
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this year.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this year as a `String`.
   *
   * @return a string representation of this year, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface Year extends Temporal, TemporalAdjuster, Comparable<Year>, Serializable {}
/**
 * A month-day in the ISO-8601 calendar system, such as `--12-03`.
 * 
 * `MonthDay` is an immutable date-time object that represents the combination
 * of a month and day-of-month. Any field that can be derived from a month and day,
 * such as quarter-of-year, can be obtained.
 * 
 * This class does not store or represent a year, time or time-zone.
 * For example, the value "December 3rd" can be stored in a `MonthDay`.
 * 
 * Since a `MonthDay` does not possess a year, the leap day of
 * February 29th is considered valid.
 * 
 * This class implements {@link TemporalAccessor} rather than {@link Temporal}.
 * This is because it is not possible to define whether February 29th is valid or not
 * without external information, preventing the implementation of plus/minus.
 * Related to this, `MonthDay` only provides access to query and set the fields
 * `MONTH_OF_YEAR` and `DAY_OF_MONTH`.
 * 
 * The ISO-8601 calendar system is the modern civil calendar system used today
 * in most of the world. It is equivalent to the proleptic Gregorian calendar
 * system, in which today's rules for leap years are applied for all time.
 * For most applications written today, the ISO-8601 rules are entirely suitable.
 * However, any application that makes use of historical dates, and requires them
 * to be accurate will find the ISO-8601 approach unsuitable.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class MonthDay extends TemporalAccessor {
  /**
   * Obtains the current month-day from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current month-day.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current month-day using the system clock and default time-zone, not null
  */
  static now(): MonthDay;
  /**
   * Obtains the current month-day from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current month-day.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current month-day using the system clock, not null
  */
  static now(zone: ZoneId): MonthDay;
  /**
   * Obtains the current month-day from the specified clock.
   * 
   * This will query the specified clock to obtain the current month-day.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current month-day, not null
  */
  static now(clock: Clock): MonthDay;
  /**
   * Obtains an instance of `MonthDay`.
   * 
   * The day-of-month must be valid for the month within a leap year.
   * Hence, for February, day 29 is valid.
   * 
   * For example, passing in April and day 31 will throw an exception, as
   * there can never be April 31st in any year. By contrast, passing in
   * February 29th is permitted, as that month-day can sometimes be valid.
   *
   * @param month  the month-of-year to represent, not null
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @return the month-day, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month
  */
  static of(month: Month, dayOfMonth: number): MonthDay;
  /**
   * Obtains an instance of `MonthDay`.
   * 
   * The day-of-month must be valid for the month within a leap year.
   * Hence, for month 2 (February), day 29 is valid.
   * 
   * For example, passing in month 4 (April) and day 31 will throw an exception, as
   * there can never be April 31st in any year. By contrast, passing in
   * February 29th is permitted, as that month-day can sometimes be valid.
   *
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @return the month-day, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month
  */
  static of(month: number, dayOfMonth: number): MonthDay;
  /**
   * Obtains an instance of `MonthDay` from a temporal object.
   * 
   * This obtains a month-day based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `MonthDay`.
   * 
   * The conversion extracts the {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
   * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} fields.
   * The extraction is only permitted if the temporal object has an ISO
   * chronology, or can be converted to a `LocalDate`.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `MonthDay::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the month-day, not null
   * @throws DateTimeException if unable to convert to a `MonthDay`
  */
  static from(temporal: TemporalAccessor): MonthDay;
  /**
   * Obtains an instance of `MonthDay` from a text string such as `--12-03`.
   * 
   * The string must represent a valid month-day.
   * The format is `--MM-dd`.
   *
   * @param text  the text to parse such as "--12-03", not null
   * @return the parsed month-day, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): MonthDay;
  /**
   * Obtains an instance of `MonthDay` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a month-day.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed month-day, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): MonthDay;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this month-day can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `MONTH_OF_YEAR`
   * `YEAR`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this month-day, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This month-day is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this month-day as an `int`.
   * 
   * This queries this month-day for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this month-day.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this month-day as a `long`.
   * 
   * This queries this month-day for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this month-day.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Gets the day-of-month field.
   * 
   * This method returns the primitive `int` value for the day-of-month.
   *
   * @return the day-of-month, from 1 to 31
  */
  get dayOfMonth(): number;
  /**
   * Checks if the year is valid for this month-day.
   * 
   * This method checks whether this month and day and the input year form
   * a valid date. This can only return false for February 29th.
   *
   * @param year  the year to validate
   * @return true if the year is valid for this month-day
   * @see Year#isValidMonthDay(MonthDay)
  */
  isValidYear(year: number): boolean;
  /**
   * Returns a copy of this `MonthDay` with the month-of-year altered.
   * 
   * This returns a month-day with the specified month.
   * If the day-of-month is invalid for the specified month, the day will
   * be adjusted to the last valid day-of-month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the returned month-day, from 1 (January) to 12 (December)
   * @return a `MonthDay` based on this month-day with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): MonthDay;
  /**
   * Returns a copy of this `MonthDay` with the month-of-year altered.
   * 
   * This returns a month-day with the specified month.
   * If the day-of-month is invalid for the specified month, the day will
   * be adjusted to the last valid day-of-month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the returned month-day, not null
   * @return a `MonthDay` based on this month-day with the requested month, not null
  */
  with(month: Month): MonthDay;
  /**
   * Returns a copy of this `MonthDay` with the day-of-month altered.
   * 
   * This returns a month-day with the specified day-of-month.
   * If the day-of-month is invalid for the month, an exception is thrown.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfMonth  the day-of-month to set in the return month-day, from 1 to 31
   * @return a `MonthDay` based on this month-day with the requested day, not null
   * @throws DateTimeException if the day-of-month value is invalid,
   *  or if the day-of-month is invalid for the month
  */
  withDayOfMonth(dayOfMonth: number): MonthDay;
  /**
   * Queries this month-day using the specified query.
   * 
   * This queries this month-day using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have this month-day.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the month and day-of-month changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * twice, passing {@link ChronoField#MONTH_OF_YEAR} and
   * {@link ChronoField#DAY_OF_MONTH} as the fields.
   * If the specified temporal object does not use the ISO calendar system then
   * a `DateTimeException` is thrown.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisMonthDay.adjustInto(temporal);
   *   temporal = temporal.with(thisMonthDay);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Formats this month-day using the specified formatter.
   * 
   * This month-day will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted month-day string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this month-day with a year to create a `LocalDate`.
   * 
   * This returns a `LocalDate` formed from this month-day and the specified year.
   * 
   * A month-day of February 29th will be adjusted to February 28th in the resulting
   * date if the year is not a leap year.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to use, from MIN_YEAR to MAX_YEAR
   * @return the local date formed from this month-day and the specified year, not null
   * @throws DateTimeException if the year is outside the valid range of years
  */
  atYear(year: number): LocalDate;
  /**
   * Compares this month-day to another month-day.
   * 
   * The comparison is based first on value of the month, then on the value of the day.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other month-day to compare to, not null
   * @return the comparator value, that is less than zero if this is before `other`,
   *          zero if they are equal, greater than zero if this is after `other`
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: MonthDay): number;
  /**
   * Checks if this month-day is after the specified month-day.
   *
   * @param other  the other month-day to compare to, not null
   * @return true if this is after the specified month-day
  */
  isAfter(other: MonthDay): boolean;
  /**
   * Checks if this month-day is before the specified month-day.
   *
   * @param other  the other month-day to compare to, not null
   * @return true if this point is before the specified month-day
  */
  isBefore(other: MonthDay): boolean;
  /**
   * Checks if this month-day is equal to another month-day.
   * 
   * The comparison is based on the time-line position of the month-day within a year.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other month-day
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this month-day.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this month-day as a `String`, such as `--12-03`.
   * 
   * The output will be in the format `--MM-dd`:
   *
   * @return a string representation of this month-day, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface MonthDay extends TemporalAccessor, TemporalAdjuster, Comparable<MonthDay>, Serializable {}
/**
 * A date-time with an offset from UTC/Greenwich in the ISO-8601 calendar system,
 * such as `2007-12-03T10:15:30+01:00`.
 * 
 * `OffsetDateTime` is an immutable representation of a date-time with an offset.
 * This class stores all date and time fields, to a precision of nanoseconds,
 * as well as the offset from UTC/Greenwich. For example, the value
 * "2nd October 2007 at 13:45:30.123456789 +02:00" can be stored in an `OffsetDateTime`.
 * 
 * `OffsetDateTime`, {@link java.time.ZonedDateTime} and {@link java.time.Instant} all store an instant
 * on the time-line to nanosecond precision.
 * `Instant` is the simplest, simply representing the instant.
 * `OffsetDateTime` adds to the instant the offset from UTC/Greenwich, which allows
 * the local date-time to be obtained.
 * `ZonedDateTime` adds full time-zone rules.
 * 
 * It is intended that `ZonedDateTime` or `Instant` is used to model data
 * in simpler applications. This class may be used when modeling date-time concepts in
 * more detail, or when communicating to a database or in a network protocol.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class OffsetDateTime extends Temporal {
  /**
   * The minimum supported `OffsetDateTime`, '-999999999-01-01T00:00:00+18:00'.
   * This is the local date-time of midnight at the start of the minimum date
   * in the maximum offset (larger offsets are earlier on the time-line).
   * This combines {@link LocalDateTime#MIN} and {@link ZoneOffset#MAX}.
   * This could be used by an application as a "far past" date-time.
  */
  static readonly MIN: OffsetDateTime;
  /**
   * The maximum supported `OffsetDateTime`, '+999999999-12-31T23:59:59.999999999-18:00'.
   * This is the local date-time just before midnight at the end of the maximum date
   * in the minimum offset (larger negative offsets are later on the time-line).
   * This combines {@link LocalDateTime#MAX} and {@link ZoneOffset#MIN}.
   * This could be used by an application as a "far future" date-time.
  */
  static readonly MAX: OffsetDateTime;
  /**
   * Gets a comparator that compares two `OffsetDateTime` instances
   * based solely on the instant.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying instant.
   *
   * @return a comparator that compares in time-line order
   *
   * @see #isAfter
   * @see #isBefore
   * @see #isEqual
  */
  static timeLineOrder(): Comparator<OffsetDateTime>;
  /**
   * Obtains the current date-time from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date-time.
   * The offset will be calculated from the time-zone in the clock.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date-time using the system clock, not null
  */
  static now(): OffsetDateTime;
  /**
   * Obtains the current date-time from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date-time.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * The offset will be calculated from the specified time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date-time using the system clock, not null
  */
  static now(zone: ZoneId): OffsetDateTime;
  /**
   * Obtains the current date-time from the specified clock.
   * 
   * This will query the specified clock to obtain the current date-time.
   * The offset will be calculated from the time-zone in the clock.
   * 
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date-time, not null
  */
  static now(clock: Clock): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a date, time and offset.
   * 
   * This creates an offset date-time with the specified local date, time and offset.
   *
   * @param date  the local date, not null
   * @param time  the local time, not null
   * @param offset  the zone offset, not null
   * @return the offset date-time, not null
  */
  static of(date: LocalDate, time: LocalTime, offset: ZoneOffset): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a date-time and offset.
   * 
   * This creates an offset date-time with the specified local date-time and offset.
   *
   * @param dateTime  the local date-time, not null
   * @param offset  the zone offset, not null
   * @return the offset date-time, not null
  */
  static of(dateTime: LocalDateTime, offset: ZoneOffset): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a year, month, day,
   * hour, minute, second, nanosecond and offset.
   * 
   * This creates an offset date-time with the seven specified fields.
   * 
   * This method exists primarily for writing test cases.
   * Non test-code will typically use other methods to create an offset time.
   * `LocalDateTime` has five additional convenience variants of the
   * equivalent factory method taking fewer arguments.
   * They are not provided here to reduce the footprint of the API.
   *
   * @param year  the year to represent, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year to represent, from 1 (January) to 12 (December)
   * @param dayOfMonth  the day-of-month to represent, from 1 to 31
   * @param hour  the hour-of-day to represent, from 0 to 23
   * @param minute  the minute-of-hour to represent, from 0 to 59
   * @param second  the second-of-minute to represent, from 0 to 59
   * @param nanoOfSecond  the nano-of-second to represent, from 0 to 999,999,999
   * @param offset  the zone offset, not null
   * @return the offset date-time, not null
   * @throws DateTimeException if the value of any field is out of range, or
   *  if the day-of-month is invalid for the month-year
  */
  static of(year: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, nanoOfSecond: number, offset: ZoneOffset): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from an `Instant` and zone ID.
   * 
   * This creates an offset date-time with the same instant as that specified.
   * Finding the offset from UTC/Greenwich is simple as there is only one valid
   * offset for each instant.
   *
   * @param instant  the instant to create the date-time from, not null
   * @param zone  the time-zone, which may be an offset, not null
   * @return the offset date-time, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  static ofInstant(instant: Instant, zone: ZoneId): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a temporal object.
   * 
   * This obtains an offset date-time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `OffsetDateTime`.
   * 
   * The conversion will first obtain a `ZoneOffset` from the temporal object.
   * It will then try to obtain a `LocalDateTime`, falling back to an `Instant` if necessary.
   * The result will be the combination of `ZoneOffset` with either
   * with `LocalDateTime` or `Instant`.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `OffsetDateTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the offset date-time, not null
   * @throws DateTimeException if unable to convert to an `OffsetDateTime`
  */
  static from(temporal: TemporalAccessor): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a text string
   * such as `2007-12-03T10:15:30+01:00`.
   * 
   * The string must represent a valid date-time and is parsed using
   * {@link java.time.format.DateTimeFormatter#ISO_OFFSET_DATE_TIME}.
   *
   * @param text  the text to parse such as "2007-12-03T10:15:30+01:00", not null
   * @return the parsed offset date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence): OffsetDateTime;
  /**
   * Obtains an instance of `OffsetDateTime` from a text string using a specific formatter.
   * 
   * The text is parsed using the formatter, returning a date-time.
   *
   * @param text  the text to parse, not null
   * @param formatter  the formatter to use, not null
   * @return the parsed offset date-time, not null
   * @throws DateTimeParseException if the text cannot be parsed
  */
  static parse(text: CharSequence, formatter: DateTimeFormatter): OffsetDateTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this date-time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `NANO_OF_SECOND`
   * `NANO_OF_DAY`
   * `MICRO_OF_SECOND`
   * `MICRO_OF_DAY`
   * `MILLI_OF_SECOND`
   * `MILLI_OF_DAY`
   * `SECOND_OF_MINUTE`
   * `SECOND_OF_DAY`
   * `MINUTE_OF_HOUR`
   * `MINUTE_OF_DAY`
   * `HOUR_OF_AMPM`
   * `CLOCK_HOUR_OF_AMPM`
   * `HOUR_OF_DAY`
   * `CLOCK_HOUR_OF_DAY`
   * `AMPM_OF_DAY`
   * `DAY_OF_WEEK`
   * `ALIGNED_DAY_OF_WEEK_IN_MONTH`
   * `ALIGNED_DAY_OF_WEEK_IN_YEAR`
   * `DAY_OF_MONTH`
   * `DAY_OF_YEAR`
   * `EPOCH_DAY`
   * `ALIGNED_WEEK_OF_MONTH`
   * `ALIGNED_WEEK_OF_YEAR`
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * `INSTANT_SECONDS`
   * `OFFSET_SECONDS`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this date-time, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * If the unit is a {@link ChronoUnit} then the query is implemented here.
   * The supported units are:
   * 
   * `NANOS`
   * `MICROS`
   * `MILLIS`
   * `SECONDS`
   * `MINUTES`
   * `HOURS`
   * `HALF_DAYS`
   * `DAYS`
   * `WEEKS`
   * `MONTHS`
   * `YEARS`
   * `DECADES`
   * `CENTURIES`
   * `MILLENNIA`
   * `ERAS`
   * 
   * All other `ChronoUnit` instances will return false.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This date-time is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return
   * appropriate range instances.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this date-time as an `int`.
   * 
   * This queries this date-time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time, except `NANO_OF_DAY`, `MICRO_OF_DAY`,
   * `EPOCH_DAY`, `PROLEPTIC_MONTH` and `INSTANT_SECONDS` which are too
   * large to fit in an `int` and throw an `UnsupportedTemporalTypeException`.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this date-time as a `long`.
   * 
   * This queries this date-time for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The {@link #isSupported(TemporalField) supported fields} will return valid
   * values based on this date-time.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Gets the zone offset, such as '+01:00'.
   * 
   * This is the offset of the local date-time from UTC/Greenwich.
   *
   * @return the zone offset, not null
  */
  get offset(): ZoneOffset;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified offset ensuring
   * that the result has the same local date-time.
   * 
   * This method returns an object with the same `LocalDateTime` and the specified `ZoneOffset`.
   * No calculation is needed or performed.
   * For example, if this time represents `2007-12-03T10:30+02:00` and the offset specified is
   * `+03:00`, then this method will return `2007-12-03T10:30+03:00`.
   * 
   * To take into account the difference between the offsets, and adjust the time fields,
   * use {@link #withOffsetSameInstant}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param offset  the zone offset to change to, not null
   * @return an `OffsetDateTime` based on this date-time with the requested offset, not null
  */
  withOffsetSameLocal(offset: ZoneOffset): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified offset ensuring
   * that the result is at the same instant.
   * 
   * This method returns an object with the specified `ZoneOffset` and a `LocalDateTime`
   * adjusted by the difference between the two offsets.
   * This will result in the old and new objects representing the same instant.
   * This is useful for finding the local time in a different offset.
   * For example, if this time represents `2007-12-03T10:30+02:00` and the offset specified is
   * `+03:00`, then this method will return `2007-12-03T11:30+03:00`.
   * 
   * To change the offset without adjusting the local time use {@link #withOffsetSameLocal}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param offset  the zone offset to change to, not null
   * @return an `OffsetDateTime` based on this date-time with the requested offset, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  withOffsetSameInstant(offset: ZoneOffset): OffsetDateTime;
  /**
   * Gets the `LocalDateTime` part of this date-time.
   * 
   * This returns a `LocalDateTime` with the same year, month, day and time
   * as this date-time.
   *
   * @return the local date-time part of this date-time, not null
  */
  toLocalDateTime(): LocalDateTime;
  /**
   * Gets the `LocalDate` part of this date-time.
   * 
   * This returns a `LocalDate` with the same year, month and day
   * as this date-time.
   *
   * @return the date part of this date-time, not null
  */
  toLocalDate(): LocalDate;
  /**
   * Gets the year field.
   * 
   * This method returns the primitive `int` value for the year.
   * 
   * The year returned by this method is proleptic as per `get(YEAR)`.
   * To obtain the year-of-era, use `get(YEAR_OF_ERA)`.
   *
   * @return the year, from MIN_YEAR to MAX_YEAR
  */
  get year(): number;
  /**
   * Gets the month-of-year field from 1 to 12.
   * 
   * This method returns the month as an `int` from 1 to 12.
   * Application code is frequently clearer if the enum {@link Month}
   * is used by calling {@link #getMonth()}.
   *
   * @return the month-of-year, from 1 to 12
   * @see #getMonth()
  */
  get monthValue(): number;
  /**
   * Gets the month-of-year field using the `Month` enum.
   * 
   * This method returns the enum {@link Month} for the month.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link Month#getValue() int value}.
   *
   * @return the month-of-year, not null
   * @see #getMonthValue()
  */
  get month(): Month;
  /**
   * Gets the day-of-month field.
   * 
   * This method returns the primitive `int` value for the day-of-month.
   *
   * @return the day-of-month, from 1 to 31
  */
  get dayOfMonth(): number;
  /**
   * Gets the day-of-year field.
   * 
   * This method returns the primitive `int` value for the day-of-year.
   *
   * @return the day-of-year, from 1 to 365, or 366 in a leap year
  */
  get dayOfYear(): number;
  /**
   * Gets the day-of-week field, which is an enum `DayOfWeek`.
   * 
   * This method returns the enum {@link DayOfWeek} for the day-of-week.
   * This avoids confusion as to what `int` values mean.
   * If you need access to the primitive `int` value then the enum
   * provides the {@link DayOfWeek#getValue() int value}.
   * 
   * Additional information can be obtained from the `DayOfWeek`.
   * This includes textual names of the values.
   *
   * @return the day-of-week, not null
  */
  get dayOfWeek(): DayOfWeek;
  /**
   * Gets the `LocalTime` part of this date-time.
   * 
   * This returns a `LocalTime` with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Gets the hour-of-day field.
   *
   * @return the hour-of-day, from 0 to 23
  */
  get hour(): number;
  /**
   * Gets the minute-of-hour field.
   *
   * @return the minute-of-hour, from 0 to 59
  */
  get minute(): number;
  /**
   * Gets the second-of-minute field.
   *
   * @return the second-of-minute, from 0 to 59
  */
  get second(): number;
  /**
   * Gets the nano-of-second field.
   *
   * @return the nano-of-second, from 0 to 999,999,999
  */
  get nano(): number;
  /**
   * Returns an adjusted copy of this date-time.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the date-time adjusted.
   * The adjustment takes place using the specified adjuster strategy object.
   * Read the documentation of the adjuster to understand what adjustment will be made.
   * 
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the date to the last day of the month.
   * A selection of common adjustments is provided in
   * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
   * These include finding the "last day of the month" and "next Wednesday".
   * Key date-time classes also implement the `TemporalAdjuster` interface,
   * such as {@link Month} and {@link java.time.MonthDay MonthDay}.
   * The adjuster is responsible for handling special cases, such as the varying
   * lengths of month and leap years.
   * 
   * For example this code returns a date on the last day of July:
   *      *  import static java.time.Month.*;
   *  import static java.time.temporal.TemporalAdjusters.*;
   *
   *  result = offsetDateTime.with(JULY).with(lastDayOfMonth());
   * 
   * 
   * The classes {@link LocalDate}, {@link LocalTime} and {@link ZoneOffset} implement
   * `TemporalAdjuster`, thus this method can be used to change the date, time or offset:
   *      *  result = offsetDateTime.with(date);
   *  result = offsetDateTime.with(time);
   *  result = offsetDateTime.with(offset);
   * 
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalAdjuster#adjustInto(Temporal)} method on the
   * specified adjuster passing `this` as the argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param adjuster the adjuster to use, not null
   * @return an `OffsetDateTime` based on `this` with the adjustment made, not null
   * @throws DateTimeException if the adjustment cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): OffsetDateTime;
  /**
   * Returns a copy of this date-time with the specified field set to a new value.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the value
   * for the specified field changed.
   * This can be used to change any supported field, such as the year, month or day-of-month.
   * If it is not possible to set the value, because the field is not supported or for
   * some other reason, an exception is thrown.
   * 
   * In some cases, changing the specified field can cause the resulting date-time to become invalid,
   * such as changing the month from 31st January to February would make the day-of-month invalid.
   * In cases like this, the field is responsible for resolving the date. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   * 
   * If the field is a {@link ChronoField} then the adjustment is implemented here.
   * 
   * The `INSTANT_SECONDS` field will return a date-time with the specified instant.
   * The offset and nano-of-second are unchanged.
   * If the new instant value is outside the valid range then a `DateTimeException` will be thrown.
   * 
   * The `OFFSET_SECONDS` field will return a date-time with the specified offset.
   * The local date-time is unaltered. If the new offset value is outside the valid range
   * then a `DateTimeException` will be thrown.
   * 
   * The other {@link #isSupported(TemporalField) supported fields} will behave as per
   * the matching method on {@link LocalDateTime#with(TemporalField, long) LocalDateTime}.
   * In this case, the offset is not part of the calculation and will be unchanged.
   * 
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the argument. In this case, the field determines
   * whether and how to adjust the instant.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return an `OffsetDateTime` based on `this` with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the year altered.
   * 
   * The time and offset do not affect the calculation and will be the same in the result.
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param year  the year to set in the result, from MIN_YEAR to MAX_YEAR
   * @return an `OffsetDateTime` based on this date-time with the requested year, not null
   * @throws DateTimeException if the year value is invalid
  */
  withYear(year: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the month-of-year altered.
   * 
   * The time and offset do not affect the calculation and will be the same in the result.
   * If the day-of-month is invalid for the year, it will be changed to the last valid day of the month.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param month  the month-of-year to set in the result, from 1 (January) to 12 (December)
   * @return an `OffsetDateTime` based on this date-time with the requested month, not null
   * @throws DateTimeException if the month-of-year value is invalid
  */
  withMonth(month: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the day-of-month altered.
   * 
   * If the resulting `OffsetDateTime` is invalid, an exception is thrown.
   * The time and offset do not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfMonth  the day-of-month to set in the result, from 1 to 28-31
   * @return an `OffsetDateTime` based on this date-time with the requested day, not null
   * @throws DateTimeException if the day-of-month value is invalid,
   *  or if the day-of-month is invalid for the month-year
  */
  withDayOfMonth(dayOfMonth: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the day-of-year altered.
   * 
   * The time and offset do not affect the calculation and will be the same in the result.
   * If the resulting `OffsetDateTime` is invalid, an exception is thrown.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param dayOfYear  the day-of-year to set in the result, from 1 to 365-366
   * @return an `OffsetDateTime` based on this date with the requested day, not null
   * @throws DateTimeException if the day-of-year value is invalid,
   *  or if the day-of-year is invalid for the year
  */
  withDayOfYear(dayOfYear: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the hour-of-day altered.
   * 
   * The date and offset do not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hour  the hour-of-day to set in the result, from 0 to 23
   * @return an `OffsetDateTime` based on this date-time with the requested hour, not null
   * @throws DateTimeException if the hour value is invalid
  */
  withHour(hour: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the minute-of-hour altered.
   * 
   * The date and offset do not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minute  the minute-of-hour to set in the result, from 0 to 59
   * @return an `OffsetDateTime` based on this date-time with the requested minute, not null
   * @throws DateTimeException if the minute value is invalid
  */
  withMinute(minute: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the second-of-minute altered.
   * 
   * The date and offset do not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param second  the second-of-minute to set in the result, from 0 to 59
   * @return an `OffsetDateTime` based on this date-time with the requested second, not null
   * @throws DateTimeException if the second value is invalid
  */
  withSecond(second: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the nano-of-second altered.
   * 
   * The date and offset do not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanoOfSecond  the nano-of-second to set in the result, from 0 to 999,999,999
   * @return an `OffsetDateTime` based on this date-time with the requested nanosecond, not null
   * @throws DateTimeException if the nano value is invalid
  */
  withNano(nanoOfSecond: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the time truncated.
   * 
   * Truncation returns a copy of the original date-time with fields
   * smaller than the specified unit set to zero.
   * For example, truncating with the {@link ChronoUnit#MINUTES minutes} unit
   * will set the second-of-minute and nano-of-second field to zero.
   * 
   * The unit must have a {@linkplain TemporalUnit#getDuration() duration}
   * that divides into the length of a standard day without remainder.
   * This includes all supplied time units on {@link ChronoUnit} and
   * {@link ChronoUnit#DAYS DAYS}. Other units throw an exception.
   * 
   * The offset does not affect the calculation and will be the same in the result.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param unit  the unit to truncate to, not null
   * @return an `OffsetDateTime` based on this date-time with the time truncated, not null
   * @throws DateTimeException if unable to truncate
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  truncatedTo(unit: TemporalUnit): OffsetDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the specified amount added.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#addTo(Temporal)}. The amount implementation is free
   * to implement the addition in any way it wishes, however it typically
   * calls back to {@link #plus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount to add, not null
   * @return an `OffsetDateTime` based on this date-time with the addition made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): OffsetDateTime;
  /**
   * Returns a copy of this date-time with the specified amount added.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the amount
   * in terms of the unit added. If it is not possible to add the amount, because the
   * unit is not supported or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoUnit} then the addition is implemented by
   * {@link LocalDateTime#plus(long, TemporalUnit)}.
   * The offset is not part of the calculation and will be unchanged in the result.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the argument. In this case, the unit determines
   * whether and how to perform the addition.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the amount of the unit to add to the result, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return an `OffsetDateTime` based on this date-time with the specified amount added, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of years added.
   * 
   * This method adds the specified amount to the years field in three steps:
   * 
   * Add the input years to the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) plus one year would result in the
   * invalid date 2009-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2009-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the years added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusYears(years: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of months added.
   * 
   * This method adds the specified amount to the months field in three steps:
   * 
   * Add the input months to the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 plus one month would result in the invalid date
   * 2007-04-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-04-30, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the months added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMonths(months: number): OffsetDateTime;
  /**
   * Returns a copy of this OffsetDateTime with the specified number of weeks added.
   * 
   * This method adds the specified amount in weeks to the days field incrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one week would result in 2009-01-07.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the weeks added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusWeeks(weeks: number): OffsetDateTime;
  /**
   * Returns a copy of this OffsetDateTime with the specified number of days added.
   * 
   * This method adds the specified amount to the days field incrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2008-12-31 plus one day would result in 2009-01-01.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the days added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusDays(days: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of hours added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the hours added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusHours(hours: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of minutes added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the minutes added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusMinutes(minutes: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of seconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the seconds added, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  plusSeconds(seconds: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of nanoseconds added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to add, may be negative
   * @return an `OffsetDateTime` based on this date-time with the nanoseconds added, not null
   * @throws DateTimeException if the unit cannot be added to this type
  */
  plusNanos(nanos: number): OffsetDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the specified amount subtracted.
   * The amount is typically {@link Period} or {@link Duration} but may be
   * any other type implementing the {@link TemporalAmount} interface.
   * 
   * The calculation is delegated to the amount object by calling
   * {@link TemporalAmount#subtractFrom(Temporal)}. The amount implementation is free
   * to implement the subtraction in any way it wishes, however it typically
   * calls back to {@link #minus(long, TemporalUnit)}. Consult the documentation
   * of the amount implementation to determine if it can be successfully subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount to subtract, not null
   * @return an `OffsetDateTime` based on this date-time with the subtraction made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): OffsetDateTime;
  /**
   * Returns a copy of this date-time with the specified amount subtracted.
   * 
   * This returns an `OffsetDateTime`, based on this one, with the amount
   * in terms of the unit subtracted. If it is not possible to subtract the amount,
   * because the unit is not supported or for some other reason, an exception is thrown.
   * 
   * This method is equivalent to {@link #plus(long, TemporalUnit)} with the amount negated.
   * See that method for a full description of how addition, and thus subtraction, works.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the amount of the unit to subtract from the result, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return an `OffsetDateTime` based on this date-time with the specified amount subtracted, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of years subtracted.
   * 
   * This method subtracts the specified amount from the years field in three steps:
   * 
   * Subtract the input years from the year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2008-02-29 (leap year) minus one year would result in the
   * invalid date 2007-02-29 (standard year). Instead of returning an invalid
   * result, the last valid day of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param years  the years to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the years subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusYears(years: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of months subtracted.
   * 
   * This method subtracts the specified amount from the months field in three steps:
   * 
   * Subtract the input months from the month-of-year field
   * Check if the resulting date would be invalid
   * Adjust the day-of-month to the last valid day if necessary
   * 
   * 
   * For example, 2007-03-31 minus one month would result in the invalid date
   * 2007-02-31. Instead of returning an invalid result, the last valid day
   * of the month, 2007-02-28, is selected instead.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param months  the months to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the months subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMonths(months: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of weeks subtracted.
   * 
   * This method subtracts the specified amount in weeks from the days field decrementing
   * the month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-07 minus one week would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param weeks  the weeks to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the weeks subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusWeeks(weeks: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of days subtracted.
   * 
   * This method subtracts the specified amount from the days field decrementing the
   * month and year fields as necessary to ensure the result remains valid.
   * The result is only invalid if the maximum/minimum year is exceeded.
   * 
   * For example, 2009-01-01 minus one day would result in 2008-12-31.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param days  the days to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the days subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusDays(days: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of hours subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param hours  the hours to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the hours subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusHours(hours: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of minutes subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param minutes  the minutes to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the minutes subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusMinutes(minutes: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of seconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param seconds  the seconds to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the seconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusSeconds(seconds: number): OffsetDateTime;
  /**
   * Returns a copy of this `OffsetDateTime` with the specified number of nanoseconds subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param nanos  the nanos to subtract, may be negative
   * @return an `OffsetDateTime` based on this date-time with the nanoseconds subtracted, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  minusNanos(nanos: number): OffsetDateTime;
  /**
   * Queries this date-time using the specified query.
   * 
   * This queries this date-time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same offset, date
   * and time as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the offset, date and time changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * three times, passing {@link ChronoField#EPOCH_DAY},
   * {@link ChronoField#NANO_OF_DAY} and {@link ChronoField#OFFSET_SECONDS} as the fields.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisOffsetDateTime.adjustInto(temporal);
   *   temporal = temporal.with(thisOffsetDateTime);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another date-time in terms of the specified unit.
   * 
   * This calculates the amount of time between two `OffsetDateTime`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date-time.
   * The result will be negative if the end is before the start.
   * For example, the amount in days between two date-times can be calculated
   * using `startDateTime.until(endDateTime, DAYS)`.
   * 
   * The `Temporal` passed to this method is converted to a
   * `OffsetDateTime` using {@link #from(TemporalAccessor)}.
   * If the offset differs between the two date-times, the specified
   * end date-time is normalized to have the same offset as this date-time.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two date-times.
   * For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z
   * will only be one month as it is one minute short of two months.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `NANOS`, `MICROS`, `MILLIS`, `SECONDS`,
   * `MINUTES`, `HOURS` and `HALF_DAYS`, `DAYS`,
   * `WEEKS`, `MONTHS`, `YEARS`, `DECADES`,
   * `CENTURIES`, `MILLENNIA` and `ERAS` are supported.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal
   * as the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to an `OffsetDateTime`, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date-time and the end date-time
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to an `OffsetDateTime`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Formats this date-time using the specified formatter.
   * 
   * This date-time will be passed to the formatter to produce a string.
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date-time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this date-time with a time-zone to create a `ZonedDateTime`
   * ensuring that the result has the same instant.
   * 
   * This returns a `ZonedDateTime` formed from this date-time and the specified time-zone.
   * This conversion will ignore the visible local date-time and use the underlying instant instead.
   * This avoids any problems with local time-line gaps or overlaps.
   * The result might have different values for fields such as hour, minute an even day.
   * 
   * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.
   * To use the offset as the zone ID, use {@link #toZonedDateTime()}.
   *
   * @param zone  the time-zone to use, not null
   * @return the zoned date-time formed from this date-time, not null
  */
  atZoneSameInstant(zone: ZoneId): ZonedDateTime;
  /**
   * Combines this date-time with a time-zone to create a `ZonedDateTime`
   * trying to keep the same local date and time.
   * 
   * This returns a `ZonedDateTime` formed from this date-time and the specified time-zone.
   * Where possible, the result will have the same local date-time as this object.
   * 
   * Time-zone rules, such as daylight savings, mean that not every time on the
   * local time-line exists. If the local date-time is in a gap or overlap according to
   * the rules then a resolver is used to determine the resultant local time and offset.
   * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}
   * to retain the offset from this instance if possible.
   * 
   * Finer control over gaps and overlaps is available in two ways.
   * If you simply want to use the later offset at overlaps then call
   * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.
   * 
   * To create a zoned date-time at the same instant irrespective of the local time-line,
   * use {@link #atZoneSameInstant(ZoneId)}.
   * To use the offset as the zone ID, use {@link #toZonedDateTime()}.
   *
   * @param zone  the time-zone to use, not null
   * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null
  */
  atZoneSimilarLocal(zone: ZoneId): ZonedDateTime;
  /**
   * Converts this date-time to an `OffsetTime`.
   * 
   * This returns an offset time with the same local time and offset.
   *
   * @return an OffsetTime representing the time and offset, not null
  */
  toOffsetTime(): OffsetTime;
  /**
   * Converts this date-time to a `ZonedDateTime` using the offset as the zone ID.
   * 
   * This creates the simplest possible `ZonedDateTime` using the offset
   * as the zone ID.
   * 
   * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and
   * {@link #atZoneSimilarLocal(ZoneId)}.
   *
   * @return a zoned date-time representing the same local date-time and offset, not null
  */
  toZonedDateTime(): ZonedDateTime;
  /**
   * Converts this date-time to an `Instant`.
   * 
   * This returns an `Instant` representing the same point on the
   * time-line as this date-time.
   *
   * @return an `Instant` representing the same instant, not null
  */
  toInstant(): Instant;
  /**
   * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.
   * 
   * This allows this date-time to be converted to a value of the
   * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily
   * intended for low-level conversions rather than general application usage.
   *
   * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z
  */
  toEpochSecond(): number;
  /**
   * Compares this date-time to another date-time.
   * 
   * The comparison is based on the instant then on the local date-time.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * For example, the following is the comparator order:
   * 
   * `2008-12-03T10:30+01:00`
   * `2008-12-03T11:00+01:00`
   * `2008-12-03T12:00+02:00`
   * `2008-12-03T11:30+01:00`
   * `2008-12-03T12:00+01:00`
   * `2008-12-03T12:30+01:00`
   * 
   * Values #2 and #3 represent the same instant on the time-line.
   * When two values represent the same instant, the local date-time is compared
   * to distinguish them. This step is needed to make the ordering
   * consistent with `equals()`.
   *
   * @param other  the other date-time to compare to, not null
   * @return the comparator value, that is the comparison with the `other`'s instant, if they are not equal;
   *          and if equal to the `other`'s instant, the comparison of the `other`'s local date-time
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: OffsetDateTime): number;
  /**
   * Checks if the instant of this date-time is after that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} and {@link #equals} in that it
   * only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().isAfter(dateTime2.toInstant());`.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this is after the instant of the specified date-time
  */
  isAfter(other: OffsetDateTime): boolean;
  /**
   * Checks if the instant of this date-time is before that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().isBefore(dateTime2.toInstant());`.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this is before the instant of the specified date-time
  */
  isBefore(other: OffsetDateTime): boolean;
  /**
   * Checks if the instant of this date-time is equal to that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} and {@link #equals}
   * in that it only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().equals(dateTime2.toInstant());`.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if the instant equals the instant of the specified date-time
  */
  isEqual(other: OffsetDateTime): boolean;
  /**
   * Checks if this date-time is equal to another date-time.
   * 
   * The comparison is based on the local date-time and the offset.
   * To compare for the same instant on the time-line, use {@link #isEqual}.
   * Only objects of type `OffsetDateTime` are compared, other types return false.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date-time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date-time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date-time as a `String`, such as `2007-12-03T10:15:30+01:00`.
   * 
   * The output will be one of the following formats:
   * 
   * `uuuu-MM-dd'T'HH:mmXXXXX`
   * `uuuu-MM-dd'T'HH:mm:ssXXXXX`
   * `uuuu-MM-dd'T'HH:mm:ss.SSSXXXXX`
   * `uuuu-MM-dd'T'HH:mm:ss.SSSSSSXXXXX`
   * `uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSSXXXXX`
   * 
   * The format used will be the shortest that outputs the full value of
   * the time where the omitted parts are implied to be zero. The output
   * is compatible with ISO 8601 if the seconds in the offset are zero.
   *
   * @return a string representation of this date-time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface OffsetDateTime extends Temporal, TemporalAdjuster, Comparable<OffsetDateTime>, Serializable {}
/**
 * A clock providing access to the current instant, date and time using a time-zone.
 * 
 * Instances of this abstract class are used to access a pluggable representation of the
 * current instant, which can be interpreted using the stored time-zone to find the
 * current date and time.
 * For example, `Clock` can be used instead of {@link System#currentTimeMillis()}
 * and {@link TimeZone#getDefault()}.
 * 
 * Use of a `Clock` is optional. All key date-time classes also have a
 * `now()` factory method that uses the system clock in the default time zone.
 * The primary purpose of this abstraction is to allow alternate clocks to be
 * plugged in as and when required. Applications use an object to obtain the
 * current time rather than a static method. This can simplify testing.
 * 
 * As such, this abstract class does not guarantee the result actually represents the current instant
 * on the time-line. Instead, it allows the application to provide a controlled view as to what
 * the current instant and time-zone are.
 * 
 * Best practice for applications is to pass a `Clock` into any method
 * that requires the current instant and time-zone. A dependency injection framework
 * is one way to achieve this:
 *  *  public class MyBean {
 *    private Clock clock;  // dependency inject
 *    ...
 *    public void process(LocalDate eventDate) {
 *      if (eventDate.isBefore(LocalDate.now(clock)) {
 *        ...
 *      }
 *    }
 *  }
 * 
 * This approach allows an alternative clock, such as {@link #fixed(Instant, ZoneId) fixed}
 * or {@link #offset(Clock, Duration) offset} to be used during testing.
 * 
 * The `system` factory methods provide clocks based on the best available
 * system clock. This may use {@link System#currentTimeMillis()}, or a higher
 * resolution clock if one is available.
 *
 * @implSpec
 * This abstract class must be implemented with care to ensure other classes operate correctly.
 * All implementations must be thread-safe - a single instance must be capable of be invoked
 * from multiple threads without negative consequences such as race conditions.
 * 
 * The principal methods are defined to allow the throwing of an exception.
 * In normal use, no exceptions will be thrown, however one possible implementation would be to
 * obtain the time from a central time server across the network. Obviously, in this case the
 * lookup could fail, and so the method is permitted to throw an exception.
 * 
 * The returned instants from `Clock` work on a time-scale that ignores leap seconds,
 * as described in {@link Instant}. If the implementation wraps a source that provides leap
 * second information, then a mechanism should be used to "smooth" the leap second.
 * The Java Time-Scale mandates the use of UTC-SLS, however clock implementations may choose
 * how accurate they are with the time-scale so long as they document how they work.
 * Implementations are therefore not required to actually perform the UTC-SLS slew or to
 * otherwise be aware of leap seconds.
 * 
 * Implementations should implement `Serializable` wherever possible and must
 * document whether or not they do support serialization.
 *
 * @see InstantSource
 *
 * @since 1.8
*/
export class Clock extends InstantSource {
  /**
   * Obtains a clock that returns the current instant using the best available
   * system clock, converting to date and time using the UTC time-zone.
   * 
   * This clock, rather than {@link #systemDefaultZone()}, should be used when
   * you need the current instant without the date or time.
   * 
   * This clock is based on the best available system clock.
   * This may use {@link System#currentTimeMillis()}, or a higher resolution
   * clock if one is available.
   * 
   * Conversion from instant to date or time uses the {@linkplain ZoneOffset#UTC UTC time-zone}.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   * It is equivalent to `system(ZoneOffset.UTC)`.
   *
   * @return a clock that uses the best available system clock in the UTC zone, not null
  */
  static systemUTC(): Clock;
  /**
   * Obtains a clock that returns the current instant using the best available
   * system clock, converting to date and time using the default time-zone.
   * 
   * This clock is based on the best available system clock.
   * This may use {@link System#currentTimeMillis()}, or a higher resolution
   * clock if one is available.
   * 
   * Using this method hard codes a dependency to the default time-zone into your application.
   * It is recommended to avoid this and use a specific time-zone whenever possible.
   * The {@link #systemUTC() UTC clock} should be used when you need the current instant
   * without the date or time.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   * It is equivalent to `system(ZoneId.systemDefault())`.
   *
   * @return a clock that uses the best available system clock in the default zone, not null
   * @see ZoneId#systemDefault()
  */
  static systemDefaultZone(): Clock;
  /**
   * Obtains a clock that returns the current instant using the best available
   * system clock.
   * 
   * This clock is based on the best available system clock.
   * This may use {@link System#currentTimeMillis()}, or a higher resolution
   * clock if one is available.
   * 
   * Conversion from instant to date or time uses the specified time-zone.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   *
   * @param zone  the time-zone to use to convert the instant to date-time, not null
   * @return a clock that uses the best available system clock in the specified zone, not null
  */
  static system(zone: ZoneId): Clock;
  /**
   * Obtains a clock that returns the current instant ticking in whole milliseconds
   * using the best available system clock.
   * 
   * This clock will always have the nano-of-second field truncated to milliseconds.
   * This ensures that the visible time ticks in whole milliseconds.
   * The underlying clock is the best available system clock, equivalent to
   * using {@link #system(ZoneId)}.
   * 
   * Implementations may use a caching strategy for performance reasons.
   * As such, it is possible that the start of the millisecond observed via this
   * clock will be later than that observed directly via the underlying clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   * It is equivalent to `tick(system(zone), Duration.ofMillis(1))`.
   *
   * @param zone  the time-zone to use to convert the instant to date-time, not null
   * @return a clock that ticks in whole milliseconds using the specified zone, not null
   * @since 9
  */
  static tickMillis(zone: ZoneId): Clock;
  /**
   * Obtains a clock that returns the current instant ticking in whole seconds
   * using the best available system clock.
   * 
   * This clock will always have the nano-of-second field set to zero.
   * This ensures that the visible time ticks in whole seconds.
   * The underlying clock is the best available system clock, equivalent to
   * using {@link #system(ZoneId)}.
   * 
   * Implementations may use a caching strategy for performance reasons.
   * As such, it is possible that the start of the second observed via this
   * clock will be later than that observed directly via the underlying clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   * It is equivalent to `tick(system(zone), Duration.ofSeconds(1))`.
   *
   * @param zone  the time-zone to use to convert the instant to date-time, not null
   * @return a clock that ticks in whole seconds using the specified zone, not null
  */
  static tickSeconds(zone: ZoneId): Clock;
  /**
   * Obtains a clock that returns the current instant ticking in whole minutes
   * using the best available system clock.
   * 
   * This clock will always have the nano-of-second and second-of-minute fields set to zero.
   * This ensures that the visible time ticks in whole minutes.
   * The underlying clock is the best available system clock, equivalent to
   * using {@link #system(ZoneId)}.
   * 
   * Implementations may use a caching strategy for performance reasons.
   * As such, it is possible that the start of the minute observed via this
   * clock will be later than that observed directly via the underlying clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   * It is equivalent to `tick(system(zone), Duration.ofMinutes(1))`.
   *
   * @param zone  the time-zone to use to convert the instant to date-time, not null
   * @return a clock that ticks in whole minutes using the specified zone, not null
  */
  static tickMinutes(zone: ZoneId): Clock;
  /**
   * Obtains a clock that returns instants from the specified clock truncated
   * to the nearest occurrence of the specified duration.
   * 
   * This clock will only tick as per the specified duration. Thus, if the duration
   * is half a second, the clock will return instants truncated to the half second.
   * 
   * The tick duration must be positive. If it has a part smaller than a whole
   * millisecond, then the whole duration must divide into one second without
   * leaving a remainder. All normal tick durations will match these criteria,
   * including any multiple of hours, minutes, seconds and milliseconds, and
   * sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.
   * 
   * A duration of zero or one nanosecond would have no truncation effect.
   * Passing one of these will return the underlying clock.
   * 
   * Implementations may use a caching strategy for performance reasons.
   * As such, it is possible that the start of the requested duration observed
   * via this clock will be later than that observed directly via the underlying clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`
   * providing that the base clock is.
   *
   * @param baseClock  the base clock to base the ticking clock on, not null
   * @param tickDuration  the duration of each visible tick, not negative, not null
   * @return a clock that ticks in whole units of the duration, not null
   * @throws IllegalArgumentException if the duration is negative, or has a
   *  part smaller than a whole millisecond such that the whole duration is not
   *  divisible into one second
   * @throws ArithmeticException if the duration is too large to be represented as nanos
  */
  static tick(baseClock: Clock, tickDuration: Duration): Clock;
  /**
   * Obtains a clock that always returns the same instant.
   * 
   * This clock simply returns the specified instant.
   * As such, it is not a clock in the conventional sense.
   * The main use case for this is in testing, where the fixed clock ensures
   * tests are not dependent on the current clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   *
   * @param fixedInstant  the instant to use as the clock, not null
   * @param zone  the time-zone to use to convert the instant to date-time, not null
   * @return a clock that always returns the same instant, not null
  */
  static fixed(fixedInstant: Instant, zone: ZoneId): Clock;
  /**
   * Obtains a clock that returns instants from the specified clock with the
   * specified duration added.
   * 
   * This clock wraps another clock, returning instants that are later by the
   * specified duration. If the duration is negative, the instants will be
   * earlier than the current date and time.
   * The main use case for this is to simulate running in the future or in the past.
   * 
   * A duration of zero would have no offsetting effect.
   * Passing zero will return the underlying clock.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`
   * providing that the base clock is.
   *
   * @param baseClock  the base clock to add the duration to, not null
   * @param offsetDuration  the duration to add, not null
   * @return a clock based on the base clock with the duration added, not null
  */
  static offset(baseClock: Clock, offsetDuration: Duration): Clock;
  /**
   * Gets the time-zone being used to create dates and times.
   * 
   * A clock will typically obtain the current instant and then convert that
   * to a date or time using a time-zone. This method returns the time-zone used.
   *
   * @return the time-zone being used to interpret instants, not null
  */
  get zone(): ZoneId;
  /**
   * Returns a copy of this clock with a different time-zone.
   * 
   * A clock will typically obtain the current instant and then convert that
   * to a date or time using a time-zone. This method returns a clock with
   * similar properties but using a different time-zone.
   *
   * @param zone  the time-zone to change to, not null
   * @return a clock based on this clock with the specified time-zone, not null
  */
  withZone(zone: ZoneId): Clock;
  /**
   * Gets the current millisecond instant of the clock.
   * 
   * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).
   * This is equivalent to the definition of {@link System#currentTimeMillis()}.
   * 
   * Most applications should avoid this method and use {@link Instant} to represent
   * an instant on the time-line rather than a raw millisecond value.
   * This method is provided to allow the use of the clock in high performance use cases
   * where the creation of an object would be unacceptable.
   * 
   * The default implementation currently calls {@link #instant}.
   *
   * @return the current millisecond instant from this clock, measured from
   *  the Java epoch of 1970-01-01T00:00Z (UTC), not null
   * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
  */
  millis(): number;
  /**
   * Gets the current instant of the clock.
   * 
   * This returns an instant representing the current instant as defined by the clock.
   *
   * @return the current instant from this clock, not null
   * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations
  */
  instant(): Instant;
  /**
   * Checks if this clock is equal to another clock.
   * 
   * Clocks should override this method to compare equals based on
   * their state and to meet the contract of {@link Object#equals}.
   * If not overridden, the behavior is defined by {@link Object#equals}
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other clock
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this clock.
   * 
   * Clocks should override this method based on
   * their state and to meet the contract of {@link Object#hashCode}.
   * If not overridden, the behavior is defined by {@link Object#hashCode}
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Obtains a source that returns the current instant using the best available
   * system clock.
   * 
   * This source is based on the best available system clock. This may use
   * {@link System#currentTimeMillis()}, or a higher resolution system clock if
   * one is available.
   * 
   * The returned implementation is immutable, thread-safe and
   * `Serializable`.
   *
   * @return a source that uses the best available system clock, not null
  */
  static system(): InstantSource;
  /**
   * Obtains a source that returns instants from the specified source truncated to
   * the nearest occurrence of the specified duration.
   * 
   * This source will only tick as per the specified duration. Thus, if the
   * duration is half a second, the source will return instants truncated to the
   * half second.
   * 
   * The tick duration must be positive. If it has a part smaller than a whole
   * millisecond, then the whole duration must divide into one second without
   * leaving a remainder. All normal tick durations will match these criteria,
   * including any multiple of hours, minutes, seconds and milliseconds, and
   * sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.
   * 
   * A duration of zero or one nanosecond would have no truncation effect. Passing
   * one of these will return the underlying source.
   * 
   * Implementations may use a caching strategy for performance reasons. As such,
   * it is possible that the start of the requested duration observed via this
   * source will be later than that observed directly via the underlying source.
   * 
   * The returned implementation is immutable, thread-safe and
   * `Serializable` providing that the base source is.
   *
   * @param baseSource  the base source to base the ticking source on, not null
   * @param tickDuration  the duration of each visible tick, not negative, not null
   * @return a source that ticks in whole units of the duration, not null
   * @throws IllegalArgumentException if the duration is negative, or has a
   *  part smaller than a whole millisecond such that the whole duration is not
   *  divisible into one second
   * @throws ArithmeticException if the duration is too large to be represented as nanos
  */
  static tick(baseSource: InstantSource, tickDuration: Duration): InstantSource;
  /**
   * Obtains a source that always returns the same instant.
   * 
   * This source simply returns the specified instant.
   * As such, it is not a source that represents the current instant.
   * The main use case for this is in testing, where the fixed source ensures
   * tests are not dependent on the current source.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`.
   *
   * @param fixedInstant  the instant to use, not null
   * @return a source that always returns the same instant, not null
  */
  static fixed(fixedInstant: Instant): InstantSource;
  /**
   * Obtains a source that returns instants from the specified source with the
   * specified duration added.
   * 
   * This source wraps another source, returning instants that are later by the
   * specified duration. If the duration is negative, the instants will be
   * earlier than the current date and time.
   * The main use case for this is to simulate running in the future or in the past.
   * 
   * A duration of zero would have no offsetting effect.
   * Passing zero will return the underlying source.
   * 
   * The returned implementation is immutable, thread-safe and `Serializable`
   * providing that the base source is.
   *
   * @param baseSource  the base source to add the duration to, not null
   * @param offsetDuration  the duration to add, not null
   * @return a source based on the base source with the duration added, not null
  */
  static offset(baseSource: InstantSource, offsetDuration: Duration): InstantSource;
}

}
declare module 'java.time.zone.ZoneOffsetTransitionRule' {
import { LocalDateTime, ZoneOffset } from 'java.time';
import { Enum } from 'java.lang';
/**
 * A definition of the way a local time can be converted to the actual
 * transition date-time.
 * 
 * Time zone rules are expressed in one of three ways:
 * 
 * Relative to UTC
 * Relative to the standard offset in force
 * Relative to the wall offset (what you would see on a clock on the wall)
 * 
*/
export class TimeDefinition extends Enum<TimeDefinition> {
  /**
   The local date-time is expressed in terms of the UTC offset. 
  */
  static readonly UTC: TimeDefinition;
  /**
   The local date-time is expressed in terms of the wall offset. 
  */
  static readonly WALL: TimeDefinition;
  /**
   The local date-time is expressed in terms of the standard offset. 
  */
  static readonly STANDARD: TimeDefinition;
  static valueOf(name: string): TimeDefinition;
  static values(): TimeDefinition[];
  /**
   * Converts the specified local date-time to the local date-time actually
   * seen on a wall clock.
   * 
   * This method converts using the type of this enum.
   * The output is defined relative to the 'before' offset of the transition.
   * 
   * The UTC type uses the UTC offset.
   * The STANDARD type uses the standard offset.
   * The WALL type returns the input date-time.
   * The result is intended for use with the wall-offset.
   *
   * @param dateTime  the local date-time, not null
   * @param standardOffset  the standard offset, not null
   * @param wallOffset  the wall offset, not null
   * @return the date-time relative to the wall/before offset, not null
  */
  createDateTime(dateTime: LocalDateTime, standardOffset: ZoneOffset, wallOffset: ZoneOffset): LocalDateTime;
}

}
declare module 'java.time.format' {
import { DateTimePrinterParser, CompositePrinterParser } from 'java.time.format.DateTimeFormatterBuilder';
import { DateTimeException, ZoneId, Period } from 'java.time';
import { Locale, Set, List, Map } from 'java.util';
import { Format, ParsePosition } from 'java.text';
import { Enum, Appendable, CharSequence, Throwable } from 'java.lang';
import { Pattern } from 'java.util.regex';
import { ChronoLocalDate, Chronology } from 'java.time.chrono';
import { ConcurrentMap } from 'java.util.concurrent';
import { TemporalAccessor, TemporalField, TemporalQuery } from 'java.time.temporal';
/**
 * Enumeration of ways to handle the positive/negative sign.
 * 
 * The formatting engine allows the positive and negative signs of numbers
 * to be controlled using this enum.
 * See {@link DateTimeFormatterBuilder} for usage.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class SignStyle extends Enum<SignStyle> {
  /**
   * Style to output the sign only if the value is negative.
   * 
   * In strict parsing, the negative sign will be accepted and the positive sign rejected.
   * In lenient parsing, any sign will be accepted.
  */
  static readonly NORMAL: SignStyle;
  /**
   * Style to always output the sign, where zero will output '+'.
   * 
   * In strict parsing, the absence of a sign will be rejected.
   * In lenient parsing, any sign will be accepted, with the absence
   * of a sign treated as a positive number.
  */
  static readonly ALWAYS: SignStyle;
  /**
   * Style to never output sign, only outputting the absolute value.
   * 
   * In strict parsing, any sign will be rejected.
   * In lenient parsing, any sign will be accepted unless the width is fixed.
  */
  static readonly NEVER: SignStyle;
  /**
   * Style to block negative values, throwing an exception on printing.
   * 
   * In strict parsing, any sign will be rejected.
   * In lenient parsing, any sign will be accepted unless the width is fixed.
  */
  static readonly NOT_NEGATIVE: SignStyle;
  /**
   * Style to always output the sign if the value exceeds the pad width.
   * A negative value will always output the '-' sign.
   * 
   * In strict parsing, the sign will be rejected unless the pad width is exceeded.
   * In lenient parsing, any sign will be accepted, with the absence
   * of a sign treated as a positive number.
  */
  static readonly EXCEEDS_PAD: SignStyle;
  static valueOf(name: string): SignStyle;
  static values(): SignStyle[];
}
/**
 * Builder to create date-time formatters.
 * 
 * This allows a `DateTimeFormatter` to be created.
 * All date-time formatters are created ultimately using this builder.
 * 
 * The basic elements of date-time can all be added:
 * 
 * Value - a numeric value
 * Fraction - a fractional value including the decimal place. Always use this when
 * outputting fractions to ensure that the fraction is parsed correctly
 * Text - the textual equivalent for the value
 * OffsetId/Offset - the {@linkplain ZoneOffset zone offset}
 * ZoneId - the {@linkplain ZoneId time-zone} id
 * ZoneText - the name of the time-zone
 * ChronologyId - the {@linkplain Chronology chronology} id
 * ChronologyText - the name of the chronology
 * Literal - a text literal
 * Nested and Optional - formats can be nested or made optional
 * 
 * In addition, any of the elements may be decorated by padding, either with spaces or any other character.
 * 
 * Finally, a shorthand pattern, mostly compatible with `java.text.SimpleDateFormat SimpleDateFormat`
 * can be used, see {@link #appendPattern(String)}.
 * In practice, this simply parses the pattern and calls other methods on the builder.
 *
 * @implSpec
 * This class is a mutable builder intended for use from a single thread.
 *
 * @since 1.8
*/
export class DateTimeFormatterBuilder {
  /**
   * Gets the formatting pattern for date and time styles for a locale and chronology.
   * The locale and chronology are used to lookup the locale specific format
   * for the requested dateStyle and/or timeStyle.
   * 
   * If the locale contains the "rg" (region override)
   * Unicode extensions,
   * the formatting pattern is overridden with the one appropriate for the region.
   *
   * @param dateStyle  the FormatStyle for the date, null for time-only pattern
   * @param timeStyle  the FormatStyle for the time, null for date-only pattern
   * @param chrono  the Chronology, non-null
   * @param locale  the locale, non-null
   * @return the locale and Chronology specific formatting pattern
   * @throws IllegalArgumentException if both dateStyle and timeStyle are null
  */
  static getLocalizedDateTimePattern(dateStyle: FormatStyle, timeStyle: FormatStyle, chrono: Chronology, locale: Locale): string;
  /**
   * Returns the formatting pattern for the requested template for a locale and chronology.
   * The locale and chronology are used to lookup the locale specific format
   * for the requested template.
   * 
   * If the locale contains the "rg" (region override)
   * Unicode extensions,
   * the formatting pattern is overridden with the one appropriate for the region.
   * 
   * Refer to {@link #appendLocalized(String)} for the detail of `requestedTemplate`
   * argument.
   *
   * @param requestedTemplate the requested template, not null
   * @param chrono  the Chronology, non-null
   * @param locale  the locale, non-null
   * @return the locale and Chronology specific formatting pattern
   * @throws IllegalArgumentException if `requestedTemplate` does not match
   *      the regular expression syntax described in {@link #appendLocalized(String)}.
   * @throws DateTimeException if a match for the localized pattern for
   *      `requestedTemplate` is not available
   * @see #appendLocalized(String)
   * @since 19
  */
  static getLocalizedDateTimePattern(requestedTemplate: string, chrono: Chronology, locale: Locale): string;
  /**
   * Constructs a new instance of the builder.
  */
  constructor();
  /**
   * Changes the parse style to be case sensitive for the remainder of the formatter.
   * 
   * Parsing can be case sensitive or insensitive - by default it is case sensitive.
   * This method allows the case sensitivity setting of parsing to be changed.
   * 
   * Calling this method changes the state of the builder such that all
   * subsequent builder method calls will parse text in case sensitive mode.
   * See {@link #parseCaseInsensitive} for the opposite setting.
   * The parse case sensitive/insensitive methods may be called at any point
   * in the builder, thus the parser can swap between case parsing modes
   * multiple times during the parse.
   * 
   * Since the default is case sensitive, this method should only be used after
   * a previous call to `#parseCaseInsensitive`.
   *
   * @return this, for chaining, not null
  */
  parseCaseSensitive(): DateTimeFormatterBuilder;
  /**
   * Changes the parse style to be case insensitive for the remainder of the formatter.
   * 
   * Parsing can be case sensitive or insensitive - by default it is case sensitive.
   * This method allows the case sensitivity setting of parsing to be changed.
   * 
   * Calling this method changes the state of the builder such that all
   * subsequent builder method calls will parse text in case insensitive mode.
   * See {@link #parseCaseSensitive()} for the opposite setting.
   * The parse case sensitive/insensitive methods may be called at any point
   * in the builder, thus the parser can swap between case parsing modes
   * multiple times during the parse.
   *
   * @return this, for chaining, not null
  */
  parseCaseInsensitive(): DateTimeFormatterBuilder;
  /**
   * Changes the parse style to be strict for the remainder of the formatter.
   * 
   * Parsing can be strict or lenient - by default it is strict.
   * This controls the degree of flexibility in matching the text and sign styles.
   * 
   * When used, this method changes the parsing to be strict from this point onwards.
   * As strict is the default, this is normally only needed after calling {@link #parseLenient()}.
   * The change will remain in force until the end of the formatter that is eventually
   * constructed or until `parseLenient` is called.
   *
   * @return this, for chaining, not null
  */
  parseStrict(): DateTimeFormatterBuilder;
  /**
   * Changes the parse style to be lenient for the remainder of the formatter.
   * Note that case sensitivity is set separately to this method.
   * 
   * Parsing can be strict or lenient - by default it is strict.
   * This controls the degree of flexibility in matching the text and sign styles.
   * Applications calling this method should typically also call {@link #parseCaseInsensitive()}.
   * 
   * When used, this method changes the parsing to be lenient from this point onwards.
   * The change will remain in force until the end of the formatter that is eventually
   * constructed or until `parseStrict` is called.
   *
   * @return this, for chaining, not null
  */
  parseLenient(): DateTimeFormatterBuilder;
  /**
   * Appends a default value for a field to the formatter for use in parsing.
   * 
   * This appends an instruction to the builder to inject a default value
   * into the parsed result. This is especially useful in conjunction with
   * optional parts of the formatter.
   * 
   * For example, consider a formatter that parses the year, followed by
   * an optional month, with a further optional day-of-month. Using such a
   * formatter would require the calling code to check whether a full date,
   * year-month or just a year had been parsed. This method can be used to
   * default the month and day-of-month to a sensible value, such as the
   * first of the month, allowing the calling code to always get a date.
   * 
   * During formatting, this method has no effect.
   * 
   * During parsing, the current state of the parse is inspected.
   * If the specified field has no associated value, because it has not been
   * parsed successfully at that point, then the specified value is injected
   * into the parse result. Injection is immediate, thus the field-value pair
   * will be visible to any subsequent elements in the formatter.
   * As such, this method is normally called at the end of the builder.
   *
   * @param field  the field to default the value of, not null
   * @param value  the value to default the field to
   * @return this, for chaining, not null
  */
  parseDefaulting(field: TemporalField, value: number): DateTimeFormatterBuilder;
  /**
   * Appends the value of a date-time field to the formatter using a normal
   * output style.
   * 
   * The value of the field will be output during a format.
   * If the value cannot be obtained then an exception will be thrown.
   * 
   * The value will be printed as per the normal format of an integer value.
   * Only negative numbers will be signed. No padding will be added.
   * 
   * The parser for a variable width value such as this normally behaves greedily,
   * requiring one digit, but accepting as many digits as possible.
   * This behavior can be affected by 'adjacent value parsing'.
   * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
   *
   * @param field  the field to append, not null
   * @return this, for chaining, not null
  */
  appendValue(field: TemporalField): DateTimeFormatterBuilder;
  /**
   * Appends the value of a date-time field to the formatter using a fixed
   * width, zero-padded approach.
   * 
   * The value of the field will be output during a format.
   * If the value cannot be obtained then an exception will be thrown.
   * 
   * The value will be zero-padded on the left. If the size of the value
   * means that it cannot be printed within the width then an exception is thrown.
   * If the value of the field is negative then an exception is thrown during formatting.
   * 
   * This method supports a special technique of parsing known as 'adjacent value parsing'.
   * This technique solves the problem where a value, variable or fixed width, is followed by one or more
   * fixed length values. The standard parser is greedy, and thus it would normally
   * steal the digits that are needed by the fixed width value parsers that follow the
   * variable width one.
   * 
   * No action is required to initiate 'adjacent value parsing'.
   * When a call to `appendValue` is made, the builder
   * enters adjacent value parsing setup mode. If the immediately subsequent method
   * call or calls on the same builder are for a fixed width value, then the parser will reserve
   * space so that the fixed width values can be parsed.
   * 
   * For example, consider `builder.appendValue(YEAR).appendValue(MONTH_OF_YEAR, 2);`
   * The year is a variable width parse of between 1 and 19 digits.
   * The month is a fixed width parse of 2 digits.
   * Because these were appended to the same builder immediately after one another,
   * the year parser will reserve two digits for the month to parse.
   * Thus, the text '201106' will correctly parse to a year of 2011 and a month of 6.
   * Without adjacent value parsing, the year would greedily parse all six digits and leave
   * nothing for the month.
   * 
   * Adjacent value parsing applies to each set of fixed width not-negative values in the parser
   * that immediately follow any kind of value, variable or fixed width.
   * Calling any other append method will end the setup of adjacent value parsing.
   * Thus, in the unlikely event that you need to avoid adjacent value parsing behavior,
   * simply add the `appendValue` to another `DateTimeFormatterBuilder`
   * and add that to this builder.
   * 
   * If adjacent parsing is active, then parsing must match exactly the specified
   * number of digits in both strict and lenient modes.
   * In addition, no positive or negative sign is permitted.
   *
   * @param field  the field to append, not null
   * @param width  the width of the printed field, from 1 to 19
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the width is invalid
  */
  appendValue(field: TemporalField, width: number): DateTimeFormatterBuilder;
  /**
   * Appends the value of a date-time field to the formatter providing full
   * control over formatting.
   * 
   * The value of the field will be output during a format.
   * If the value cannot be obtained then an exception will be thrown.
   * 
   * This method provides full control of the numeric formatting, including
   * zero-padding and the positive/negative sign.
   * 
   * The parser for a variable width value such as this normally behaves greedily,
   * accepting as many digits as possible.
   * This behavior can be affected by 'adjacent value parsing'.
   * See {@link #appendValue(java.time.temporal.TemporalField, int)} for full details.
   * 
   * In strict parsing mode, the minimum number of parsed digits is `minWidth`
   * and the maximum is `maxWidth`.
   * In lenient parsing mode, the minimum number of parsed digits is one
   * and the maximum is 19 (except as limited by adjacent value parsing).
   * 
   * If this method is invoked with equal minimum and maximum widths and a sign style of
   * `NOT_NEGATIVE` then it delegates to `appendValue(TemporalField,int)`.
   * In this scenario, the formatting and parsing behavior described there occur.
   *
   * @param field  the field to append, not null
   * @param minWidth  the minimum field width of the printed field, from 1 to 19
   * @param maxWidth  the maximum field width of the printed field, from 1 to 19
   * @param signStyle  the positive/negative output style, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the widths are invalid
  */
  appendValue(field: TemporalField, minWidth: number, maxWidth: number, signStyle: SignStyle): DateTimeFormatterBuilder;
  /**
   * Appends the reduced value of a date-time field to the formatter.
   * 
   * Since fields such as year vary by chronology, it is recommended to use the
   * {@link #appendValueReduced(TemporalField, int, int, ChronoLocalDate)} date}
   * variant of this method in most cases. This variant is suitable for
   * simple fields or working with only the ISO chronology.
   * 
   * For formatting, the `width` and `maxWidth` are used to
   * determine the number of characters to format.
   * If they are equal then the format is fixed width.
   * If the value of the field is within the range of the `baseValue` using
   * `width` characters then the reduced value is formatted otherwise the value is
   * truncated to fit `maxWidth`.
   * The rightmost characters are output to match the width, left padding with zero.
   * 
   * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.
   * For lenient parsing, the number of characters must be at least 1 and less than 10.
   * If the number of digits parsed is equal to `width` and the value is positive,
   * the value of the field is computed to be the first number greater than
   * or equal to the `baseValue` with the same least significant characters,
   * otherwise the value parsed is the field value.
   * This allows a reduced value to be entered for values in range of the baseValue
   * and width and absolute values can be entered for values outside the range.
   * 
   * For example, a base value of `1980` and a width of `2` will have
   * valid values from `1980` to `2079`.
   * During parsing, the text `"12"` will result in the value `2012` as that
   * is the value within the range where the last two characters are "12".
   * By contrast, parsing the text `"1915"` will result in the value `1915`.
   *
   * @param field  the field to append, not null
   * @param width  the field width of the printed and parsed field, from 1 to 10
   * @param maxWidth  the maximum field width of the printed field, from 1 to 10
   * @param baseValue  the base value of the range of valid values
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the width or base value is invalid
  */
  appendValueReduced(field: TemporalField, width: number, maxWidth: number, baseValue: number): DateTimeFormatterBuilder;
  /**
   * Appends the reduced value of a date-time field to the formatter.
   * 
   * This is typically used for formatting and parsing a two digit year.
   * 
   * The base date is used to calculate the full value during parsing.
   * For example, if the base date is 1950-01-01 then parsed values for
   * a two digit year parse will be in the range 1950-01-01 to 2049-12-31.
   * Only the year would be extracted from the date, thus a base date of
   * 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31.
   * This behavior is necessary to support fields such as week-based-year
   * or other calendar systems where the parsed value does not align with
   * standard ISO years.
   * 
   * The exact behavior is as follows. Parse the full set of fields and
   * determine the effective chronology using the last chronology if
   * it appears more than once. Then convert the base date to the
   * effective chronology. Then extract the specified field from the
   * chronology-specific base date and use it to determine the
   * `baseValue` used below.
   * 
   * For formatting, the `width` and `maxWidth` are used to
   * determine the number of characters to format.
   * If they are equal then the format is fixed width.
   * If the value of the field is within the range of the `baseValue` using
   * `width` characters then the reduced value is formatted otherwise the value is
   * truncated to fit `maxWidth`.
   * The rightmost characters are output to match the width, left padding with zero.
   * 
   * For strict parsing, the number of characters allowed by `width` to `maxWidth` are parsed.
   * For lenient parsing, the number of characters must be at least 1 and less than 10.
   * If the number of digits parsed is equal to `width` and the value is positive,
   * the value of the field is computed to be the first number greater than
   * or equal to the `baseValue` with the same least significant characters,
   * otherwise the value parsed is the field value.
   * This allows a reduced value to be entered for values in range of the baseValue
   * and width and absolute values can be entered for values outside the range.
   * 
   * For example, a base value of `1980` and a width of `2` will have
   * valid values from `1980` to `2079`.
   * During parsing, the text `"12"` will result in the value `2012` as that
   * is the value within the range where the last two characters are "12".
   * By contrast, parsing the text `"1915"` will result in the value `1915`.
   *
   * @param field  the field to append, not null
   * @param width  the field width of the printed and parsed field, from 1 to 10
   * @param maxWidth  the maximum field width of the printed field, from 1 to 10
   * @param baseDate  the base date used to calculate the base value for the range
   *  of valid values in the parsed chronology, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the width or base value is invalid
  */
  appendValueReduced(field: TemporalField, width: number, maxWidth: number, baseDate: ChronoLocalDate): DateTimeFormatterBuilder;
  /**
   * Appends the fractional value of a date-time field to the formatter.
   * 
   * The fractional value of the field will be output including the
   * preceding decimal point. The preceding value is not output.
   * For example, the second-of-minute value of 15 would be output as `.25`.
   * 
   * The width of the printed fraction can be controlled. Setting the
   * minimum width to zero will cause no output to be generated.
   * The printed fraction will have the minimum width necessary between
   * the minimum and maximum widths - trailing zeroes are omitted.
   * No rounding occurs due to the maximum width - digits are simply dropped.
   * 
   * When parsing in strict mode, the number of parsed digits must be between
   * the minimum and maximum width. In strict mode, if the minimum and maximum widths
   * are equal and there is no decimal point then the parser will
   * participate in adjacent value parsing, see
   * {@link #appendValue(java.time.temporal.TemporalField, int)}. When parsing in lenient mode,
   * the minimum width is considered to be zero and the maximum is nine.
   * 
   * If the value cannot be obtained then an exception will be thrown.
   * If the value is negative an exception will be thrown.
   * If the field does not have a fixed set of valid values then an
   * exception will be thrown.
   * If the field value in the date-time to be printed is outside the
   * range of valid values then an exception will be thrown.
   *
   * @param field  the field to append, not null
   * @param minWidth  the minimum width of the field excluding the decimal point, from 0 to 9
   * @param maxWidth  the maximum width of the field excluding the decimal point, from 1 to 9
   * @param decimalPoint  whether to output the localized decimal point symbol
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the field has a variable set of valid values or
   *  either width is invalid
  */
  appendFraction(field: TemporalField, minWidth: number, maxWidth: number, decimalPoint: boolean): DateTimeFormatterBuilder;
  /**
   * Appends the text of a date-time field to the formatter using the full
   * text style.
   * 
   * The text of the field will be output during a format.
   * The value must be within the valid range of the field.
   * If the value cannot be obtained then an exception will be thrown.
   * If the field has no textual representation, then the numeric value will be used.
   * 
   * The value will be printed as per the normal format of an integer value.
   * Only negative numbers will be signed. No padding will be added.
   *
   * @param field  the field to append, not null
   * @return this, for chaining, not null
  */
  appendText(field: TemporalField): DateTimeFormatterBuilder;
  /**
   * Appends the text of a date-time field to the formatter.
   * 
   * The text of the field will be output during a format.
   * The value must be within the valid range of the field.
   * If the value cannot be obtained then an exception will be thrown.
   * If the field has no textual representation, then the numeric value will be used.
   * 
   * The value will be printed as per the normal format of an integer value.
   * Only negative numbers will be signed. No padding will be added.
   *
   * @param field  the field to append, not null
   * @param textStyle  the text style to use, not null
   * @return this, for chaining, not null
  */
  appendText(field: TemporalField, textStyle: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends the text of a date-time field to the formatter using the specified
   * map to supply the text.
   * 
   * The standard text outputting methods use the localized text in the JDK.
   * This method allows that text to be specified directly.
   * The supplied map is not validated by the builder to ensure that formatting or
   * parsing is possible, thus an invalid map may throw an error during later use.
   * 
   * Supplying the map of text provides considerable flexibility in formatting and parsing.
   * For example, a legacy application might require or supply the months of the
   * year as "JNY", "FBY", "MCH" etc. These do not match the standard set of text
   * for localized month names. Using this method, a map can be created which
   * defines the connection between each value and the text:
   *      * Map<Long, String> map = new HashMap<>();
   * map.put(1L, "JNY");
   * map.put(2L, "FBY");
   * map.put(3L, "MCH");
   * ...
   * builder.appendText(MONTH_OF_YEAR, map);
   * 
   * 
   * Other uses might be to output the value with a suffix, such as "1st", "2nd", "3rd",
   * or as Roman numerals "I", "II", "III", "IV".
   * 
   * During formatting, the value is obtained and checked that it is in the valid range.
   * If text is not available for the value then it is output as a number.
   * During parsing, the parser will match against the map of text and numeric values.
   *
   * @param field  the field to append, not null
   * @param textLookup  the map from the value to the text
   * @return this, for chaining, not null
  */
  appendText(field: TemporalField, textLookup: Map<number,string>): DateTimeFormatterBuilder;
  /**
   * Appends an instant using ISO-8601 to the formatter, formatting fractional
   * digits in groups of three.
   * 
   * Instants have a fixed output format.
   * They are converted to a date-time with a zone-offset of UTC and formatted
   * using the standard ISO-8601 format.
   * With this method, formatting nano-of-second outputs zero, three, six
   * or nine digits as necessary.
   * The localized decimal style is not used.
   * 
   * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
   * and optionally `NANO_OF_SECOND`. The value of `INSTANT_SECONDS`
   * may be outside the maximum range of `LocalDateTime`.
   * 
   * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
   * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
   * The leap-second time of '23:59:59' is handled to some degree, see
   * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
   * 
   * When formatting, the instant will always be suffixed by 'Z' to indicate UTC.
   * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}
   * will be used to parse the offset, converting the instant to UTC as necessary.
   * 
   * An alternative to this method is to format/parse the instant as a single
   * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.
   *
   * @return this, for chaining, not null
  */
  appendInstant(): DateTimeFormatterBuilder;
  /**
   * Appends an instant using ISO-8601 to the formatter with control over
   * the number of fractional digits.
   * 
   * Instants have a fixed output format, although this method provides some
   * control over the fractional digits. They are converted to a date-time
   * with a zone-offset of UTC and printed using the standard ISO-8601 format.
   * The localized decimal style is not used.
   * 
   * The `fractionalDigits` parameter allows the output of the fractional
   * second to be controlled. Specifying zero will cause no fractional digits
   * to be output. From 1 to 9 will output an increasing number of digits, using
   * zero right-padding if necessary. The special value -1 is used to output as
   * many digits as necessary to avoid any trailing zeroes.
   * 
   * When parsing in strict mode, the number of parsed digits must match the
   * fractional digits. When parsing in lenient mode, any number of fractional
   * digits from zero to nine are accepted.
   * 
   * The instant is obtained using {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS}
   * and optionally `NANO_OF_SECOND`. The value of `INSTANT_SECONDS`
   * may be outside the maximum range of `LocalDateTime`.
   * 
   * The {@linkplain ResolverStyle resolver style} has no effect on instant parsing.
   * The end-of-day time of '24:00' is handled as midnight at the start of the following day.
   * The leap-second time of '23:59:60' is handled to some degree, see
   * {@link DateTimeFormatter#parsedLeapSecond()} for full details.
   * 
   * An alternative to this method is to format/parse the instant as a single
   * epoch-seconds value. That is achieved using `appendValue(INSTANT_SECONDS)`.
   *
   * @param fractionalDigits  the number of fractional second digits to format with,
   *  from 0 to 9, or -1 to use as many digits as necessary
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the number of fractional digits is invalid
  */
  appendInstant(fractionalDigits: number): DateTimeFormatterBuilder;
  /**
   * Appends the zone offset, such as '+01:00', to the formatter.
   * 
   * This appends an instruction to format/parse the offset ID to the builder.
   * This is equivalent to calling `appendOffset("+HH:mm:ss", "Z")`.
   * See {@link #appendOffset(String, String)} for details on formatting
   * and parsing.
   *
   * @return this, for chaining, not null
  */
  appendOffsetId(): DateTimeFormatterBuilder;
  /**
   * Appends the zone offset, such as '+01:00', to the formatter.
   * 
   * This appends an instruction to format/parse the offset ID to the builder.
   * 
   * During formatting, the offset is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#offset()}.
   * It will be printed using the format defined below.
   * If the offset cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * When parsing in strict mode, the input must contain the mandatory
   * and optional elements are defined by the specified pattern.
   * If the offset cannot be parsed then an exception is thrown unless
   * the section of the formatter is optional.
   * 
   * When parsing in lenient mode, only the hours are mandatory - minutes
   * and seconds are optional. The colons are required if the specified
   * pattern contains a colon. If the specified pattern is "+HH", the
   * presence of colons is determined by whether the character after the
   * hour digits is a colon or not.
   * If the offset cannot be parsed then an exception is thrown unless
   * the section of the formatter is optional.
   * 
   * The format of the offset is controlled by a pattern which must be one
   * of the following:
   * 
   * `+HH` - hour only, ignoring minute and second
   * `+HHmm` - hour, with minute if non-zero, ignoring second, no colon
   * `+HH:mm` - hour, with minute if non-zero, ignoring second, with colon
   * `+HHMM` - hour and minute, ignoring second, no colon
   * `+HH:MM` - hour and minute, ignoring second, with colon
   * `+HHMMss` - hour and minute, with second if non-zero, no colon
   * `+HH:MM:ss` - hour and minute, with second if non-zero, with colon
   * `+HHMMSS` - hour, minute and second, no colon
   * `+HH:MM:SS` - hour, minute and second, with colon
   * `+HHmmss` - hour, with minute if non-zero or with minute and
   * second if non-zero, no colon
   * `+HH:mm:ss` - hour, with minute if non-zero or with minute and
   * second if non-zero, with colon
   * `+H` - hour only, ignoring minute and second
   * `+Hmm` - hour, with minute if non-zero, ignoring second, no colon
   * `+H:mm` - hour, with minute if non-zero, ignoring second, with colon
   * `+HMM` - hour and minute, ignoring second, no colon
   * `+H:MM` - hour and minute, ignoring second, with colon
   * `+HMMss` - hour and minute, with second if non-zero, no colon
   * `+H:MM:ss` - hour and minute, with second if non-zero, with colon
   * `+HMMSS` - hour, minute and second, no colon
   * `+H:MM:SS` - hour, minute and second, with colon
   * `+Hmmss` - hour, with minute if non-zero or with minute and
   * second if non-zero, no colon
   * `+H:mm:ss` - hour, with minute if non-zero or with minute and
   * second if non-zero, with colon
   * 
   * Patterns containing "HH" will format and parse a two digit hour,
   * zero-padded if necessary. Patterns containing "H" will format with no
   * zero-padding, and parse either one or two digits.
   * In lenient mode, the parser will be greedy and parse the maximum digits possible.
   * The "no offset" text controls what text is printed when the total amount of
   * the offset fields to be output is zero.
   * Example values would be 'Z', '+00:00', 'UTC' or 'GMT'.
   * Three formats are accepted for parsing UTC - the "no offset" text, and the
   * plus and minus versions of zero defined by the pattern.
   *
   * @param pattern  the pattern to use, not null
   * @param noOffsetText  the text to use when the offset is zero, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the pattern is invalid
  */
  appendOffset(pattern: string, noOffsetText: string): DateTimeFormatterBuilder;
  /**
   * Appends the localized zone offset, such as 'GMT+01:00', to the formatter.
   * 
   * This appends a localized zone offset to the builder, the format of the
   * localized offset is controlled by the specified {@link FormatStyle style}
   * to this method:
   * 
   * {@link TextStyle#FULL full} - formats with localized offset text, such
   * as 'GMT, 2-digit hour and minute field, optional second field if non-zero,
   * and colon.
   * {@link TextStyle#SHORT short} - formats with localized offset text,
   * such as 'GMT, hour without leading zero, optional 2-digit minute and
   * second if non-zero, and colon.
   * 
   * 
   * During formatting, the offset is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#offset()}.
   * If the offset cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, the offset is parsed using the format defined above.
   * If the offset cannot be parsed then an exception is thrown unless the
   * section of the formatter is optional.
   *
   * @param style  the format style to use, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if style is neither {@link TextStyle#FULL
   * full} nor {@link TextStyle#SHORT short}
  */
  appendLocalizedOffset(style: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to the formatter.
   * 
   * This appends an instruction to format/parse the zone ID to the builder.
   * The zone ID is obtained in a strict manner suitable for `ZonedDateTime`.
   * By contrast, `OffsetDateTime` does not have a zone ID suitable
   * for use with this method, see {@link #appendZoneOrOffsetId()}.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zoneId()}.
   * It will be printed using the result of {@link ZoneId#getId()}.
   * If the zone cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, the text must match a known zone or offset.
   * There are two types of zone ID, offset-based, such as '+01:30' and
   * region-based, such as 'Europe/London'. These are parsed differently.
   * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
   * expects an offset-based zone and will not match region-based zones.
   * The offset ID, such as '+02:30', may be at the start of the parse,
   * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
   * equivalent to using {@link #appendOffset(String, String)} using the
   * arguments 'HH:MM:ss' and the no offset string '0'.
   * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
   * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
   * In all other cases, the list of known region-based zones is used to
   * find the longest available match. If no match is found, and the parse
   * starts with 'Z', then `ZoneOffset.UTC` is selected.
   * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
   * 
   * For example, the following will parse:
   *      *   "Europe/London"           -- ZoneId.of("Europe/London")
   *   "Z"                       -- ZoneOffset.UTC
   *   "UT"                      -- ZoneId.of("UT")
   *   "UTC"                     -- ZoneId.of("UTC")
   *   "GMT"                     -- ZoneId.of("GMT")
   *   "+01:30"                  -- ZoneOffset.of("+01:30")
   *   "UT+01:30"                -- ZoneOffset.of("+01:30")
   *   "UTC+01:30"               -- ZoneOffset.of("+01:30")
   *   "GMT+01:30"               -- ZoneOffset.of("+01:30")
   * 
   *
   * @return this, for chaining, not null
   * @see #appendZoneRegionId()
  */
  appendZoneId(): DateTimeFormatterBuilder;
  /**
   * Appends the time-zone region ID, such as 'Europe/Paris', to the formatter,
   * rejecting the zone ID if it is a `ZoneOffset`.
   * 
   * This appends an instruction to format/parse the zone ID to the builder
   * only if it is a region-based ID.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zoneId()}.
   * If the zone is a `ZoneOffset` or it cannot be obtained then
   * an exception is thrown unless the section of the formatter is optional.
   * If the zone is not an offset, then the zone will be printed using
   * the zone ID from {@link ZoneId#getId()}.
   * 
   * During parsing, the text must match a known zone or offset.
   * There are two types of zone ID, offset-based, such as '+01:30' and
   * region-based, such as 'Europe/London'. These are parsed differently.
   * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
   * expects an offset-based zone and will not match region-based zones.
   * The offset ID, such as '+02:30', may be at the start of the parse,
   * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
   * equivalent to using {@link #appendOffset(String, String)} using the
   * arguments 'HH:MM:ss' and the no offset string '0'.
   * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
   * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
   * In all other cases, the list of known region-based zones is used to
   * find the longest available match. If no match is found, and the parse
   * starts with 'Z', then `ZoneOffset.UTC` is selected.
   * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
   * 
   * For example, the following will parse:
   *      *   "Europe/London"           -- ZoneId.of("Europe/London")
   *   "Z"                       -- ZoneOffset.UTC
   *   "UT"                      -- ZoneId.of("UT")
   *   "UTC"                     -- ZoneId.of("UTC")
   *   "GMT"                     -- ZoneId.of("GMT")
   *   "+01:30"                  -- ZoneOffset.of("+01:30")
   *   "UT+01:30"                -- ZoneOffset.of("+01:30")
   *   "UTC+01:30"               -- ZoneOffset.of("+01:30")
   *   "GMT+01:30"               -- ZoneOffset.of("+01:30")
   * 
   * 
   * Note that this method is identical to `appendZoneId()` except
   * in the mechanism used to obtain the zone.
   * Note also that parsing accepts offsets, whereas formatting will never
   * produce one.
   *
   * @return this, for chaining, not null
   * @see #appendZoneId()
  */
  appendZoneRegionId(): DateTimeFormatterBuilder;
  /**
   * Appends the time-zone ID, such as 'Europe/Paris' or '+02:00', to
   * the formatter, using the best available zone ID.
   * 
   * This appends an instruction to format/parse the best available
   * zone or offset ID to the builder.
   * The zone ID is obtained in a lenient manner that first attempts to
   * find a true zone ID, such as that on `ZonedDateTime`, and
   * then attempts to find an offset, such as that on `OffsetDateTime`.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zone()}.
   * It will be printed using the result of {@link ZoneId#getId()}.
   * If the zone cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, the text must match a known zone or offset.
   * There are two types of zone ID, offset-based, such as '+01:30' and
   * region-based, such as 'Europe/London'. These are parsed differently.
   * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser
   * expects an offset-based zone and will not match region-based zones.
   * The offset ID, such as '+02:30', may be at the start of the parse,
   * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is
   * equivalent to using {@link #appendOffset(String, String)} using the
   * arguments 'HH:MM:ss' and the no offset string '0'.
   * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot
   * match a following offset ID, then {@link ZoneOffset#UTC} is selected.
   * In all other cases, the list of known region-based zones is used to
   * find the longest available match. If no match is found, and the parse
   * starts with 'Z', then `ZoneOffset.UTC` is selected.
   * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
   * 
   * For example, the following will parse:
   *      *   "Europe/London"           -- ZoneId.of("Europe/London")
   *   "Z"                       -- ZoneOffset.UTC
   *   "UT"                      -- ZoneId.of("UT")
   *   "UTC"                     -- ZoneId.of("UTC")
   *   "GMT"                     -- ZoneId.of("GMT")
   *   "+01:30"                  -- ZoneOffset.of("+01:30")
   *   "UT+01:30"                -- ZoneOffset.of("UT+01:30")
   *   "UTC+01:30"               -- ZoneOffset.of("UTC+01:30")
   *   "GMT+01:30"               -- ZoneOffset.of("GMT+01:30")
   * 
   * 
   * Note that this method is identical to `appendZoneId()` except
   * in the mechanism used to obtain the zone.
   *
   * @return this, for chaining, not null
   * @see #appendZoneId()
  */
  appendZoneOrOffsetId(): DateTimeFormatterBuilder;
  /**
   * Appends the time-zone name, such as 'British Summer Time', to the formatter.
   * 
   * This appends an instruction to format/parse the textual name of the zone to
   * the builder.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zoneId()}.
   * If the zone is a `ZoneOffset` it will be printed using the
   * result of {@link ZoneOffset#getId()}.
   * If the zone is not an offset, the textual name will be looked up
   * for the locale set in the {@link DateTimeFormatter}.
   * If the temporal object being printed represents an instant, or if it is a
   * local date-time that is not in a daylight saving gap or overlap then
   * the text will be the summer or winter time text as appropriate.
   * If the lookup for text does not find any suitable result, then the
   * {@link ZoneId#getId() ID} will be printed.
   * If the zone cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, either the textual zone name, the zone ID or the offset
   * is accepted. Many textual zone names are not unique, such as CST can be
   * for both "Central Standard Time" and "China Standard Time". In this
   * situation, the zone id will be determined by the region information from
   * formatter's  {@link DateTimeFormatter#getLocale() locale} and the standard
   * zone id for that area, for example, America/New_York for the America Eastern
   * zone. The {@link #appendZoneText(TextStyle, Set)} may be used
   * to specify a set of preferred {@link ZoneId} in this situation.
   *
   * @param textStyle  the text style to use, not null
   * @return this, for chaining, not null
  */
  appendZoneText(textStyle: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends the time-zone name, such as 'British Summer Time', to the formatter.
   * 
   * This appends an instruction to format/parse the textual name of the zone to
   * the builder.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zoneId()}.
   * If the zone is a `ZoneOffset` it will be printed using the
   * result of {@link ZoneOffset#getId()}.
   * If the zone is not an offset, the textual name will be looked up
   * for the locale set in the {@link DateTimeFormatter}.
   * If the temporal object being printed represents an instant, or if it is a
   * local date-time that is not in a daylight saving gap or overlap, then the text
   * will be the summer or winter time text as appropriate.
   * If the lookup for text does not find any suitable result, then the
   * {@link ZoneId#getId() ID} will be printed.
   * If the zone cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, either the textual zone name, the zone ID or the offset
   * is accepted. Many textual zone names are not unique, such as CST can be
   * for both "Central Standard Time" and "China Standard Time". In this
   * situation, the zone id will be determined by the region information from
   * formatter's  {@link DateTimeFormatter#getLocale() locale} and the standard
   * zone id for that area, for example, America/New_York for the America Eastern
   * zone. This method also allows a set of preferred {@link ZoneId} to be
   * specified for parsing. The matched preferred zone id will be used if the
   * textural zone name being parsed is not unique.
   * 
   * If the zone cannot be parsed then an exception is thrown unless the
   * section of the formatter is optional.
   *
   * @param textStyle  the text style to use, not null
   * @param preferredZones  the set of preferred zone ids, not null
   * @return this, for chaining, not null
  */
  appendZoneText(textStyle: TextStyle, preferredZones: Set<ZoneId>): DateTimeFormatterBuilder;
  /**
   * Appends the generic time-zone name, such as 'Pacific Time', to the formatter.
   * 
   * This appends an instruction to format/parse the generic textual
   * name of the zone to the builder. The generic name is the same throughout the whole
   * year, ignoring any daylight saving changes. For example, 'Pacific Time' is the
   * generic name, whereas 'Pacific Standard Time' and 'Pacific Daylight Time' are the
   * specific names, see {@link #appendZoneText(TextStyle)}.
   * 
   * During formatting, the zone is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#zoneId()}.
   * If the zone is a `ZoneOffset` it will be printed using the
   * result of {@link ZoneOffset#getId()}.
   * If the zone is not an offset, the textual name will be looked up
   * for the locale set in the {@link DateTimeFormatter}.
   * If the lookup for text does not find any suitable result, then the
   * {@link ZoneId#getId() ID} will be printed.
   * If the zone cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, either the textual zone name, the zone ID or the offset
   * is accepted. Many textual zone names are not unique, such as CST can be
   * for both "Central Standard Time" and "China Standard Time". In this
   * situation, the zone id will be determined by the region information from
   * formatter's  {@link DateTimeFormatter#getLocale() locale} and the standard
   * zone id for that area, for example, America/New_York for the America Eastern zone.
   * The {@link #appendGenericZoneText(TextStyle, Set)} may be used
   * to specify a set of preferred {@link ZoneId} in this situation.
   *
   * @param textStyle  the text style to use, not null
   * @return this, for chaining, not null
   * @since 9
  */
  appendGenericZoneText(textStyle: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends the generic time-zone name, such as 'Pacific Time', to the formatter.
   * 
   * This appends an instruction to format/parse the generic textual
   * name of the zone to the builder. The generic name is the same throughout the whole
   * year, ignoring any daylight saving changes. For example, 'Pacific Time' is the
   * generic name, whereas 'Pacific Standard Time' and 'Pacific Daylight Time' are the
   * specific names, see {@link #appendZoneText(TextStyle)}.
   * 
   * This method also allows a set of preferred {@link ZoneId} to be
   * specified for parsing. The matched preferred zone id will be used if the
   * textural zone name being parsed is not unique.
   * 
   * See {@link #appendGenericZoneText(TextStyle)} for details about
   * formatting and parsing.
   *
   * @param textStyle  the text style to use, not null
   * @param preferredZones  the set of preferred zone ids, not null
   * @return this, for chaining, not null
   * @since 9
  */
  appendGenericZoneText(textStyle: TextStyle, preferredZones: Set<ZoneId>): DateTimeFormatterBuilder;
  /**
   * Appends the chronology ID, such as 'ISO' or 'ThaiBuddhist', to the formatter.
   * 
   * This appends an instruction to format/parse the chronology ID to the builder.
   * 
   * During formatting, the chronology is obtained using a mechanism equivalent
   * to querying the temporal with {@link TemporalQueries#chronology()}.
   * It will be printed using the result of {@link Chronology#getId()}.
   * If the chronology cannot be obtained then an exception is thrown unless the
   * section of the formatter is optional.
   * 
   * During parsing, the chronology is parsed and must match one of the chronologies
   * in {@link Chronology#getAvailableChronologies()}.
   * If the chronology cannot be parsed then an exception is thrown unless the
   * section of the formatter is optional.
   * The parser uses the {@linkplain #parseCaseInsensitive() case sensitive} setting.
   *
   * @return this, for chaining, not null
  */
  appendChronologyId(): DateTimeFormatterBuilder;
  /**
   * Appends the chronology name to the formatter.
   * 
   * The calendar system name will be output during a format.
   * If the chronology cannot be obtained then an exception will be thrown.
   *
   * @param textStyle  the text style to use, not null
   * @return this, for chaining, not null
  */
  appendChronologyText(textStyle: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends a localized date-time pattern to the formatter.
   * 
   * This appends a localized section to the builder, suitable for outputting
   * a date, time or date-time combination. The format of the localized
   * section is lazily looked up based on four items:
   * 
   * the `dateStyle` specified to this method
   * the `timeStyle` specified to this method
   * the `Locale` of the `DateTimeFormatter`
   * the `Chronology`, selecting the best available
   * 
   * During formatting, the chronology is obtained from the temporal object
   * being formatted, which may have been overridden by
   * {@link DateTimeFormatter#withChronology(Chronology)}.
   * The `FULL` and `LONG` styles typically require a time-zone.
   * When formatting using these styles, a `ZoneId` must be available,
   * either by using `ZonedDateTime` or {@link DateTimeFormatter#withZone}.
   * 
   * During parsing, if a chronology has already been parsed, then it is used.
   * Otherwise the default from `DateTimeFormatter.withChronology(Chronology)`
   * is used, with `IsoChronology` as the fallback.
   * 
   * Note that this method provides similar functionality to methods on
   * `DateFormat` such as {@link java.text.DateFormat#getDateTimeInstance(int, int)}.
   *
   * @param dateStyle  the date style to use, null means no date required
   * @param timeStyle  the time style to use, null means no time required
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if both the date and time styles are null
  */
  appendLocalized(dateStyle: FormatStyle, timeStyle: FormatStyle): DateTimeFormatterBuilder;
  /**
   * Appends a localized pattern to the formatter using the requested template.
   * 
   * This appends a localized section to the builder, suitable for outputting
   * a date, time or date-time combination. The format of the localized
   * section is lazily looked up based on three items:
   * 
   * the `requestedTemplate` specified to this method
   * the `Locale` of the `DateTimeFormatter`
   * the `Chronology` of the `DateTimeFormatter` unless overridden
   * 
   * During formatting, the chronology is obtained from the temporal object
   * being formatted, which may have been overridden by
   * {@link DateTimeFormatter#withChronology(Chronology)}.
   * 
   * During parsing, if a chronology has already been parsed, then it is used.
   * Otherwise the default from `DateTimeFormatter.withChronology(Chronology)`
   * is used, with `IsoChronology` as the fallback.
   * 
   * The requested template is a series of typical pattern
   * symbols in canonical order from the largest date or time unit to the smallest,
   * which can be expressed with the following regular expression:
   * {@snippet :
   *      "G{0,5}" +        // Era
   *      "y*" +            // Year
   *      "Q{0,5}" +        // Quarter
   *      "M{0,5}" +        // Month
   *      "w*" +            // Week of Week Based Year
   *      "E{0,5}" +        // Day of Week
   *      "d{0,2}" +        // Day of Month
   *      "B{0,5}" +        // Period/AmPm of Day
   *      "[hHjC]{0,2}" +   // Hour of Day/AmPm (refer to LDML for 'j' and 'C')
   *      "m{0,2}" +        // Minute of Hour
   *      "s{0,2}" +        // Second of Minute
   *      "[vz]{0,4}"       // Zone
   * }
   * All pattern symbols are optional, and each pattern symbol represents a field,
   * for example, 'M' represents the Month field. The number of the pattern symbol letters follows the
   * same presentation, such as "number" or "text" as in the
   * Patterns for Formatting and Parsing section.
   * Other pattern symbols in the requested template are invalid.
   * 
   * The mapping of the requested template to the closest of the available localized formats
   * is defined by the
   * 
   * Unicode LDML specification. For example, the formatter created from the requested template
   * `yMMM` will format the date '2020-06-16' to 'Jun 2020' in the {@link Locale#US US locale}.
   *
   * @param requestedTemplate the requested template to use, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if `requestedTemplate` is invalid
   *
   * @spec https://www.unicode.org/reports/tr35 Unicode Locale Data Markup Language (LDML)
   * @see #appendPattern(String)
   * @since 19
  */
  appendLocalized(requestedTemplate: string): DateTimeFormatterBuilder;
  /**
   * Appends a character literal to the formatter.
   * 
   * This character will be output during a format.
   *
   * @param literal  the literal to append, not null
   * @return this, for chaining, not null
  */
  appendLiteral(literal: string): DateTimeFormatterBuilder;
  /**
   * Appends the day period text to the formatter.
   * 
   * This appends an instruction to format/parse the textual name of the day period
   * to the builder. Day periods are defined in LDML's
   * "day periods"
   *  element.
   * 
   * During formatting, the day period is obtained from `HOUR_OF_DAY`, and
   * optionally `MINUTE_OF_HOUR` if exist. It will be mapped to a day period
   * type defined in LDML, such as "morning1" and then it will be translated into
   * text. Mapping to a day period type and its translation both depend on the
   * locale in the formatter.
   * 
   * During parsing, the text will be parsed into a day period type first. Then
   * the parsed day period is combined with other fields to make a `LocalTime` in
   * the resolving phase. If the `HOUR_OF_AMPM` field is present, it is combined
   * with the day period to make `HOUR_OF_DAY` taking into account any
   * `MINUTE_OF_HOUR` value. If `HOUR_OF_DAY` is present, it is validated
   * against the day period taking into account any `MINUTE_OF_HOUR` value. If a
   * day period is present without `HOUR_OF_DAY`, `MINUTE_OF_HOUR`,
   * `SECOND_OF_MINUTE` and `NANO_OF_SECOND` then the midpoint of the
   * day period is set as the time in `SMART` and `LENIENT` mode.
   * For example, if the parsed day period type is "night1" and the period defined
   * for it in the formatter locale is from 21:00 to 06:00, then it results in
   * the `LocalTime` of 01:30.
   * If the resolved time conflicts with the day period, `DateTimeException` is
   * thrown in `STRICT` and `SMART` mode. In `LENIENT` mode, no
   * exception is thrown and the parsed day period is ignored.
   * 
   * The "midnight" type allows both "00:00" as the start-of-day and "24:00" as the
   * end-of-day, as long as they are valid with the resolved hour field.
   *
   * @param style the text style to use, not null
   * @return this, for chaining, not null
   *
   * @spec https://www.unicode.org/reports/tr35 Unicode Locale Data Markup Language (LDML)
   * @since 16
  */
  appendDayPeriodText(style: TextStyle): DateTimeFormatterBuilder;
  /**
   * Appends all the elements of a formatter to the builder.
   * 
   * This method has the same effect as appending each of the constituent
   * parts of the formatter directly to this builder.
   *
   * @param formatter  the formatter to add, not null
   * @return this, for chaining, not null
  */
  append(formatter: DateTimeFormatter): DateTimeFormatterBuilder;
  /**
   * Appends a formatter to the builder which will optionally format/parse.
   * 
   * This method has the same effect as appending each of the constituent
   * parts directly to this builder surrounded by an {@link #optionalStart()} and
   * {@link #optionalEnd()}.
   * 
   * The formatter will format if data is available for all the fields contained within it.
   * The formatter will parse if the string matches, otherwise no error is returned.
   *
   * @param formatter  the formatter to add, not null
   * @return this, for chaining, not null
  */
  appendOptional(formatter: DateTimeFormatter): DateTimeFormatterBuilder;
  /**
   * Appends the elements defined by the specified pattern to the builder.
   * 
   * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters.
   * The characters '#', '{' and '}' are reserved for future use.
   * The characters '[' and ']' indicate optional patterns.
   * The following pattern letters are defined:
   *      *  Symbol  Meaning                     Presentation      Examples
   *  ------  -------                     ------------      -------
   *   G       era                         text              AD; Anno Domini; A
   *   u       year                        year              2004; 04
   *   y       year-of-era                 year              2004; 04
   *   D       day-of-year                 number            189
   *   M/L     month-of-year               number/text       7; 07; Jul; July; J
   *   d       day-of-month                number            10
   *   g       modified-julian-day         number            2451334
   *
   *   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
   *   Y       week-based-year             year              1996; 96
   *   w       week-of-week-based-year     number            27
   *   W       week-of-month               number            4
   *   E       day-of-week                 text              Tue; Tuesday; T
   *   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
   *   F       day-of-week-in-month        number            3
   *
   *   a       am-pm-of-day                text              PM
   *   B       period-of-day               text              in the morning
   *   h       clock-hour-of-am-pm (1-12)  number            12
   *   K       hour-of-am-pm (0-11)        number            0
   *   k       clock-hour-of-day (1-24)    number            24
   *
   *   H       hour-of-day (0-23)          number            0
   *   m       minute-of-hour              number            30
   *   s       second-of-minute            number            55
   *   S       fraction-of-second          fraction          978
   *   A       milli-of-day                number            1234
   *   n       nano-of-second              number            987654321
   *   N       nano-of-day                 number            1234000000
   *
   *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
   *   v       generic time-zone name      zone-name         PT, Pacific Time
   *   z       time-zone name              zone-name         Pacific Standard Time; PST
   *   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00;
   *   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15
   *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15
   *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00
   *
   *   p       pad next                    pad modifier      1
   *
   *   '       escape for text             delimiter
   *   ''      single quote                literal           '
   *   [       optional section start
   *   ]       optional section end
   *   #       reserved for future use
   *   {       reserved for future use
   *   }       reserved for future use
   * 
   * 
   * The count of pattern letters determine the format.
   * See DateTimeFormatter for a user-focused description of the patterns.
   * The following tables define how the pattern letters map to the builder.
   * 
   * Date fields: Pattern letters to output a date.
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    G       1      appendText(ChronoField.ERA, TextStyle.SHORT)
   *    GG      2      appendText(ChronoField.ERA, TextStyle.SHORT)
   *    GGG     3      appendText(ChronoField.ERA, TextStyle.SHORT)
   *    GGGG    4      appendText(ChronoField.ERA, TextStyle.FULL)
   *    GGGGG   5      appendText(ChronoField.ERA, TextStyle.NARROW)
   *
   *    u       1      appendValue(ChronoField.YEAR, 1, 19, SignStyle.NORMAL)
   *    uu      2      appendValueReduced(ChronoField.YEAR, 2, 2, 2000)
   *    uuu     3      appendValue(ChronoField.YEAR, 3, 19, SignStyle.NORMAL)
   *    u..u    4..n   appendValue(ChronoField.YEAR, n, 19, SignStyle.EXCEEDS_PAD)
   *    y       1      appendValue(ChronoField.YEAR_OF_ERA, 1, 19, SignStyle.NORMAL)
   *    yy      2      appendValueReduced(ChronoField.YEAR_OF_ERA, 2, 2, 2000)
   *    yyy     3      appendValue(ChronoField.YEAR_OF_ERA, 3, 19, SignStyle.NORMAL)
   *    y..y    4..n   appendValue(ChronoField.YEAR_OF_ERA, n, 19, SignStyle.EXCEEDS_PAD)
   *    Y       1      append special localized WeekFields element for numeric week-based-year
   *    YY      2      append special localized WeekFields element for reduced numeric week-based-year 2 digits
   *    YYY     3      append special localized WeekFields element for numeric week-based-year (3, 19, SignStyle.NORMAL)
   *    Y..Y    4..n   append special localized WeekFields element for numeric week-based-year (n, 19, SignStyle.EXCEEDS_PAD)
   *
   *    Q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
   *    QQ      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)
   *    QQQ     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT)
   *    QQQQ    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL)
   *    QQQQQ   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW)
   *    q       1      appendValue(IsoFields.QUARTER_OF_YEAR)
   *    qq      2      appendValue(IsoFields.QUARTER_OF_YEAR, 2)
   *    qqq     3      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.SHORT_STANDALONE)
   *    qqqq    4      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.FULL_STANDALONE)
   *    qqqqq   5      appendText(IsoFields.QUARTER_OF_YEAR, TextStyle.NARROW_STANDALONE)
   *
   *    M       1      appendValue(ChronoField.MONTH_OF_YEAR)
   *    MM      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)
   *    MMM     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT)
   *    MMMM    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL)
   *    MMMMM   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW)
   *    L       1      appendValue(ChronoField.MONTH_OF_YEAR)
   *    LL      2      appendValue(ChronoField.MONTH_OF_YEAR, 2)
   *    LLL     3      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.SHORT_STANDALONE)
   *    LLLL    4      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.FULL_STANDALONE)
   *    LLLLL   5      appendText(ChronoField.MONTH_OF_YEAR, TextStyle.NARROW_STANDALONE)
   *
   *    w       1      append special localized WeekFields element for numeric week-of-year
   *    ww      2      append special localized WeekFields element for numeric week-of-year, zero-padded
   *    W       1      append special localized WeekFields element for numeric week-of-month
   *    d       1      appendValue(ChronoField.DAY_OF_MONTH)
   *    dd      2      appendValue(ChronoField.DAY_OF_MONTH, 2)
   *    D       1      appendValue(ChronoField.DAY_OF_YEAR)
   *    DD      2      appendValue(ChronoField.DAY_OF_YEAR, 2, 3, SignStyle.NOT_NEGATIVE)
   *    DDD     3      appendValue(ChronoField.DAY_OF_YEAR, 3)
   *    F       1      appendValue(ChronoField.ALIGNED_WEEK_OF_MONTH)
   *    g..g    1..n   appendValue(JulianFields.MODIFIED_JULIAN_DAY, n, 19, SignStyle.NORMAL)
   *    E       1      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
   *    EE      2      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
   *    EEE     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
   *    EEEE    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
   *    EEEEE   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
   *    e       1      append special localized WeekFields element for numeric day-of-week
   *    ee      2      append special localized WeekFields element for numeric day-of-week, zero-padded
   *    eee     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT)
   *    eeee    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL)
   *    eeeee   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW)
   *    c       1      append special localized WeekFields element for numeric day-of-week
   *    ccc     3      appendText(ChronoField.DAY_OF_WEEK, TextStyle.SHORT_STANDALONE)
   *    cccc    4      appendText(ChronoField.DAY_OF_WEEK, TextStyle.FULL_STANDALONE)
   *    ccccc   5      appendText(ChronoField.DAY_OF_WEEK, TextStyle.NARROW_STANDALONE)
   * 
   * 
   * Time fields: Pattern letters to output a time.
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    a       1      appendText(ChronoField.AMPM_OF_DAY, TextStyle.SHORT)
   *    h       1      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM)
   *    hh      2      appendValue(ChronoField.CLOCK_HOUR_OF_AMPM, 2)
   *    H       1      appendValue(ChronoField.HOUR_OF_DAY)
   *    HH      2      appendValue(ChronoField.HOUR_OF_DAY, 2)
   *    k       1      appendValue(ChronoField.CLOCK_HOUR_OF_DAY)
   *    kk      2      appendValue(ChronoField.CLOCK_HOUR_OF_DAY, 2)
   *    K       1      appendValue(ChronoField.HOUR_OF_AMPM)
   *    KK      2      appendValue(ChronoField.HOUR_OF_AMPM, 2)
   *    m       1      appendValue(ChronoField.MINUTE_OF_HOUR)
   *    mm      2      appendValue(ChronoField.MINUTE_OF_HOUR, 2)
   *    s       1      appendValue(ChronoField.SECOND_OF_MINUTE)
   *    ss      2      appendValue(ChronoField.SECOND_OF_MINUTE, 2)
   *
   *    S..S    1..n   appendFraction(ChronoField.NANO_OF_SECOND, n, n, false)
   *    A..A    1..n   appendValue(ChronoField.MILLI_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)
   *    n..n    1..n   appendValue(ChronoField.NANO_OF_SECOND, n, 19, SignStyle.NOT_NEGATIVE)
   *    N..N    1..n   appendValue(ChronoField.NANO_OF_DAY, n, 19, SignStyle.NOT_NEGATIVE)
   * 
   * 
   * Day periods: Pattern letters to output a day period.
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    B       1      appendDayPeriodText(TextStyle.SHORT)
   *    BBBB    4      appendDayPeriodText(TextStyle.FULL)
   *    BBBBB   5      appendDayPeriodText(TextStyle.NARROW)
   * 
   * 
   * Zone ID: Pattern letters to output `ZoneId`.
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    VV      2      appendZoneId()
   *    v       1      appendGenericZoneText(TextStyle.SHORT)
   *    vvvv    4      appendGenericZoneText(TextStyle.FULL)
   *    z       1      appendZoneText(TextStyle.SHORT)
   *    zz      2      appendZoneText(TextStyle.SHORT)
   *    zzz     3      appendZoneText(TextStyle.SHORT)
   *    zzzz    4      appendZoneText(TextStyle.FULL)
   * 
   * 
   * Zone offset: Pattern letters to output `ZoneOffset`.
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    O       1      appendLocalizedOffset(TextStyle.SHORT)
   *    OOOO    4      appendLocalizedOffset(TextStyle.FULL)
   *    X       1      appendOffset("+HHmm","Z")
   *    XX      2      appendOffset("+HHMM","Z")
   *    XXX     3      appendOffset("+HH:MM","Z")
   *    XXXX    4      appendOffset("+HHMMss","Z")
   *    XXXXX   5      appendOffset("+HH:MM:ss","Z")
   *    x       1      appendOffset("+HHmm","+00")
   *    xx      2      appendOffset("+HHMM","+0000")
   *    xxx     3      appendOffset("+HH:MM","+00:00")
   *    xxxx    4      appendOffset("+HHMMss","+0000")
   *    xxxxx   5      appendOffset("+HH:MM:ss","+00:00")
   *    Z       1      appendOffset("+HHMM","+0000")
   *    ZZ      2      appendOffset("+HHMM","+0000")
   *    ZZZ     3      appendOffset("+HHMM","+0000")
   *    ZZZZ    4      appendLocalizedOffset(TextStyle.FULL)
   *    ZZZZZ   5      appendOffset("+HH:MM:ss","Z")
   * 
   * 
   * Modifiers: Pattern letters that modify the rest of the pattern:
   *      *  Pattern  Count  Equivalent builder methods
   *  -------  -----  --------------------------
   *    [       1      optionalStart()
   *    ]       1      optionalEnd()
   *    p..p    1..n   padNext(n)
   * 
   * 
   * Any sequence of letters not specified above, unrecognized letter or
   * reserved character will throw an exception.
   * Future versions may add to the set of patterns.
   * It is recommended to use single quotes around all characters that you want
   * to output directly to ensure that future changes do not break your application.
   * 
   * Note that the pattern string is similar, but not identical, to
   * {@link java.text.SimpleDateFormat SimpleDateFormat}.
   * The pattern string is also similar, but not identical, to that defined by the
   * Unicode Common Locale Data Repository (CLDR/LDML).
   * Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML.
   * By contrast, `SimpleDateFormat` uses 'u' for the numeric day of week.
   * Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently.
   * Pattern letters 'n', 'A', 'N', and 'p' are added.
   * Number types will reject large numbers.
   *
   * @param pattern  the pattern to add, not null
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if the pattern is invalid
  */
  appendPattern(pattern: string): DateTimeFormatterBuilder;
  /**
   * Causes the next added printer/parser to pad to a fixed width using a space.
   * 
   * This padding will pad to a fixed width using spaces.
   * 
   * During formatting, the decorated element will be output and then padded
   * to the specified width. An exception will be thrown during formatting if
   * the pad width is exceeded.
   * 
   * During parsing, the padding and decorated element are parsed.
   * If parsing is lenient, then the pad width is treated as a maximum.
   * The padding is parsed greedily. Thus, if the decorated element starts with
   * the pad character, it will not be parsed.
   *
   * @param padWidth  the pad width, 1 or greater
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if pad width is too small
  */
  padNext(padWidth: number): DateTimeFormatterBuilder;
  /**
   * Causes the next added printer/parser to pad to a fixed width.
   * 
   * This padding is intended for padding other than zero-padding.
   * Zero-padding should be achieved using the appendValue methods.
   * 
   * During formatting, the decorated element will be output and then padded
   * to the specified width. An exception will be thrown during formatting if
   * the pad width is exceeded.
   * 
   * During parsing, the padding and decorated element are parsed.
   * If parsing is lenient, then the pad width is treated as a maximum.
   * If parsing is case insensitive, then the pad character is matched ignoring case.
   * The padding is parsed greedily. Thus, if the decorated element starts with
   * the pad character, it will not be parsed.
   *
   * @param padWidth  the pad width, 1 or greater
   * @param padChar  the pad character
   * @return this, for chaining, not null
   * @throws IllegalArgumentException if pad width is too small
  */
  padNext(padWidth: number, padChar: string): DateTimeFormatterBuilder;
  /**
   * Mark the start of an optional section.
   * 
   * The output of formatting can include optional sections, which may be nested.
   * An optional section is started by calling this method and ended by calling
   * {@link #optionalEnd()} or by ending the build process.
   * 
   * All elements in the optional section are treated as optional.
   * During formatting, the section is only output if data is available in the
   * `TemporalAccessor` for all the elements in the section.
   * During parsing, the whole section may be missing from the parsed string.
   * 
   * For example, consider a builder setup as
   * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2)`.
   * The optional section ends automatically at the end of the builder.
   * During formatting, the minute will only be output if its value can be obtained from the date-time.
   * During parsing, the input will be successfully parsed whether the minute is present or not.
   *
   * @return this, for chaining, not null
  */
  optionalStart(): DateTimeFormatterBuilder;
  /**
   * Ends an optional section.
   * 
   * The output of formatting can include optional sections, which may be nested.
   * An optional section is started by calling {@link #optionalStart()} and ended
   * using this method (or at the end of the builder).
   * 
   * Calling this method without having previously called `optionalStart`
   * will throw an exception.
   * Calling this method immediately after calling `optionalStart` has no effect
   * on the formatter other than ending the (empty) optional section.
   * 
   * All elements in the optional section are treated as optional.
   * During formatting, the section is only output if data is available in the
   * `TemporalAccessor` for all the elements in the section.
   * During parsing, the whole section may be missing from the parsed string.
   * 
   * For example, consider a builder setup as
   * `builder.appendValue(HOUR_OF_DAY,2).optionalStart().appendValue(MINUTE_OF_HOUR,2).optionalEnd()`.
   * During formatting, the minute will only be output if its value can be obtained from the date-time.
   * During parsing, the input will be successfully parsed whether the minute is present or not.
   *
   * @return this, for chaining, not null
   * @throws IllegalStateException if there was no previous call to `optionalStart`
  */
  optionalEnd(): DateTimeFormatterBuilder;
  /**
   * Completes this builder by creating the `DateTimeFormatter`
   * using the default locale.
   * 
   * This will create a formatter with the {@linkplain Locale#getDefault(Locale.Category) default FORMAT locale}.
   * Numbers will be printed and parsed using the standard DecimalStyle.
   * The resolver style will be {@link ResolverStyle#SMART SMART}.
   * 
   * Calling this method will end any open optional sections by repeatedly
   * calling {@link #optionalEnd()} before creating the formatter.
   * 
   * This builder can still be used after creating the formatter if desired,
   * although the state may have been changed by calls to `optionalEnd`.
   *
   * @return the created formatter, not null
  */
  toFormatter(): DateTimeFormatter;
  /**
   * Completes this builder by creating the `DateTimeFormatter`
   * using the specified locale.
   * 
   * This will create a formatter with the specified locale.
   * Numbers will be printed and parsed using the standard DecimalStyle.
   * The resolver style will be {@link ResolverStyle#SMART SMART}.
   * 
   * Calling this method will end any open optional sections by repeatedly
   * calling {@link #optionalEnd()} before creating the formatter.
   * 
   * This builder can still be used after creating the formatter if desired,
   * although the state may have been changed by calls to `optionalEnd`.
   *
   * @param locale  the locale to use for formatting, not null
   * @return the created formatter, not null
  */
  toFormatter(locale: Locale): DateTimeFormatter;
}
/**
 * Enumeration of the style of text formatting and parsing.
 * 
 * Text styles define three sizes for the formatted text - 'full', 'short' and 'narrow'.
 * Each of these three sizes is available in both 'standard' and 'stand-alone' variations.
 * 
 * The difference between the three sizes is obvious in most languages.
 * For example, in English the 'full' month is 'January', the 'short' month is 'Jan'
 * and the 'narrow' month is 'J'. Note that the narrow size is often not unique.
 * For example, 'January', 'June' and 'July' all have the 'narrow' text 'J'.
 * 
 * The difference between the 'standard' and 'stand-alone' forms is trickier to describe
 * as there is no difference in English. However, in other languages there is a difference
 * in the word used when the text is used alone, as opposed to in a complete date.
 * For example, the word used for a month when used alone in a date picker is different
 * to the word used for month in association with a day and year in a date.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class TextStyle extends Enum<TextStyle> {
  /**
   * Full text, typically the full description.
   * For example, day-of-week Monday might output "Monday".
  */
  static readonly FULL: TextStyle;
  /**
   * Full text for stand-alone use, typically the full description.
   * For example, day-of-week Monday might output "Monday".
  */
  static readonly FULL_STANDALONE: TextStyle;
  /**
   * Short text, typically an abbreviation.
   * For example, day-of-week Monday might output "Mon".
  */
  static readonly SHORT: TextStyle;
  /**
   * Short text for stand-alone use, typically an abbreviation.
   * For example, day-of-week Monday might output "Mon".
  */
  static readonly SHORT_STANDALONE: TextStyle;
  /**
   * Narrow text, typically a single letter.
   * For example, day-of-week Monday might output "M".
  */
  static readonly NARROW: TextStyle;
  /**
   * Narrow text for stand-alone use, typically a single letter.
   * For example, day-of-week Monday might output "M".
  */
  static readonly NARROW_STANDALONE: TextStyle;
  static valueOf(name: string): TextStyle;
  static values(): TextStyle[];
  /**
   * Returns true if the Style is a stand-alone style.
   * @return true if the style is a stand-alone style.
  */
  isStandalone(): boolean;
  /**
   * Returns the stand-alone style with the same size.
   * @return the stand-alone style with the same size
  */
  asStandalone(): TextStyle;
  /**
   * Returns the normal style with the same size.
   *
   * @return the normal style with the same size
  */
  asNormal(): TextStyle;
}
/**
 * Formatter for printing and parsing date-time objects.
 * 
 * This class provides the main application entry point for printing and parsing
 * and provides common implementations of `DateTimeFormatter`:
 * 
 * Using predefined constants, such as {@link #ISO_LOCAL_DATE}
 * Using pattern letters, such as `uuuu-MMM-dd`
 * Using localized styles, such as `long` or `medium`
 * 
 * 
 * More complex formatters are provided by
 * {@link DateTimeFormatterBuilder DateTimeFormatterBuilder}.
 *
 * 
 * The main date-time classes provide two methods - one for formatting,
 * `format(DateTimeFormatter formatter)`, and one for parsing,
 * `parse(CharSequence text, DateTimeFormatter formatter)`.
 * For example:
 *  *  LocalDate date = LocalDate.now();
 *  String text = date.format(formatter);
 *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 * 
 * 
 * In addition to the format, formatters can be created with desired Locale,
 * Chronology, ZoneId, and DecimalStyle.
 * 
 * The {@link #withLocale withLocale} method returns a new formatter that
 * overrides the locale. The locale affects some aspects of formatting and
 * parsing. For example, the {@link #ofLocalizedDate ofLocalizedDate} provides a
 * formatter that uses the locale specific date format.
 * 
 * The {@link #withChronology withChronology} method returns a new formatter
 * that overrides the chronology. If overridden, the date-time value is
 * converted to the chronology before formatting. During parsing the date-time
 * value is converted to the chronology before it is returned.
 * 
 * The {@link #withZone withZone} method returns a new formatter that overrides
 * the zone. If overridden, the date-time value is converted to a ZonedDateTime
 * with the requested ZoneId before formatting. During parsing the ZoneId is
 * applied before the value is returned.
 * 
 * The {@link #withDecimalStyle withDecimalStyle} method returns a new formatter that
 * overrides the {@link DecimalStyle}. The DecimalStyle symbols are used for
 * formatting and parsing.
 * 
 * Some applications may need to use the older {@link Format java.text.Format}
 * class for formatting. The {@link #toFormat()} method returns an
 * implementation of `java.text.Format`.
 *
 * Predefined Formatters
 * 
 * Predefined Formatters
 * 
 * 
 * Formatter
 * Description
 * Example
 * 
 * 
 * 
 * 
 * {@link #ofLocalizedDate ofLocalizedDate(dateStyle)} 
 *  Formatter with date style from the locale 
 *  '2011-12-03'
 * 
 * 
 *  {@link #ofLocalizedTime ofLocalizedTime(timeStyle)} 
 *  Formatter with time style from the locale 
 *  '10:15:30'
 * 
 * 
 *  {@link #ofLocalizedDateTime ofLocalizedDateTime(dateTimeStyle)} 
 *  Formatter with a style for date and time from the locale
 *  '3 Jun 2008 11:05:30'
 * 
 * 
 *  {@link #ofLocalizedDateTime ofLocalizedDateTime(dateStyle,timeStyle)}
 * 
 *  Formatter with date and time styles from the locale 
 *  '3 Jun 2008 11:05'
 * 
 * 
 *  {@link #BASIC_ISO_DATE}
 * Basic ISO date  '20111203'
 * 
 * 
 *  {@link #ISO_LOCAL_DATE}
 *  ISO Local Date 
 * '2011-12-03'
 * 
 * 
 *  {@link #ISO_OFFSET_DATE}
 *  ISO Date with offset 
 * '2011-12-03+01:00'
 * 
 * 
 *  {@link #ISO_DATE}
 *  ISO Date with or without offset 
 *  '2011-12-03+01:00'; '2011-12-03'
 * 
 * 
 *  {@link #ISO_LOCAL_TIME}
 *  Time without offset 
 * '10:15:30'
 * 
 * 
 *  {@link #ISO_OFFSET_TIME}
 *  Time with offset 
 * '10:15:30+01:00'
 * 
 * 
 *  {@link #ISO_TIME}
 *  Time with or without offset 
 * '10:15:30+01:00'; '10:15:30'
 * 
 * 
 *  {@link #ISO_LOCAL_DATE_TIME}
 *  ISO Local Date and Time 
 * '2011-12-03T10:15:30'
 * 
 * 
 *  {@link #ISO_OFFSET_DATE_TIME}
 *  Date Time with Offset
 * '2011-12-03T10:15:30+01:00'
 * 
 * 
 *  {@link #ISO_ZONED_DATE_TIME}
 *  Zoned Date Time 
 * '2011-12-03T10:15:30+01:00[Europe/Paris]'
 * 
 * 
 *  {@link #ISO_DATE_TIME}
 *  Date and time with ZoneId 
 * '2011-12-03T10:15:30+01:00[Europe/Paris]'
 * 
 * 
 *  {@link #ISO_ORDINAL_DATE}
 *  Year and day of year 
 * '2012-337'
 * 
 * 
 *  {@link #ISO_WEEK_DATE}
 *  Year and Week 
 * '2012-W48-6'
 * 
 *  {@link #ISO_INSTANT}
 *  Date and Time of an Instant 
 * '2011-12-03T10:15:30Z' 
 * 
 * 
 *  {@link #RFC_1123_DATE_TIME}
 *  RFC 1123 / RFC 822 
 * 'Tue, 3 Jun 2008 11:05:30 GMT'
 * 
 * 
 * 
 *
 * Patterns for Formatting and Parsing
 * Patterns are based on a simple sequence of letters and symbols.
 * A pattern is used to create a Formatter using the
 * {@link #ofPattern(String)} and {@link #ofPattern(String, Locale)} methods.
 * For example,
 * `"d MMM uuuu"` will format 2011-12-03 as '3Dec2011'.
 * A formatter created from a pattern can be used as many times as necessary,
 * it is immutable and is thread-safe.
 * 
 * For example:
 *  *  LocalDate date = LocalDate.now();
 *  DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy MM dd");
 *  String text = date.format(formatter);
 *  LocalDate parsedDate = LocalDate.parse(text, formatter);
 * 
 * 
 * All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The
 * following pattern letters are defined:
 * 
 * Pattern Letters and Symbols
 * 
 *  Symbol   Meaning         Presentation Examples
 * 
 * 
 *   G       era                         text              AD; Anno Domini; A
 *   u       year                        year              2004; 04
 *   y       year-of-era                 year              2004; 04
 *   D       day-of-year                 number            189
 *   M/L     month-of-year               number/text       7; 07; Jul; July; J
 *   d       day-of-month                number            10
 *   g       modified-julian-day         number            2451334
 *
 *   Q/q     quarter-of-year             number/text       3; 03; Q3; 3rd quarter
 *   Y       week-based-year             year              1996; 96
 *   w       week-of-week-based-year     number            27
 *   W       week-of-month               number            4
 *   E       day-of-week                 text              Tue; Tuesday; T
 *   e/c     localized day-of-week       number/text       2; 02; Tue; Tuesday; T
 *   F       aligned-week-of-month       number            3
 *
 *   a       am-pm-of-day                text              PM
 *   B       period-of-day               text              in the morning
 *   h       clock-hour-of-am-pm (1-12)  number            12
 *   K       hour-of-am-pm (0-11)        number            0
 *   k       clock-hour-of-day (1-24)    number            24
 *
 *   H       hour-of-day (0-23)          number            0
 *   m       minute-of-hour              number            30
 *   s       second-of-minute            number            55
 *   S       fraction-of-second          fraction          978
 *   A       milli-of-day                number            1234
 *   n       nano-of-second              number            987654321
 *   N       nano-of-day                 number            1234000000
 *
 *   V       time-zone ID                zone-id           America/Los_Angeles; Z; -08:30
 *   v       generic time-zone name      zone-name         Pacific Time; PT
 *   z       time-zone name              zone-name         Pacific Standard Time; PST
 *   O       localized zone-offset       offset-O          GMT+8; GMT+08:00; UTC-08:00
 *   X       zone-offset 'Z' for zero    offset-X          Z; -08; -0830; -08:30; -083015; -08:30:15
 *   x       zone-offset                 offset-x          +0000; -08; -0830; -08:30; -083015; -08:30:15
 *   Z       zone-offset                 offset-Z          +0000; -0800; -08:00
 *
 *   p       pad next                    pad modifier      1
 *
 *   '       escape for text             delimiter         
 *   ''      single quote                literal           '
 *   [       optional section start                        
 *   ]       optional section end                          
 *   #       reserved for future use                       
 *   {       reserved for future use                       
 *   }       reserved for future use                       
 * 
 * 
 * 
 * The count of pattern letters determines the format.
 * 
 * Text: The text style is determined based on the number of pattern
 * letters used. Less than 4 pattern letters will use the
 * {@link TextStyle#SHORT short form}. Exactly 4 pattern letters will use the
 * {@link TextStyle#FULL full form}. Exactly 5 pattern letters will use the
 * {@link TextStyle#NARROW narrow form}.
 * Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles.
 * 
 * Number: If the count of letters is one, then the value is output using
 * the minimum number of digits and without padding. Otherwise, the count of digits
 * is used as the width of the output field, with the value zero-padded as necessary.
 * The following pattern letters have constraints on the count of letters.
 * Only one letter of 'c' and 'F' can be specified.
 * Up to two letters of 'd', 'H', 'h', 'K', 'k', 'm', and 's' can be specified.
 * Up to three letters of 'D' can be specified.
 * 
 * Number/Text: If the count of pattern letters is 3 or greater, use the
 * Text rules above. Otherwise use the Number rules above.
 * 
 * Fraction: Outputs the nano-of-second field as a fraction-of-second.
 * The nano-of-second value has nine digits, thus the count of pattern letters
 * is from 1 to 9. If it is less than 9, then the nano-of-second value is
 * truncated, with only the most significant digits being output.
 * 
 * Year: The count of letters determines the minimum field width below
 * which padding is used. If the count of letters is two, then a
 * {@link DateTimeFormatterBuilder#appendValueReduced reduced} two digit form is
 * used. For printing, this outputs the rightmost two digits. For parsing, this
 * will parse using the base value of 2000, resulting in a year within the range
 * 2000 to 2099 inclusive. If the count of letters is less than four (but not
 * two), then the sign is only output for negative years as per
 * {@link SignStyle#NORMAL}. Otherwise, the sign is output if the pad width is
 * exceeded, as per {@link SignStyle#EXCEEDS_PAD}.
 * 
 * ZoneId: This outputs the time-zone ID, such as 'Europe/Paris'. If the
 * count of letters is two, then the time-zone ID is output. Any other count of
 * letters throws `IllegalArgumentException`.
 * 
 * Zone names: This outputs the display name of the time-zone ID. If the
 * pattern letter is 'z' the output is the daylight saving aware zone name.
 * If there is insufficient information to determine whether DST applies,
 * the name ignoring daylight saving time will be used.
 * If the count of letters is one, two or three, then the short name is output.
 * If the count of letters is four, then the full name is output.
 * Five or more letters throws `IllegalArgumentException`.
 * 
 * If the pattern letter is 'v' the output provides the zone name ignoring
 * daylight saving time. If the count of letters is one, then the short name is output.
 * If the count of letters is four, then the full name is output.
 * Two, three and five or more letters throw `IllegalArgumentException`.
 * 
 * Offset X and x: This formats the offset based on the number of pattern
 * letters. One letter outputs just the hour, such as '+01', unless the minute
 * is non-zero in which case the minute is also output, such as '+0130'. Two
 * letters outputs the hour and minute, without a colon, such as '+0130'. Three
 * letters outputs the hour and minute, with a colon, such as '+01:30'. Four
 * letters outputs the hour and minute and optional second, without a colon,
 * such as '+013015'. Five letters outputs the hour and minute and optional
 * second, with a colon, such as '+01:30:15'. Six or more letters throws
 * `IllegalArgumentException`. Pattern letter 'X' (upper case) will output
 * 'Z' when the offset to be output would be zero, whereas pattern letter 'x'
 * (lower case) will output '+00', '+0000', or '+00:00'.
 * 
 * Offset O: With a non-zero offset, this formats the localized offset
 * based on the number of pattern letters. One letter outputs the
 * {@linkplain TextStyle#SHORT short} form of the localized offset, which is
 * localized offset text, such as 'GMT', with hour without leading zero, optional
 * 2-digit minute and second if non-zero, and colon, for example 'GMT+8'. Four
 * letters outputs the {@linkplain TextStyle#FULL full} form, which is localized
 * offset text, such as 'GMT, with 2-digit hour and minute field, optional second
 * field if non-zero, and colon, for example 'GMT+08:00'. If the offset is zero,
 * only localized text is output. Any other count of letters throws
 * `IllegalArgumentException`.
 * 
 * Offset Z: This formats the offset based on the number of pattern
 * letters. One, two or three letters outputs the hour and minute, without a
 * colon, such as '+0130'. The output will be '+0000' when the offset is zero.
 * Four letters outputs the {@linkplain TextStyle#FULL full} form of localized
 * offset, equivalent to four letters of Offset-O. The output will be the
 * corresponding localized offset text if the offset is zero. Five
 * letters outputs the hour, minute, with optional second if non-zero, with
 * colon. It outputs 'Z' if the offset is zero.
 * Six or more letters throws `IllegalArgumentException`.
 * 
 * Optional section: The optional section markers work exactly like
 * calling {@link DateTimeFormatterBuilder#optionalStart()} and
 * {@link DateTimeFormatterBuilder#optionalEnd()}.
 * 
 * Pad modifier: Modifies the pattern that immediately follows to be
 * padded with spaces. The pad width is determined by the number of pattern
 * letters. This is the same as calling
 * {@link DateTimeFormatterBuilder#padNext(int)}.
 * 
 * For example, 'ppH' outputs the hour-of-day padded on the left with spaces to
 * a width of 2.
 * 
 * Any unrecognized letter is an error. Any non-letter character, other than
 * '[', ']', '{', '}', '#' and the single quote will be output directly.
 * Despite this, it is recommended to use single quotes around all characters
 * that you want to output directly to ensure that future changes do not break
 * your application.
 *
 * Resolving
 * Parsing is implemented as a two-phase operation.
 * First, the text is parsed using the layout defined by the formatter, producing
 * a `Map` of field to value, a `ZoneId` and a `Chronology`.
 * Second, the parsed data is resolved, by validating, combining and
 * simplifying the various fields into more useful ones.
 * 
 * Five parsing methods are supplied by this class.
 * Four of these perform both the parse and resolve phases.
 * The fifth method, {@link #parseUnresolved(CharSequence, ParsePosition)},
 * only performs the first phase, leaving the result unresolved.
 * As such, it is essentially a low-level operation.
 * 
 * The resolve phase is controlled by two parameters, set on this class.
 * 
 * The {@link ResolverStyle} is an enum that offers three different approaches,
 * strict, smart and lenient. The smart option is the default.
 * It can be set using {@link #withResolverStyle(ResolverStyle)}.
 * 
 * The {@link #withResolverFields(TemporalField...)} parameter allows the
 * set of fields that will be resolved to be filtered before resolving starts.
 * For example, if the formatter has parsed a year, month, day-of-month
 * and day-of-year, then there are two approaches to resolve a date:
 * (year + month + day-of-month) and (year + day-of-year).
 * The resolver fields allows one of the two approaches to be selected.
 * If no resolver fields are set then both approaches must result in the same date.
 * 
 * Resolving separate fields to form a complete date and time is a complex
 * process with behaviour distributed across a number of classes.
 * It follows these steps:
 * 
 * The chronology is determined.
 * The chronology of the result is either the chronology that was parsed,
 * or if no chronology was parsed, it is the chronology set on this class,
 * or if that is null, it is `IsoChronology`.
 * The `ChronoField` date fields are resolved.
 * This is achieved using {@link Chronology#resolveDate(Map, ResolverStyle)}.
 * Documentation about field resolution is located in the implementation
 * of `Chronology`.
 * The `ChronoField` time fields are resolved.
 * This is documented on {@link ChronoField} and is the same for all chronologies.
 * Any fields that are not `ChronoField` are processed.
 * This is achieved using {@link TemporalField#resolve(Map, TemporalAccessor, ResolverStyle)}.
 * Documentation about field resolution is located in the implementation
 * of `TemporalField`.
 * The `ChronoField` date and time fields are re-resolved.
 * This allows fields in step four to produce `ChronoField` values
 * and have them be processed into dates and times.
 * A `LocalTime` is formed if there is at least an hour-of-day available.
 * This involves providing default values for minute, second and fraction of second.
 * Any remaining unresolved fields are cross-checked against any
 * date and/or time that was resolved. Thus, an earlier stage would resolve
 * (year + month + day-of-month) to a date, and this stage would check that
 * day-of-week was valid for the date.
 * If an {@linkplain #parsedExcessDays() excess number of days}
 * was parsed then it is added to the date if a date is available.
 *  If a second-based field is present, but `LocalTime` was not parsed,
 * then the resolver ensures that milli, micro and nano second values are
 * available to meet the contract of {@link ChronoField}.
 * These will be set to zero if missing.
 * If both date and time were parsed and either an offset or zone is present,
 * the field {@link ChronoField#INSTANT_SECONDS} is created.
 * If an offset was parsed then the offset will be combined with the
 * `LocalDateTime` to form the instant, with any zone ignored.
 * If a `ZoneId` was parsed without an offset then the zone will be
 * combined with the `LocalDateTime` to form the instant using the rules
 * of {@link ChronoLocalDateTime#atZone(ZoneId)}. If the `ZoneId` was
 * parsed from a zone name that indicates whether daylight saving time is in
 * operation or not, then that fact will be used to select the correct offset
 * at the local time-line overlap.
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class DateTimeFormatter {
  /**
   * Creates a formatter using the specified pattern.
   * 
   * This method will create a formatter based on a simple
   * pattern of letters and symbols
   * as described in the class documentation.
   * For example, `d MMM uuuu` will format 2011-12-03 as '3 Dec 2011'.
   * 
   * The formatter will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
   * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.
   * Alternatively use the {@link #ofPattern(String, Locale)} variant of this method.
   * 
   * The returned formatter has no override chronology or zone.
   * It uses {@link ResolverStyle#SMART SMART} resolver style.
   *
   * @param pattern  the pattern to use, not null
   * @return the formatter based on the pattern, not null
   * @throws IllegalArgumentException if the pattern is invalid
   * @see DateTimeFormatterBuilder#appendPattern(String)
  */
  static ofPattern(pattern: string): DateTimeFormatter;
  /**
   * Creates a formatter using the specified pattern and locale.
   * 
   * This method will create a formatter based on a simple
   * pattern of letters and symbols
   * as described in the class documentation.
   * For example, `d MMM uuuu` will format 2011-12-03 as '3 Dec 2011'.
   * 
   * The formatter will use the specified locale.
   * This can be changed using {@link DateTimeFormatter#withLocale(Locale)} on the returned formatter.
   * 
   * The returned formatter has no override chronology or zone.
   * It uses {@link ResolverStyle#SMART SMART} resolver style.
   *
   * @param pattern  the pattern to use, not null
   * @param locale  the locale to use, not null
   * @return the formatter based on the pattern, not null
   * @throws IllegalArgumentException if the pattern is invalid
   * @see DateTimeFormatterBuilder#appendPattern(String)
  */
  static ofPattern(pattern: string, locale: Locale): DateTimeFormatter;
  /**
   * Returns a locale specific date format for the ISO chronology.
   * 
   * This returns a formatter that will format or parse a date.
   * The exact format pattern used varies by locale.
   * 
   * The locale is determined from the formatter. The formatter returned directly by
   * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
   * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
   * on the result of this method.
   * 
   * Note that the localized pattern is looked up lazily.
   * This `DateTimeFormatter` holds the style required and the locale,
   * looking up the pattern required on demand.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
   *
   * @param dateStyle  the formatter style to obtain, not null
   * @return the date formatter, not null
  */
  static ofLocalizedDate(dateStyle: FormatStyle): DateTimeFormatter;
  /**
   * Returns a locale specific time format for the ISO chronology.
   * 
   * This returns a formatter that will format or parse a time.
   * The exact format pattern used varies by locale.
   * 
   * The locale is determined from the formatter. The formatter returned directly by
   * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
   * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
   * on the result of this method.
   * 
   * Note that the localized pattern is looked up lazily.
   * This `DateTimeFormatter` holds the style required and the locale,
   * looking up the pattern required on demand.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
   * The `FULL` and `LONG` styles typically require a time-zone.
   * When formatting using these styles, a `ZoneId` must be available,
   * either by using `ZonedDateTime` or {@link DateTimeFormatter#withZone}.
   *
   * @param timeStyle  the formatter style to obtain, not null
   * @return the time formatter, not null
  */
  static ofLocalizedTime(timeStyle: FormatStyle): DateTimeFormatter;
  /**
   * Returns a locale specific date-time formatter for the ISO chronology.
   * 
   * This returns a formatter that will format or parse a date-time.
   * The exact format pattern used varies by locale.
   * 
   * The locale is determined from the formatter. The formatter returned directly by
   * this method will use the {@link Locale#getDefault(Locale.Category) default FORMAT locale}.
   * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
   * on the result of this method.
   * 
   * Note that the localized pattern is looked up lazily.
   * This `DateTimeFormatter` holds the style required and the locale,
   * looking up the pattern required on demand.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
   * The `FULL` and `LONG` styles typically require a time-zone.
   * When formatting using these styles, a `ZoneId` must be available,
   * either by using `ZonedDateTime` or {@link DateTimeFormatter#withZone}.
   *
   * @param dateTimeStyle  the formatter style to obtain, not null
   * @return the date-time formatter, not null
  */
  static ofLocalizedDateTime(dateTimeStyle: FormatStyle): DateTimeFormatter;
  /**
   * Returns a locale specific date and time format for the ISO chronology.
   * 
   * This returns a formatter that will format or parse a date-time.
   * The exact format pattern used varies by locale.
   * 
   * The locale is determined from the formatter. The formatter returned directly by
   * this method will use the {@link Locale#getDefault() default FORMAT locale}.
   * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
   * on the result of this method.
   * 
   * Note that the localized pattern is looked up lazily.
   * This `DateTimeFormatter` holds the style required and the locale,
   * looking up the pattern required on demand.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
   * The `FULL` and `LONG` styles typically require a time-zone.
   * When formatting using these styles, a `ZoneId` must be available,
   * either by using `ZonedDateTime` or {@link DateTimeFormatter#withZone}.
   *
   * @param dateStyle  the date formatter style to obtain, not null
   * @param timeStyle  the time formatter style to obtain, not null
   * @return the date, time or date-time formatter, not null
  */
  static ofLocalizedDateTime(dateStyle: FormatStyle, timeStyle: FormatStyle): DateTimeFormatter;
  /**
   * Creates a locale specific formatter derived from the requested template for
   * the ISO chronology. The requested template is a series of typical pattern
   * symbols in canonical order from the largest date or time unit to the smallest,
   * which can be expressed with the following regular expression:
   * {@snippet :
   *      "G{0,5}" +        // Era
   *      "y*" +            // Year
   *      "Q{0,5}" +        // Quarter
   *      "M{0,5}" +        // Month
   *      "w*" +            // Week of Week Based Year
   *      "E{0,5}" +        // Day of Week
   *      "d{0,2}" +        // Day of Month
   *      "B{0,5}" +        // Period/AmPm of Day
   *      "[hHjC]{0,2}" +   // Hour of Day/AmPm (refer to LDML for 'j' and 'C')
   *      "m{0,2}" +        // Minute of Hour
   *      "s{0,2}" +        // Second of Minute
   *      "[vz]{0,4}"       // Zone
   * }
   * All pattern symbols are optional, and each pattern symbol represents a field,
   * for example, 'M' represents the Month field. The number of the pattern symbol letters follows the
   * same presentation, such as "number" or "text" as in the Patterns for
   * Formatting and Parsing section. Other pattern symbols in the requested template are
   * invalid.
   * 
   * The mapping of the requested template to the closest of the available localized formats
   * is defined by the
   * 
   * Unicode LDML specification. For example, the formatter created from the requested template
   * `yMMM` will format the date '2020-06-16' to 'Jun 2020' in the {@link Locale#US US locale}.
   * 
   * The locale is determined from the formatter. The formatter returned directly by
   * this method uses the {@link Locale#getDefault() default FORMAT locale}.
   * The locale can be controlled using {@link DateTimeFormatter#withLocale(Locale) withLocale(Locale)}
   * on the result of this method.
   * 
   * The returned formatter has no override zone.
   * It uses {@link ResolverStyle#SMART SMART} resolver style.
   *
   * @param requestedTemplate the requested template, not null
   * @return the formatter based on the `requestedTemplate` pattern, not null
   * @throws IllegalArgumentException if `requestedTemplate` is invalid
   *
   * @spec https://www.unicode.org/reports/tr35 Unicode Locale Data Markup Language (LDML)
   * @see #ofPattern(String)
   * @since 19
  */
  static ofLocalizedPattern(requestedTemplate: string): DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses a date without an
   * offset, such as '2011-12-03'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended local date format.
   * The format consists of:
   * 
   * Four digits or more for the {@link ChronoField#YEAR year}.
   * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
   * Years outside that range will have a prefixed positive or negative symbol.
   * A hyphen ('HYPHEN-MINUS', U+002D)
   * Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
   *  This is pre-padded by zero to ensure two digits.
   * A hyphen ('HYPHEN-MINUS', U+002D)
   * Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
   *  This is pre-padded by zero to ensure two digits.
   * 
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_LOCAL_DATE: DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses a date with an
   * offset, such as '2011-12-03+01:00'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended offset date format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_DATE}
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_OFFSET_DATE: DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses a date with the
   * offset if available, such as '2011-12-03' or '2011-12-03+01:00'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended date format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_DATE}
   * If the offset is not available then the format is complete.
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_DATE: DateTimeFormatter;
  /**
   * The ISO time formatter that formats or parses a time without an
   * offset, such as '10:15' or '10:15:30'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended local time format.
   * The format consists of:
   * 
   * Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
   *  This is pre-padded by zero to ensure two digits.
   * A colon
   * Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
   *  This is pre-padded by zero to ensure two digits.
   * If the second-of-minute is not available then the format is complete.
   * A colon
   * Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
   *  This is pre-padded by zero to ensure two digits.
   * If the nano-of-second is zero or not available then the format is complete.
   * A decimal point
   * One to nine digits for the {@link ChronoField#NANO_OF_SECOND nano-of-second}.
   *  As many digits will be output as required.
   * 
   * 
   * The returned formatter has no override chronology or zone.
   * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_LOCAL_TIME: DateTimeFormatter;
  /**
   * The ISO time formatter that formats or parses a time with an
   * offset, such as '10:15+01:00' or '10:15:30+01:00'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended offset time format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_TIME}
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * The returned formatter has no override chronology or zone.
   * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_OFFSET_TIME: DateTimeFormatter;
  /**
   * The ISO time formatter that formats or parses a time, with the
   * offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended offset time format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_TIME}
   * If the offset is not available then the format is complete.
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has no override chronology or zone.
   * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_TIME: DateTimeFormatter;
  /**
   * The ISO date-time formatter that formats or parses a date-time without
   * an offset, such as '2011-12-03T10:15:30'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended offset date-time format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_DATE}
   * The letter 'T'. Parsing is case insensitive.
   * The {@link #ISO_LOCAL_TIME}
   * 
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_LOCAL_DATE_TIME: DateTimeFormatter;
  /**
   * The ISO date-time formatter that formats or parses a date-time with an
   * offset, such as '2011-12-03T10:15:30+01:00'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended offset date-time format.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_DATE_TIME}
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  The offset parsing is lenient, which allows the minutes and seconds to be optional.
   *  Parsing is case insensitive.
   * 
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_OFFSET_DATE_TIME: DateTimeFormatter;
  /**
   * The ISO-like date-time formatter that formats or parses a date-time with
   * offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * a format that extends the ISO-8601 extended offset date-time format
   * to add the time-zone.
   * The section in square brackets is not part of the ISO-8601 standard.
   * The format consists of:
   * 
   * The {@link #ISO_OFFSET_DATE_TIME}
   * If the zone ID is not available or is a `ZoneOffset` then the format is complete.
   * An open square bracket '['.
   * The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
   *  Parsing is case sensitive.
   * A close square bracket ']'.
   * 
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_ZONED_DATE_TIME: DateTimeFormatter;
  /**
   * The ISO-like date-time formatter that formats or parses a date-time with
   * the offset and zone if available, such as '2011-12-03T10:15:30',
   * '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended local or offset date-time format, as well as the
   * extended non-ISO form specifying the time-zone.
   * The format consists of:
   * 
   * The {@link #ISO_LOCAL_DATE_TIME}
   * If the offset is not available to format or parse then the format is complete.
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   * If the zone ID is not available or is a `ZoneOffset` then the format is complete.
   * An open square bracket '['.
   * The {@link ZoneId#getId() zone ID}. This is not part of the ISO-8601 standard.
   *  Parsing is case sensitive.
   * A close square bracket ']'.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_DATE_TIME: DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses the ordinal date
   * without an offset, such as '2012-337'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended ordinal date format.
   * The format consists of:
   * 
   * Four digits or more for the {@link ChronoField#YEAR year}.
   * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
   * Years outside that range will have a prefixed positive or negative symbol.
   * A hyphen ('HYPHEN-MINUS', U+002D)
   * Three digits for the {@link ChronoField#DAY_OF_YEAR day-of-year}.
   *  This is pre-padded by zero to ensure three digits.
   * If the offset is not available to format or parse then the format is complete.
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_ORDINAL_DATE: DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses the week-based date
   * without an offset, such as '2012-W48-6'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 extended week-based date format.
   * The format consists of:
   * 
   * Four digits or more for the {@link IsoFields#WEEK_BASED_YEAR week-based-year}.
   * Years in the range 0000 to 9999 will be pre-padded by zero to ensure four digits.
   * Years outside that range will have a prefixed positive or negative symbol.
   * A hyphen ('HYPHEN-MINUS', U+002D)
   * The letter 'W'. Parsing is case insensitive.
   * Two digits for the {@link IsoFields#WEEK_OF_WEEK_BASED_YEAR week-of-week-based-year}.
   *  This is pre-padded by zero to ensure three digits.
   * A hyphen ('HYPHEN-MINUS', U+002D)
   * One digit for the {@link ChronoField#DAY_OF_WEEK day-of-week}.
   *  The value run from Monday (1) to Sunday (7).
   * If the offset is not available to format or parse then the format is complete.
   * The {@link ZoneOffset#getId() offset ID}. If the offset has seconds then
   *  they will be handled even though this is not part of the ISO-8601 standard.
   *  Parsing is case insensitive.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_WEEK_DATE: DateTimeFormatter;
  /**
   * The ISO instant formatter that formats or parses an instant in UTC,
   * such as '2011-12-03T10:15:30Z'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 instant format.
   * When formatting, the instant will always be suffixed by 'Z' to indicate UTC.
   * The second-of-minute is always output.
   * The nano-of-second outputs zero, three, six or nine digits as necessary.
   * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}
   * will be used to parse the offset, converting the instant to UTC as necessary.
   * The time to at least the seconds field is required.
   * Fractional seconds from zero to nine are parsed.
   * The localized decimal style is not used.
   * 
   * This is a special case formatter intended to allow a human readable form
   * of an {@link java.time.Instant}. The `Instant` class is designed to
   * only represent a point in time and internally stores a value in nanoseconds
   * from a fixed epoch of 1970-01-01Z. As such, an `Instant` cannot be
   * formatted as a date or time without providing some form of time-zone.
   * This formatter allows the `Instant` to be formatted, by providing
   * a suitable conversion using `ZoneOffset.UTC`.
   * 
   * The format consists of:
   * 
   * The {@link #ISO_OFFSET_DATE_TIME} where the instant is converted from
   *  {@link ChronoField#INSTANT_SECONDS} and {@link ChronoField#NANO_OF_SECOND}
   *  using the `UTC` offset. Parsing is case insensitive.
   * 
   * 
   * The returned formatter has no override chronology or zone.
   * It uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly ISO_INSTANT: DateTimeFormatter;
  /**
   * The ISO date formatter that formats or parses a date without an
   * offset, such as '20111203'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * the ISO-8601 basic local date format.
   * The format consists of:
   * 
   * Four digits for the {@link ChronoField#YEAR year}.
   *  Only years in the range 0000 to 9999 are supported.
   * Two digits for the {@link ChronoField#MONTH_OF_YEAR month-of-year}.
   *  This is pre-padded by zero to ensure two digits.
   * Two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
   *  This is pre-padded by zero to ensure two digits.
   * If the offset is not available to format or parse then the format is complete.
   * The {@link ZoneOffset#getId() offset ID} without colons. If the offset has
   *  seconds then they will be handled even though this is not part of the ISO-8601 standard.
   *  The offset parsing is lenient, which allows the minutes and seconds to be optional.
   *  Parsing is case insensitive.
   * 
   * 
   * As this formatter has an optional element, it may be necessary to parse using
   * {@link DateTimeFormatter#parseBest}.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#STRICT STRICT} resolver style.
  */
  static readonly BASIC_ISO_DATE: DateTimeFormatter;
  /**
   * The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30 GMT'.
   * 
   * This returns an immutable formatter capable of formatting and parsing
   * most of the RFC-1123 format.
   * RFC-1123 updates RFC-822 changing the year from two digits to four.
   * This implementation requires a four digit year.
   * This implementation also does not handle North American or military zone
   * names, only 'GMT' and offset amounts.
   * 
   * The format consists of:
   * 
   * If the day-of-week is not available to format or parse then jump to day-of-month.
   * Three letter {@link ChronoField#DAY_OF_WEEK day-of-week} in English.
   * A comma
   * A space
   * One or two digits for the {@link ChronoField#DAY_OF_MONTH day-of-month}.
   * A space
   * Three letter {@link ChronoField#MONTH_OF_YEAR month-of-year} in English.
   * A space
   * Four digits for the {@link ChronoField#YEAR year}.
   *  Only years in the range 0000 to 9999 are supported.
   * A space
   * Two digits for the {@link ChronoField#HOUR_OF_DAY hour-of-day}.
   *  This is pre-padded by zero to ensure two digits.
   * A colon
   * Two digits for the {@link ChronoField#MINUTE_OF_HOUR minute-of-hour}.
   *  This is pre-padded by zero to ensure two digits.
   * If the second-of-minute is not available then jump to the next space.
   * A colon
   * Two digits for the {@link ChronoField#SECOND_OF_MINUTE second-of-minute}.
   *  This is pre-padded by zero to ensure two digits.
   * A space
   * The {@link ZoneOffset#getId() offset ID} without colons or seconds.
   *  An offset of zero uses "GMT". North American zone names and military zone names are not handled.
   * 
   * 
   * Parsing is case insensitive.
   * 
   * The returned formatter has a chronology of ISO set to ensure dates in
   * other calendar systems are correctly converted.
   * It has no override zone and uses the {@link ResolverStyle#SMART SMART} resolver style.
  */
  static readonly RFC_1123_DATE_TIME: DateTimeFormatter;
  /**
   * A query that provides access to the excess days that were parsed.
   * 
   * This returns a singleton {@linkplain TemporalQuery query} that provides
   * access to additional information from the parse. The query always returns
   * a non-null period, with a zero period returned instead of null.
   * 
   * There are two situations where this query may return a non-zero period.
   * 
   * If the `ResolverStyle` is `LENIENT` and a time is parsed
   *  without a date, then the complete result of the parse consists of a
   *  `LocalTime` and an excess `Period` in days.
   *
   * If the `ResolverStyle` is `SMART` and a time is parsed
   *  without a date where the time is 24:00:00, then the complete result of
   *  the parse consists of a `LocalTime` of 00:00:00 and an excess
   *  `Period` of one day.
   * 
   * 
   * In both cases, if a complete `ChronoLocalDateTime` or `Instant`
   * is parsed, then the excess days are added to the date part.
   * As a result, this query will return a zero period.
   * 
   * The `SMART` behaviour handles the common "end of day" 24:00 value.
   * Processing in `LENIENT` mode also produces the same result:
   *      *  Text to parse        Parsed object                         Excess days
   *  "2012-12-03T00:00"   LocalDateTime.of(2012, 12, 3, 0, 0)   ZERO
   *  "2012-12-03T24:00"   LocalDateTime.of(2012, 12, 4, 0, 0)   ZERO
   *  "00:00"              LocalTime.of(0, 0)                    ZERO
   *  "24:00"              LocalTime.of(0, 0)                    Period.ofDays(1)
   * 
   * The query can be used as follows:
   *      *  TemporalAccessor parsed = formatter.parse(str);
   *  LocalTime time = parsed.query(LocalTime::from);
   *  Period extraDays = parsed.query(DateTimeFormatter.parsedExcessDays());
   * 
   * @return a query that provides access to the excess days that were parsed
  */
  static parsedExcessDays(): TemporalQuery<Period>;
  /**
   * A query that provides access to whether a leap-second was parsed.
   * 
   * This returns a singleton {@linkplain TemporalQuery query} that provides
   * access to additional information from the parse. The query always returns
   * a non-null boolean, true if parsing saw a leap-second, false if not.
   * 
   * Instant parsing handles the special "leap second" time of '23:59:60'.
   * Leap seconds occur at '23:59:60' in the UTC time-zone, but at other
   * local times in different time-zones. To avoid this potential ambiguity,
   * the handling of leap-seconds is limited to
   * {@link DateTimeFormatterBuilder#appendInstant()}, as that method
   * always parses the instant with the UTC zone offset.
   * 
   * If the time '23:59:60' is received, then a simple conversion is applied,
   * replacing the second-of-minute of 60 with 59. This query can be used
   * on the parse result to determine if the leap-second adjustment was made.
   * The query will return `true` if it did adjust to remove the
   * leap-second, and `false` if not. Note that applying a leap-second
   * smoothing mechanism, such as UTC-SLS, is the responsibility of the
   * application, as follows:
   *      *  TemporalAccessor parsed = formatter.parse(str);
   *  Instant instant = parsed.query(Instant::from);
   *  if (parsed.query(DateTimeFormatter.parsedLeapSecond())) {
   *    // validate leap-second is correct and apply correct smoothing
   *  }
   * 
   * @return a query that provides access to whether a leap-second was parsed
  */
  static parsedLeapSecond(): TemporalQuery<boolean>;
  /**
   * Gets the locale to be used during formatting.
   * 
   * This is used to lookup any part of the formatter needing specific
   * localization, such as the text or localized pattern.
   *
   * @return the locale of this formatter, not null
  */
  get locale(): Locale;
  /**
   * Returns a copy of this formatter with a new locale.
   * 
   * This is used to lookup any part of the formatter needing specific
   * localization, such as the text or localized pattern.
   * 
   * The locale is stored as passed in, without further processing.
   * If the locale has 
   * Unicode extensions, they may be used later in text
   * processing. To set the chronology, time-zone and decimal style from
   * unicode extensions, see {@link #localizedBy localizedBy()}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param locale  the new locale, not null
   * @return a formatter based on this formatter with the requested locale, not null
   * @see #localizedBy(Locale)
  */
  withLocale(locale: Locale): DateTimeFormatter;
  /**
   * Returns a copy of this formatter with localized values of the locale,
   * calendar, region, decimal style and/or timezone, that supersede values in
   * this formatter.
   * 
   * This is used to lookup any part of the formatter needing specific
   * localization, such as the text or localized pattern. If the locale contains the
   * "ca" (calendar), "nu" (numbering system), "rg" (region override), and/or
   * "tz" (timezone)
   * Unicode extensions,
   * the chronology, numbering system and/or the zone are overridden. If both "ca"
   * and "rg" are specified, the chronology from the "ca" extension supersedes the
   * implicit one from the "rg" extension. Same is true for the "nu" extension.
   * 
   * Unlike the {@link #withLocale withLocale} method, the call to this method may
   * produce a different formatter depending on the order of method chaining with
   * other withXXXX() methods.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param locale  the locale, not null
   * @return a formatter based on this formatter with localized values of
   *      the calendar, decimal style and/or timezone, that supersede values in this
   *      formatter.
   * @see #withLocale(Locale)
   * @since 10
  */
  localizedBy(locale: Locale): DateTimeFormatter;
  /**
   * Gets the DecimalStyle to be used during formatting.
   *
   * @return the DecimalStyle of this formatter, not null
  */
  get decimalStyle(): DecimalStyle;
  /**
   * Returns a copy of this formatter with a new DecimalStyle.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param decimalStyle  the new DecimalStyle, not null
   * @return a formatter based on this formatter with the requested DecimalStyle, not null
  */
  withDecimalStyle(decimalStyle: DecimalStyle): DateTimeFormatter;
  /**
   * Gets the overriding chronology to be used during formatting.
   * 
   * This returns the override chronology, used to convert dates.
   * By default, a formatter has no override chronology, returning null.
   * See {@link #withChronology(Chronology)} for more details on overriding.
   *
   * @return the override chronology of this formatter, null if no override
  */
  get chronology(): Chronology;
  /**
   * Returns a copy of this formatter with a new override chronology.
   * 
   * This returns a formatter with similar state to this formatter but
   * with the override chronology set.
   * By default, a formatter has no override chronology, returning null.
   * 
   * If an override is added, then any date that is formatted or parsed will be affected.
   * 
   * When formatting, if the temporal object contains a date, then it will
   * be converted to a date in the override chronology.
   * Whether the temporal contains a date is determined by querying the
   * {@link ChronoField#EPOCH_DAY EPOCH_DAY} field.
   * Any time or zone will be retained unaltered unless overridden.
   * 
   * If the temporal object does not contain a date, but does contain one
   * or more `ChronoField` date fields, then a `DateTimeException`
   * is thrown. In all other cases, the override chronology is added to the temporal,
   * replacing any previous chronology, but without changing the date/time.
   * 
   * When parsing, there are two distinct cases to consider.
   * If a chronology has been parsed directly from the text, perhaps because
   * {@link DateTimeFormatterBuilder#appendChronologyId()} was used, then
   * this override chronology has no effect.
   * If no zone has been parsed, then this override chronology will be used
   * to interpret the `ChronoField` values into a date according to the
   * date resolving rules of the chronology.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param chrono  the new chronology, null if no override
   * @return a formatter based on this formatter with the requested override chronology, not null
  */
  withChronology(chrono: Chronology): DateTimeFormatter;
  /**
   * Gets the overriding zone to be used during formatting.
   * 
   * This returns the override zone, used to convert instants.
   * By default, a formatter has no override zone, returning null.
   * See {@link #withZone(ZoneId)} for more details on overriding.
   *
   * @return the override zone of this formatter, null if no override
  */
  get zone(): ZoneId;
  /**
   * Returns a copy of this formatter with a new override zone.
   * 
   * This returns a formatter with similar state to this formatter but
   * with the override zone set.
   * By default, a formatter has no override zone, returning null.
   * 
   * If an override is added, then any instant that is formatted or parsed will be affected.
   * 
   * When formatting, if the temporal object contains an instant, then it will
   * be converted to a zoned date-time using the override zone.
   * Whether the temporal is an instant is determined by querying the
   * {@link ChronoField#INSTANT_SECONDS INSTANT_SECONDS} field.
   * If the input has a chronology then it will be retained unless overridden.
   * If the input does not have a chronology, such as `Instant`, then
   * the ISO chronology will be used.
   * 
   * If the temporal object does not contain an instant, but does contain
   * an offset then an additional check is made. If the normalized override
   * zone is an offset that differs from the offset of the temporal, then
   * a `DateTimeException` is thrown. In all other cases, the override
   * zone is added to the temporal, replacing any previous zone, but without
   * changing the date/time.
   * 
   * When parsing, there are two distinct cases to consider.
   * If a zone has been parsed directly from the text, perhaps because
   * {@link DateTimeFormatterBuilder#appendZoneId()} was used, then
   * this override zone has no effect.
   * If no zone has been parsed, then this override zone will be included in
   * the result of the parse where it can be used to build instants and date-times.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param zone  the new override zone, null if no override
   * @return a formatter based on this formatter with the requested override zone, not null
  */
  withZone(zone: ZoneId): DateTimeFormatter;
  /**
   * Gets the resolver style to use during parsing.
   * 
   * This returns the resolver style, used during the second phase of parsing
   * when fields are resolved into dates and times.
   * By default, a formatter has the {@link ResolverStyle#SMART SMART} resolver style.
   * See {@link #withResolverStyle(ResolverStyle)} for more details.
   *
   * @return the resolver style of this formatter, not null
  */
  get resolverStyle(): ResolverStyle;
  /**
   * Returns a copy of this formatter with a new resolver style.
   * 
   * This returns a formatter with similar state to this formatter but
   * with the resolver style set. By default, a formatter has the
   * {@link ResolverStyle#SMART SMART} resolver style.
   * 
   * Changing the resolver style only has an effect during parsing.
   * Parsing a text string occurs in two phases.
   * Phase 1 is a basic text parse according to the fields added to the builder.
   * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
   * The resolver style is used to control how phase 2, resolving, happens.
   * See `ResolverStyle` for more information on the options available.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param resolverStyle  the new resolver style, not null
   * @return a formatter based on this formatter with the requested resolver style, not null
  */
  withResolverStyle(resolverStyle: ResolverStyle): DateTimeFormatter;
  /**
   * Gets the resolver fields to use during parsing.
   * 
   * This returns the resolver fields, used during the second phase of parsing
   * when fields are resolved into dates and times.
   * By default, a formatter has no resolver fields, and thus returns null.
   * See {@link #withResolverFields(Set)} for more details.
   *
   * @return the immutable set of resolver fields of this formatter, null if no fields
  */
  get resolverFields(): Set<TemporalField>;
  /**
   * Returns a copy of this formatter with a new set of resolver fields.
   * 
   * This returns a formatter with similar state to this formatter but with
   * the resolver fields set. By default, a formatter has no resolver fields.
   * 
   * Changing the resolver fields only has an effect during parsing.
   * Parsing a text string occurs in two phases.
   * Phase 1 is a basic text parse according to the fields added to the builder.
   * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
   * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
   * 
   * This can be used to select between two or more ways that a date or time might
   * be resolved. For example, if the formatter consists of year, month, day-of-month
   * and day-of-year, then there are two ways to resolve a date.
   * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
   * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
   * resolved using the year and day-of-year, effectively meaning that the month
   * and day-of-month are ignored during the resolving phase.
   * 
   * In a similar manner, this method can be used to ignore secondary fields that
   * would otherwise be cross-checked. For example, if the formatter consists of year,
   * month, day-of-month and day-of-week, then there is only one way to resolve a
   * date, but the parsed value for day-of-week will be cross-checked against the
   * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
   * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
   * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
   * resolved correctly, but without any cross-check for the day-of-week.
   * 
   * In implementation terms, this method behaves as follows. The result of the
   * parsing phase can be considered to be a map of field to value. The behavior
   * of this method is to cause that map to be filtered between phase 1 and 2,
   * removing all fields other than those specified as arguments to this method.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param resolverFields  the new set of resolver fields, null if no fields
   * @return a formatter based on this formatter with the requested resolver style, not null
  */
  withResolverFields(...resolverFields: TemporalField[]): DateTimeFormatter;
  /**
   * Returns a copy of this formatter with a new set of resolver fields.
   * 
   * This returns a formatter with similar state to this formatter but with
   * the resolver fields set. By default, a formatter has no resolver fields.
   * 
   * Changing the resolver fields only has an effect during parsing.
   * Parsing a text string occurs in two phases.
   * Phase 1 is a basic text parse according to the fields added to the builder.
   * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
   * The resolver fields are used to filter the field-value pairs between phase 1 and 2.
   * 
   * This can be used to select between two or more ways that a date or time might
   * be resolved. For example, if the formatter consists of year, month, day-of-month
   * and day-of-year, then there are two ways to resolve a date.
   * Calling this method with the arguments {@link ChronoField#YEAR YEAR} and
   * {@link ChronoField#DAY_OF_YEAR DAY_OF_YEAR} will ensure that the date is
   * resolved using the year and day-of-year, effectively meaning that the month
   * and day-of-month are ignored during the resolving phase.
   * 
   * In a similar manner, this method can be used to ignore secondary fields that
   * would otherwise be cross-checked. For example, if the formatter consists of year,
   * month, day-of-month and day-of-week, then there is only one way to resolve a
   * date, but the parsed value for day-of-week will be cross-checked against the
   * resolved date. Calling this method with the arguments {@link ChronoField#YEAR YEAR},
   * {@link ChronoField#MONTH_OF_YEAR MONTH_OF_YEAR} and
   * {@link ChronoField#DAY_OF_MONTH DAY_OF_MONTH} will ensure that the date is
   * resolved correctly, but without any cross-check for the day-of-week.
   * 
   * In implementation terms, this method behaves as follows. The result of the
   * parsing phase can be considered to be a map of field to value. The behavior
   * of this method is to cause that map to be filtered between phase 1 and 2,
   * removing all fields other than those specified as arguments to this method.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param resolverFields  the new set of resolver fields, null if no fields
   * @return a formatter based on this formatter with the requested resolver style, not null
  */
  withResolverFields(resolverFields: Set<TemporalField>): DateTimeFormatter;
  /**
   * Formats a date-time object using this formatter.
   * 
   * This formats the date-time to a String using the rules of the formatter.
   *
   * @param temporal  the temporal object to format, not null
   * @return the formatted string, not null
   * @throws DateTimeException if an error occurs during formatting
  */
  format(temporal: TemporalAccessor): string;
  /**
   * Formats a date-time object to an `Appendable` using this formatter.
   * 
   * This outputs the formatted date-time to the specified destination.
   * {@link Appendable} is a general purpose interface that is implemented by all
   * key character output classes including `StringBuffer`, `StringBuilder`,
   * `PrintStream` and `Writer`.
   * 
   * Although `Appendable` methods throw an `IOException`, this method does not.
   * Instead, any `IOException` is wrapped in a runtime exception.
   *
   * @param temporal  the temporal object to format, not null
   * @param appendable  the appendable to format to, not null
   * @throws DateTimeException if an error occurs during formatting
  */
  formatTo(temporal: TemporalAccessor, appendable: Appendable): void;
  /**
   * Fully parses the text producing a temporal object.
   * 
   * This parses the entire text producing a temporal object.
   * It is typically more useful to use {@link #parse(CharSequence, TemporalQuery)}.
   * The result of this method is `TemporalAccessor` which has been resolved,
   * applying basic validation checks to help ensure a valid date-time.
   * 
   * If the parse completes without reading the entire length of the text,
   * or a problem occurs during parsing or merging, then an exception is thrown.
   *
   * @param text  the text to parse, not null
   * @return the parsed temporal object, not null
   * @throws DateTimeParseException if unable to parse the requested result
  */
  parse(text: CharSequence): TemporalAccessor;
  /**
   * Parses the text using this formatter, providing control over the text position.
   * 
   * This parses the text without requiring the parse to start from the beginning
   * of the string or finish at the end.
   * The result of this method is `TemporalAccessor` which has been resolved,
   * applying basic validation checks to help ensure a valid date-time.
   * 
   * The text will be parsed from the specified start `ParsePosition`.
   * The entire length of the text does not have to be parsed, the `ParsePosition`
   * will be updated with the index at the end of parsing.
   * 
   * The operation of this method is slightly different to similar methods using
   * `ParsePosition` on `java.text.Format`. That class will return
   * errors using the error index on the `ParsePosition`. By contrast, this
   * method will throw a {@link DateTimeParseException} if an error occurs, with
   * the exception containing the error index.
   * This change in behavior is necessary due to the increased complexity of
   * parsing and resolving dates/times in this API.
   * 
   * If the formatter parses the same field more than once with different values,
   * the result will be an error.
   *
   * @param text  the text to parse, not null
   * @param position  the position to parse from, updated with length parsed
   *  and the index of any error, not null
   * @return the parsed temporal object, not null
   * @throws DateTimeParseException if unable to parse the requested result
   * @throws IndexOutOfBoundsException if the position is invalid
  */
  parse(text: CharSequence, position: ParsePosition): TemporalAccessor;
  /**
   * Fully parses the text producing an object of the specified type.
   * 
   * Most applications should use this method for parsing.
   * It parses the entire text to produce the required date-time.
   * The query is typically a method reference to a `from(TemporalAccessor)` method.
   * For example:
   *      *  LocalDateTime dt = parser.parse(str, LocalDateTime::from);
   * 
   * If the parse completes without reading the entire length of the text,
   * or a problem occurs during parsing or merging, then an exception is thrown.
   *
   * @param  the type of the parsed date-time
   * @param text  the text to parse, not null
   * @param query  the query defining the type to parse to, not null
   * @return the parsed date-time, not null
   * @throws DateTimeParseException if unable to parse the requested result
  */
  parse<T>(text: CharSequence, query: TemporalQuery<T>): T;
  /**
   * Fully parses the text producing an object of one of the specified types.
   * 
   * This parse method is convenient for use when the parser can handle optional elements.
   * For example, a pattern of 'uuuu-MM-dd HH.mm[ VV]' can be fully parsed to a `ZonedDateTime`,
   * or partially parsed to a `LocalDateTime`.
   * The queries must be specified in order, starting from the best matching full-parse option
   * and ending with the worst matching minimal parse option.
   * The query is typically a method reference to a `from(TemporalAccessor)` method.
   * 
   * The result is associated with the first type that successfully parses.
   * Normally, applications will use `instanceof` to check the result.
   * For example:
   *      *  TemporalAccessor dt = parser.parseBest(str, ZonedDateTime::from, LocalDateTime::from);
   *  if (dt instanceof ZonedDateTime) {
   *   ...
   *  } else {
   *   ...
   *  }
   * 
   * If the parse completes without reading the entire length of the text,
   * or a problem occurs during parsing or merging, then an exception is thrown.
   *
   * @param text  the text to parse, not null
   * @param queries  the queries defining the types to attempt to parse to,
   *  must implement `TemporalAccessor`, not null
   * @return the parsed date-time, not null
   * @throws IllegalArgumentException if less than 2 types are specified
   * @throws DateTimeParseException if unable to parse the requested result
  */
  parseBest(text: CharSequence, ...queries: TemporalQuery[]): TemporalAccessor;
  /**
   * Parses the text using this formatter, without resolving the result, intended
   * for advanced use cases.
   * 
   * Parsing is implemented as a two-phase operation.
   * First, the text is parsed using the layout defined by the formatter, producing
   * a `Map` of field to value, a `ZoneId` and a `Chronology`.
   * Second, the parsed data is resolved, by validating, combining and
   * simplifying the various fields into more useful ones.
   * This method performs the parsing stage but not the resolving stage.
   * 
   * The result of this method is `TemporalAccessor` which represents the
   * data as seen in the input. Values are not validated, thus parsing a date string
   * of '2012-00-65' would result in a temporal with three fields - year of '2012',
   * month of '0' and day-of-month of '65'.
   * 
   * The text will be parsed from the specified start `ParsePosition`.
   * The entire length of the text does not have to be parsed, the `ParsePosition`
   * will be updated with the index at the end of parsing.
   * 
   * Errors are returned using the error index field of the `ParsePosition`
   * instead of `DateTimeParseException`.
   * The returned error index will be set to an index indicative of the error.
   * Callers must check for errors before using the result.
   * 
   * If the formatter parses the same field more than once with different values,
   * the result will be an error.
   * 
   * This method is intended for advanced use cases that need access to the
   * internal state during parsing. Typical application code should use
   * {@link #parse(CharSequence, TemporalQuery)} or the parse method on the target type.
   *
   * @param text  the text to parse, not null
   * @param position  the position to parse from, updated with length parsed
   *  and the index of any error, not null
   * @return the parsed text, null if the parse results in an error
   * @throws DateTimeException if some problem occurs during parsing
   * @throws IndexOutOfBoundsException if the position is invalid
  */
  parseUnresolved(text: CharSequence, position: ParsePosition): TemporalAccessor;
  /**
   * Returns this formatter as a `java.text.Format` instance.
   * 
   * The returned {@link Format} instance will format any {@link TemporalAccessor}
   * and parses to a resolved {@link TemporalAccessor}.
   * 
   * Exceptions will follow the definitions of `Format`, see those methods
   * for details about `IllegalArgumentException` during formatting and
   * `ParseException` or null during parsing.
   * The format does not support attributing of the returned format string.
   *
   * @return this formatter as a classic format instance, not null
  */
  toFormat(): Format;
  /**
   * Returns this formatter as a `java.text.Format` instance that will
   * parse using the specified query.
   * 
   * The returned {@link Format} instance will format any {@link TemporalAccessor}
   * and parses to the type specified.
   * The type must be one that is supported by {@link #parse}.
   * 
   * Exceptions will follow the definitions of `Format`, see those methods
   * for details about `IllegalArgumentException` during formatting and
   * `ParseException` or null during parsing.
   * The format does not support attributing of the returned format string.
   *
   * @param parseQuery  the query defining the type to parse to, not null
   * @return this formatter as a classic format instance, not null
  */
  toFormat(parseQuery: TemporalQuery<any>): Format;
  /**
   * Returns a description of the underlying formatters.
   *
   * @return a description of this formatter, not null
  */
  toString(): string;
}
/**
 * Enumeration of the style of a localized date, time or date-time formatter.
 * 
 * These styles are used when obtaining a date-time style from configuration.
 * See {@link DateTimeFormatter} and {@link DateTimeFormatterBuilder} for usage.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class FormatStyle extends Enum<FormatStyle> {
  /**
   * Full text style, with the most detail.
   * For example, the format might be 'Tuesday, April 12, 1952 AD' or '3:30:42pm PST'.
  */
  static readonly FULL: FormatStyle;
  /**
   * Long text style, with lots of detail.
   * For example, the format might be 'January 12, 1952'.
  */
  static readonly LONG: FormatStyle;
  /**
   * Medium text style, with some detail.
   * For example, the format might be 'Jan 12, 1952'.
  */
  static readonly MEDIUM: FormatStyle;
  /**
   * Short text style, typically numeric.
   * For example, the format might be '12.13.52' or '3:30pm'.
  */
  static readonly SHORT: FormatStyle;
  static valueOf(name: string): FormatStyle;
  static values(): FormatStyle[];
}
/**
 * An exception thrown when an error occurs during parsing.
 * 
 * This exception includes the text being parsed and the error index.
 *
 * @implSpec
 * This class is intended for use in a single thread.
 *
 * @since 1.8
*/
export class DateTimeParseException extends DateTimeException {
  /**
   * Constructs a new exception with the specified message.
   *
   * @param message  the message to use for this exception, may be null
   * @param parsedData  the parsed text, should not be null
   * @param errorIndex  the index in the parsed string that was invalid, should be a valid index
  */
  constructor(message: string, parsedData: CharSequence, errorIndex: number);
  /**
   * Constructs a new exception with the specified message and cause.
   *
   * @param message  the message to use for this exception, may be null
   * @param parsedData  the parsed text, should not be null
   * @param errorIndex  the index in the parsed string that was invalid, should be a valid index
   * @param cause  the cause exception, may be null
  */
  constructor(message: string, parsedData: CharSequence, errorIndex: number, cause: Throwable);
  /**
   * Returns the string that was being parsed.
   *
   * @return the string that was being parsed, should not be null.
  */
  get parsedString(): string;
  /**
   * Returns the index where the error was found.
   *
   * @return the index in the parsed string that was invalid, should be a valid index
  */
  get errorIndex(): number;
}
/**
 * Enumeration of different ways to resolve dates and times.
 * 
 * Parsing a text string occurs in two phases.
 * Phase 1 is a basic text parse according to the fields added to the builder.
 * Phase 2 resolves the parsed field-value pairs into date and/or time objects.
 * This style is used to control how phase 2, resolving, happens.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class ResolverStyle extends Enum<ResolverStyle> {
  /**
   * Style to resolve dates and times strictly.
   * 
   * Using strict resolution will ensure that all parsed values are within
   * the outer range of valid values for the field. Individual fields may
   * be further processed for strictness.
   * 
   * For example, resolving year-month and day-of-month in the ISO calendar
   * system using strict mode will ensure that the day-of-month is valid
   * for the year-month, rejecting invalid values.
  */
  static readonly STRICT: ResolverStyle;
  /**
   * Style to resolve dates and times in a smart, or intelligent, manner.
   * 
   * Using smart resolution will perform the sensible default for each
   * field, which may be the same as strict, the same as lenient, or a third
   * behavior. Individual fields will interpret this differently.
   * 
   * For example, resolving year-month and day-of-month in the ISO calendar
   * system using smart mode will ensure that the day-of-month is from
   * 1 to 31, converting any value beyond the last valid day-of-month to be
   * the last valid day-of-month.
  */
  static readonly SMART: ResolverStyle;
  /**
   * Style to resolve dates and times leniently.
   * 
   * Using lenient resolution will resolve the values in an appropriate
   * lenient manner. Individual fields will interpret this differently.
   * 
   * For example, lenient mode allows the month in the ISO calendar system
   * to be outside the range 1 to 12.
   * For example, month 15 is treated as being 3 months after month 12.
  */
  static readonly LENIENT: ResolverStyle;
  static valueOf(name: string): ResolverStyle;
  static values(): ResolverStyle[];
}
/**
 * Localized decimal style used in date and time formatting.
 * 
 * A significant part of dealing with dates and times is the localization.
 * This class acts as a central point for accessing the information.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class DecimalStyle {
  /**
   * The standard set of non-localized decimal style symbols.
   * 
   * This uses standard ASCII characters for zero, positive, negative and a dot for the decimal point.
  */
  static readonly STANDARD: DecimalStyle;
  /**
   * Lists all the locales that are supported.
   * 
   * At a minimum, the returned `Set` must contain a `Locale` instance equal to
   * {@link Locale#ROOT Locale.ROOT} and a `Locale` instance equal to
   * {@link Locale#US Locale.US}.
   *
   * @return a Set of Locales for which localization is supported
  */
  static get availableLocales(): Set<Locale>;
  /**
   * Obtains the DecimalStyle for the default
   * {@link java.util.Locale.Category#FORMAT FORMAT} locale.
   * 
   * This method provides access to locale sensitive decimal style symbols.
   * 
   * This is equivalent to calling
   * {@link #of(Locale)
   *     of(Locale.getDefault(Locale.Category.FORMAT))}.
   *
   * @see java.util.Locale.Category#FORMAT
   * @return the decimal style, not null
  */
  static ofDefaultLocale(): DecimalStyle;
  /**
   * Obtains the DecimalStyle for the specified locale.
   * 
   * This method provides access to locale sensitive decimal style symbols.
   * If the locale contains "nu" (Numbering System) and/or "rg"
   * (Region Override) 
   * Unicode extensions, returned instance will reflect the values specified with
   * those extensions. If both "nu" and "rg" are specified, the value from
   * the "nu" extension supersedes the implicit one from the "rg" extension.
   *
   * @param locale  the locale, not null
   * @return the decimal style, not null
  */
  static of(locale: Locale): DecimalStyle;
  /**
   * Gets the character that represents zero.
   * 
   * The character used to represent digits may vary by culture.
   * This method specifies the zero character to use, which implies the characters for one to nine.
   *
   * @return the character for zero
  */
  get zeroDigit(): string;
  /**
   * Returns a copy of the info with a new character that represents zero.
   * 
   * The character used to represent digits may vary by culture.
   * This method specifies the zero character to use, which implies the characters for one to nine.
   *
   * @param zeroDigit  the character for zero
   * @return  a copy with a new character that represents zero, not null
  */
  withZeroDigit(zeroDigit: string): DecimalStyle;
  /**
   * Gets the character that represents the positive sign.
   * 
   * The character used to represent a positive number may vary by culture.
   * This method specifies the character to use.
   *
   * @return the character for the positive sign
  */
  get positiveSign(): string;
  /**
   * Returns a copy of the info with a new character that represents the positive sign.
   * 
   * The character used to represent a positive number may vary by culture.
   * This method specifies the character to use.
   *
   * @param positiveSign  the character for the positive sign
   * @return  a copy with a new character that represents the positive sign, not null
  */
  withPositiveSign(positiveSign: string): DecimalStyle;
  /**
   * Gets the character that represents the negative sign.
   * 
   * The character used to represent a negative number may vary by culture.
   * This method specifies the character to use.
   *
   * @return the character for the negative sign
  */
  get negativeSign(): string;
  /**
   * Returns a copy of the info with a new character that represents the negative sign.
   * 
   * The character used to represent a negative number may vary by culture.
   * This method specifies the character to use.
   *
   * @param negativeSign  the character for the negative sign
   * @return  a copy with a new character that represents the negative sign, not null
  */
  withNegativeSign(negativeSign: string): DecimalStyle;
  /**
   * Gets the character that represents the decimal point.
   * 
   * The character used to represent a decimal point may vary by culture.
   * This method specifies the character to use.
   *
   * @return the character for the decimal point
  */
  get decimalSeparator(): string;
  /**
   * Returns a copy of the info with a new character that represents the decimal point.
   * 
   * The character used to represent a decimal point may vary by culture.
   * This method specifies the character to use.
   *
   * @param decimalSeparator  the character for the decimal point
   * @return  a copy with a new character that represents the decimal point, not null
  */
  withDecimalSeparator(decimalSeparator: string): DecimalStyle;
  /**
   * Checks if this DecimalStyle is equal to another DecimalStyle.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this DecimalStyle.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Returns a string describing this DecimalStyle.
   *
   * @return a string description, not null
  */
  toString(): string;
}

}
declare module 'java.time.temporal' {
import { DayOfWeek, DateTimeException, LocalTime, ZoneId, Duration, LocalDate, ZoneOffset } from 'java.time';
import { Locale, List, Map } from 'java.util';
import { Enum, Throwable } from 'java.lang';
import { ResolverStyle } from 'java.time.format';
import { Serializable } from 'java.io';
import { Chronology } from 'java.time.chrono';
import { ConcurrentMap } from 'java.util.concurrent';
import { UnaryOperator } from 'java.util.function';
/**
 * A field of date-time, such as month-of-year or minute-of-hour.
 * 
 * Date and time is expressed using fields which partition the time-line into something
 * meaningful for humans. Implementations of this interface represent those fields.
 * 
 * The most commonly used units are defined in {@link ChronoField}.
 * Further fields are supplied in {@link IsoFields}, {@link WeekFields} and {@link JulianFields}.
 * Fields can also be written by application code by implementing this interface.
 * 
 * The field works using double dispatch. Client code calls methods on a date-time like
 * `LocalDateTime` which check if the field is a `ChronoField`.
 * If it is, then the date-time must handle it.
 * Otherwise, the method call is re-dispatched to the matching method in this interface.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Implementations should be `Serializable` where possible.
 * An enum is as effective implementation choice.
 *
 * @since 1.8
*/
export class TemporalField {
  /**
   * Gets the display name for the field in the requested locale.
   * 
   * If there is no display name for the locale then a suitable default must be returned.
   * 
   * The default implementation must check the locale is not null
   * and return `toString()`.
   *
   * @param locale  the locale to use, not null
   * @return the display name for the locale or a suitable default, not null
  */
  getDisplayName(locale: Locale): string;
  /**
   * Gets the unit that the field is measured in.
   * 
   * The unit of the field is the period that varies within the range.
   * For example, in the field 'MonthOfYear', the unit is 'Months'.
   * See also {@link #getRangeUnit()}.
   *
   * @return the unit defining the base unit of the field, not null
  */
  get baseUnit(): TemporalUnit;
  /**
   * Gets the range that the field is bound by.
   * 
   * The range of the field is the period that the field varies within.
   * For example, in the field 'MonthOfYear', the range is 'Years'.
   * See also {@link #getBaseUnit()}.
   * 
   * The range is never null. For example, the 'Year' field is shorthand for
   * 'YearOfForever'. It therefore has a unit of 'Years' and a range of 'Forever'.
   *
   * @return the unit defining the range of the field, not null
  */
  get rangeUnit(): TemporalUnit;
  /**
   * Gets the range of valid values for the field.
   * 
   * All fields can be expressed as a `long` integer.
   * This method returns an object that describes the valid range for that value.
   * This method is generally only applicable to the ISO-8601 calendar system.
   * 
   * Note that the result only describes the minimum and maximum valid values
   * and it is important not to read too much into them. For example, there
   * could be values within the range that are invalid for the field.
   *
   * @return the range of valid values for the field, not null
  */
  range(): ValueRange;
  /**
   * Checks if this field represents a component of a date.
   * 
   * A field is date-based if it can be derived from
   * {@link ChronoField#EPOCH_DAY EPOCH_DAY}.
   * Note that it is valid for both `isDateBased()` and `isTimeBased()`
   * to return false, such as when representing a field like minute-of-week.
   *
   * @return true if this field is a component of a date
  */
  isDateBased(): boolean;
  /**
   * Checks if this field represents a component of a time.
   * 
   * A field is time-based if it can be derived from
   * {@link ChronoField#NANO_OF_DAY NANO_OF_DAY}.
   * Note that it is valid for both `isDateBased()` and `isTimeBased()`
   * to return false, such as when representing a field like minute-of-week.
   *
   * @return true if this field is a component of a time
  */
  isTimeBased(): boolean;
  /**
   * Checks if this field is supported by the temporal object.
   * 
   * This determines whether the temporal accessor supports this field.
   * If this returns false, then the temporal cannot be queried for this field.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link TemporalAccessor#isSupported(TemporalField)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisField.isSupportedBy(temporal);
   *   temporal = temporal.isSupported(thisField);
   * 
   * It is recommended to use the second approach, `isSupported(TemporalField)`,
   * as it is a lot clearer to read in code.
   * 
   * Implementations should determine whether they are supported using the fields
   * available in {@link ChronoField}.
   *
   * @param temporal  the temporal object to query, not null
   * @return true if the date-time can be queried for this field, false if not
  */
  isSupportedBy(temporal: TemporalAccessor): boolean;
  /**
   * Get the range of valid values for this field using the temporal object to
   * refine the result.
   * 
   * This uses the temporal object to find the range of valid values for the field.
   * This is similar to {@link #range()}, however this method refines the result
   * using the temporal. For example, if the field is `DAY_OF_MONTH` the
   * `range` method is not accurate as there are four possible month lengths,
   * 28, 29, 30 and 31 days. Using this method with a date allows the range to be
   * accurate, returning just one of those four options.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link TemporalAccessor#range(TemporalField)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisField.rangeRefinedBy(temporal);
   *   temporal = temporal.range(thisField);
   * 
   * It is recommended to use the second approach, `range(TemporalField)`,
   * as it is a lot clearer to read in code.
   * 
   * Implementations should perform any queries or calculations using the fields
   * available in {@link ChronoField}.
   * If the field is not supported an `UnsupportedTemporalTypeException` must be thrown.
   *
   * @param temporal  the temporal object used to refine the result, not null
   * @return the range of valid values for this field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported by the temporal
  */
  rangeRefinedBy(temporal: TemporalAccessor): ValueRange;
  /**
   * Gets the value of this field from the specified temporal object.
   * 
   * This queries the temporal object for the value of this field.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link TemporalAccessor#getLong(TemporalField)}
   * (or {@link TemporalAccessor#get(TemporalField)}):
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisField.getFrom(temporal);
   *   temporal = temporal.getLong(thisField);
   * 
   * It is recommended to use the second approach, `getLong(TemporalField)`,
   * as it is a lot clearer to read in code.
   * 
   * Implementations should perform any queries or calculations using the fields
   * available in {@link ChronoField}.
   * If the field is not supported an `UnsupportedTemporalTypeException` must be thrown.
   *
   * @param temporal  the temporal object to query, not null
   * @return the value of this field, not null
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported by the temporal
   * @throws ArithmeticException if numeric overflow occurs
  */
  getFrom(temporal: TemporalAccessor): number;
  /**
   * Returns a copy of the specified temporal object with the value of this field set.
   * 
   * This returns a new temporal object based on the specified one with the value for
   * this field changed. For example, on a `LocalDate`, this could be used to
   * set the year, month or day-of-month.
   * The returned object has the same observable type as the specified object.
   * 
   * In some cases, changing a field is not fully defined. For example, if the target object is
   * a date representing the 31st January, then changing the month to February would be unclear.
   * In cases like this, the implementation is responsible for resolving the result.
   * Typically it will choose the previous valid date, which would be the last valid
   * day of February in this example.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#with(TemporalField, long)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisField.adjustInto(temporal);
   *   temporal = temporal.with(thisField);
   * 
   * It is recommended to use the second approach, `with(TemporalField)`,
   * as it is a lot clearer to read in code.
   * 
   * Implementations should perform any queries or calculations using the fields
   * available in {@link ChronoField}.
   * If the field is not supported an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * Implementations must not alter the specified temporal object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   *
   * @param   the type of the Temporal object
   * @param temporal the temporal object to adjust, not null
   * @param newValue the new value of the field
   * @return the adjusted temporal object, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported by the temporal
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto<R>(temporal: R, newValue: number): R;
  /**
   * Resolves this field to provide a simpler alternative or a date.
   * 
   * This method is invoked during the resolve phase of parsing.
   * It is designed to allow application defined fields to be simplified into
   * more standard fields, such as those on `ChronoField`, or into a date.
   * 
   * Applications should not normally invoke this method directly.
   *
   * @implSpec
   * If an implementation represents a field that can be simplified, or
   * combined with others, then this method must be implemented.
   * 
   * The specified map contains the current state of the parse.
   * The map is mutable and must be mutated to resolve the field and
   * any related fields. This method will only be invoked during parsing
   * if the map contains this field, and implementations should therefore
   * assume this field is present.
   * 
   * Resolving a field will consist of looking at the value of this field,
   * and potentially other fields, and either updating the map with a
   * simpler value, such as a `ChronoField`, or returning a
   * complete `ChronoLocalDate`. If a resolve is successful,
   * the code must remove all the fields that were resolved from the map,
   * including this field.
   * 
   * For example, the `IsoFields` class contains the quarter-of-year
   * and day-of-quarter fields. The implementation of this method in that class
   * resolves the two fields plus the {@link ChronoField#YEAR YEAR} into a
   * complete `LocalDate`. The resolve method will remove all three
   * fields from the map before returning the `LocalDate`.
   * 
   * A partially complete temporal is used to allow the chronology and zone
   * to be queried. In general, only the chronology will be needed.
   * Querying items other than the zone or chronology is undefined and
   * must not be relied on.
   * The behavior of other methods such as `get`, `getLong`,
   * `range` and `isSupported` is unpredictable and the results undefined.
   * 
   * If resolution should be possible, but the data is invalid, the resolver
   * style should be used to determine an appropriate level of leniency, which
   * may require throwing a `DateTimeException` or `ArithmeticException`.
   * If no resolution is possible, the resolve method must return null.
   * 
   * When resolving time fields, the map will be altered and null returned.
   * When resolving date fields, the date is normally returned from the method,
   * with the map altered to remove the resolved fields. However, it would also
   * be acceptable for the date fields to be resolved into other `ChronoField`
   * instances that can produce a date, such as `EPOCH_DAY`.
   * 
   * Not all `TemporalAccessor` implementations are accepted as return values.
   * Implementations that call this method must accept `ChronoLocalDate`,
   * `ChronoLocalDateTime`, `ChronoZonedDateTime` and `LocalTime`.
   * 
   * The default implementation must return null.
   *
   * @param fieldValues  the map of fields to values, which can be updated, not null
   * @param partialTemporal  the partially complete temporal to query for zone and
   *  chronology; querying for other things is undefined and not recommended, not null
   * @param resolverStyle  the requested type of resolve, not null
   * @return the resolved temporal object; null if resolving only
   *  changed the map, or no resolve occurred
   * @throws ArithmeticException if numeric overflow occurs
   * @throws DateTimeException if resolving results in an error. This must not be thrown
   *  by querying a field on the temporal without first checking if it is supported
  */
  resolve(fieldValues: Map<TemporalField,number>, partialTemporal: TemporalAccessor, resolverStyle: ResolverStyle): TemporalAccessor;
  /**
   * Gets a descriptive name for the field.
   * 
   * The should be of the format 'BaseOfRange', such as 'MonthOfYear',
   * unless the field has a range of `FOREVER`, when only
   * the base unit is mentioned, such as 'Year' or 'Era'.
   *
   * @return the name of the field, not null
  */
  toString(): string;
}
/**
 * Framework-level interface defining read-only access to a temporal object,
 * such as a date, time, offset or some combination of these.
 * 
 * This is the base interface type for date, time and offset objects.
 * It is implemented by those classes that can provide information
 * as {@linkplain TemporalField fields} or {@linkplain TemporalQuery queries}.
 * 
 * Most date and time information can be represented as a number.
 * These are modeled using `TemporalField` with the number held using
 * a `long` to handle large values. Year, month and day-of-month are
 * simple examples of fields, but they also include instant and offsets.
 * See {@link ChronoField} for the standard set of fields.
 * 
 * Two pieces of date/time information cannot be represented by numbers,
 * the {@linkplain java.time.chrono.Chronology chronology} and the
 * {@linkplain java.time.ZoneId time-zone}.
 * These can be accessed via {@linkplain #query(TemporalQuery) queries} using
 * the static methods defined on {@link TemporalQuery}.
 * 
 * A sub-interface, {@link Temporal}, extends this definition to one that also
 * supports adjustment and manipulation on more complete temporal objects.
 * 
 * This interface is a framework-level interface that should not be widely
 * used in application code. Instead, applications should create and pass
 * around instances of concrete types, such as `LocalDate`.
 * There are many reasons for this, part of which is that implementations
 * of this interface may be in calendar systems other than ISO.
 * See {@link java.time.chrono.ChronoLocalDate} for a fuller discussion of the issues.
 *
 * @implSpec
 * This interface places no restrictions on the mutability of implementations,
 * however immutability is strongly recommended.
 *
 * @since 1.8
*/
export class TemporalAccessor {
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if the date-time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and {@link #get(TemporalField) get}
   * methods will throw an exception.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported, then true must be returned, otherwise false must be returned.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param field  the field to check, null returns false
   * @return true if this date-time can be queried for the field, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * All fields can be expressed as a `long` integer.
   * This method returns an object that describes the valid range for that value.
   * The value of this temporal object is used to enhance the accuracy of the returned range.
   * If the date-time cannot return the range, because the field is unsupported or for
   * some other reason, an exception will be thrown.
   * 
   * Note that the result only describes the minimum and maximum valid values
   * and it is important not to read too much into them. For example, there
   * could be values within the range that are invalid for the field.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported, then the range of the field must be returned.
   * If unsupported, then an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  if (field instanceof ChronoField) {
   *    if (isSupported(field)) {
   *      return field.range();
   *    }
   *    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
   *  }
   *  return field.rangeRefinedBy(this);
   * 
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field as an `int`.
   * 
   * This queries the date-time for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If the date-time cannot return the value, because the field is unsupported or for
   * some other reason, an exception will be thrown.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported and has an `int` range, then the value of
   * the field must be returned.
   * If unsupported, then an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  if (range(field).isIntValue()) {
   *    return range(field).checkValidIntValue(getLong(field), field);
   *  }
   *  throw new UnsupportedTemporalTypeException("Invalid field " + field + " + for get() method, use getLong() instead");
   * 
   *
   * @param field  the field to get, not null
   * @return the value for the field, within the valid range of values
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field as a `long`.
   * 
   * This queries the date-time for the value of the specified field.
   * The returned value may be outside the valid range of values for the field.
   * If the date-time cannot return the value, because the field is unsupported or for
   * some other reason, an exception will be thrown.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported, then the value of the field must be returned.
   * If unsupported, then an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Queries this date-time.
   * 
   * This queries this date-time using the specified query strategy object.
   * 
   * Queries are a key tool for extracting information from date-times.
   * They exists to externalize the process of querying, permitting different
   * approaches, as per the strategy design pattern.
   * Examples might be a query that checks if the date is the day before February 29th
   * in a leap year, or calculates the number of days to your next birthday.
   * 
   * The most common query implementations are method references, such as
   * `LocalDate::from` and `ZoneId::from`.
   * Additional implementations are provided as static methods on {@link TemporalQuery}.
   *
   * @implSpec
   * The default implementation must behave equivalent to this code:
   *      *  if (query == TemporalQueries.zoneId() ||
   *        query == TemporalQueries.chronology() || query == TemporalQueries.precision()) {
   *    return null;
   *  }
   *  return query.queryFrom(this);
   * 
   * Future versions are permitted to add further queries to the if statement.
   * 
   * All classes implementing this interface and overriding this method must call
   * `TemporalAccessor.super.query(query)`. JDK classes may avoid calling
   * super if they provide behavior equivalent to the default behaviour, however
   * non-JDK classes may not utilize this optimization and must call `super`.
   * 
   * If the implementation can supply a value for one of the queries listed in the
   * if statement of the default implementation, then it must do so.
   * For example, an application-defined `HourMin` class storing the hour
   * and minute must override this method as follows:
   *      *  if (query == TemporalQueries.precision()) {
   *    return MINUTES;
   *  }
   *  return TemporalAccessor.super.query(query);
   * 
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query
   * @throws ArithmeticException if numeric overflow occurs
  */
  query<R>(query: TemporalQuery<R>): R;
}
/**
 * UnsupportedTemporalTypeException indicates that a ChronoField or ChronoUnit is
 * not supported for a Temporal class.
 *
 * @implSpec
 * This class is intended for use in a single thread.
 *
 * @since 1.8
*/
export class UnsupportedTemporalTypeException extends DateTimeException {
  /**
   * Constructs a new UnsupportedTemporalTypeException with the specified message.
   *
   * @param message  the message to use for this exception, may be null
  */
  constructor(message: string);
  /**
   * Constructs a new UnsupportedTemporalTypeException with the specified message and cause.
   *
   * @param message  the message to use for this exception, may be null
   * @param cause  the cause of the exception, may be null
  */
  constructor(message: string, cause: Throwable);
}
/**
 * A unit of date-time, such as Days or Hours.
 * 
 * Measurement of time is built on units, such as years, months, days, hours, minutes and seconds.
 * Implementations of this interface represent those units.
 * 
 * An instance of this interface represents the unit itself, rather than an amount of the unit.
 * See {@link Period} for a class that represents an amount in terms of the common units.
 * 
 * The most commonly used units are defined in {@link ChronoUnit}.
 * Further units are supplied in {@link IsoFields}.
 * Units can also be written by application code by implementing this interface.
 * 
 * The unit works using double dispatch. Client code calls methods on a date-time like
 * `LocalDateTime` which check if the unit is a `ChronoUnit`.
 * If it is, then the date-time must handle it.
 * Otherwise, the method call is re-dispatched to the matching method in this interface.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * It is recommended to use an enum where possible.
 *
 * @since 1.8
*/
export class TemporalUnit {
  /**
   * Gets the duration of this unit, which may be an estimate.
   * 
   * All units return a duration measured in standard nanoseconds from this method.
   * The duration will be positive and non-zero.
   * For example, an hour has a duration of `60 * 60 * 1,000,000,000ns`.
   * 
   * Some units may return an accurate duration while others return an estimate.
   * For example, days have an estimated duration due to the possibility of
   * daylight saving time changes.
   * To determine if the duration is an estimate, use {@link #isDurationEstimated()}.
   *
   * @return the duration of this unit, which may be an estimate, not null
  */
  get duration(): Duration;
  /**
   * Checks if the duration of the unit is an estimate.
   * 
   * All units have a duration, however the duration is not always accurate.
   * For example, days have an estimated duration due to the possibility of
   * daylight saving time changes.
   * This method returns true if the duration is an estimate and false if it is
   * accurate. Note that accurate/estimated ignores leap seconds.
   *
   * @return true if the duration is estimated, false if accurate
  */
  isDurationEstimated(): boolean;
  /**
   * Checks if this unit represents a component of a date.
   * 
   * A date is time-based if it can be used to imply meaning from a date.
   * It must have a {@linkplain #getDuration() duration} that is an integral
   * multiple of the length of a standard day.
   * Note that it is valid for both `isDateBased()` and `isTimeBased()`
   * to return false, such as when representing a unit like 36 hours.
   *
   * @return true if this unit is a component of a date
  */
  isDateBased(): boolean;
  /**
   * Checks if this unit represents a component of a time.
   * 
   * A unit is time-based if it can be used to imply meaning from a time.
   * It must have a {@linkplain #getDuration() duration} that divides into
   * the length of a standard day without remainder.
   * Note that it is valid for both `isDateBased()` and `isTimeBased()`
   * to return false, such as when representing a unit like 36 hours.
   *
   * @return true if this unit is a component of a time
  */
  isTimeBased(): boolean;
  /**
   * Checks if this unit is supported by the specified temporal object.
   * 
   * This checks that the implementing date-time can add/subtract this unit.
   * This can be used to avoid throwing an exception.
   * 
   * This default implementation derives the value using
   * {@link Temporal#plus(long, TemporalUnit)}.
   *
   * @param temporal  the temporal object to check, not null
   * @return true if the unit is supported
  */
  isSupportedBy(temporal: Temporal): boolean;
  /**
   * Returns a copy of the specified temporal object with the specified period added.
   * 
   * The period added is a multiple of this unit. For example, this method
   * could be used to add "3 days" to a date by calling this method on the
   * instance representing "days", passing the date and the period "3".
   * The period to be added may be negative, which is equivalent to subtraction.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#plus(long, TemporalUnit)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisUnit.addTo(temporal);
   *   temporal = temporal.plus(thisUnit);
   * 
   * It is recommended to use the second approach, `plus(TemporalUnit)`,
   * as it is a lot clearer to read in code.
   * 
   * Implementations should perform any queries or calculations using the units
   * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.
   * If the unit is not supported an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * Implementations must not alter the specified temporal object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   *
   * @param   the type of the Temporal object
   * @param temporal  the temporal object to adjust, not null
   * @param amount  the amount of this unit to add, positive or negative
   * @return the adjusted temporal object, not null
   * @throws DateTimeException if the amount cannot be added
   * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal
  */
  addTo<R>(temporal: R, amount: number): R;
  /**
   * Calculates the amount of time between two temporal objects.
   * 
   * This calculates the amount in terms of this unit. The start and end
   * points are supplied as temporal objects and must be of compatible types.
   * The implementation will convert the second type to be an instance of the
   * first type before the calculating the amount.
   * The result will be negative if the end is before the start.
   * For example, the amount in hours between two temporal objects can be
   * calculated using `HOURS.between(startTime, endTime)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two temporals.
   * For example, the amount in hours between the times 11:30 and 13:29
   * will only be one hour as it is one minute short of two hours.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#until(Temporal, TemporalUnit)}:
   *      *   // these two lines are equivalent
   *   between = thisUnit.between(start, end);
   *   between = start.until(end, thisUnit);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * For example, this method allows the number of days between two dates to
   * be calculated:
   *      *  long daysBetween = DAYS.between(start, end);
   *  // or alternatively
   *  long daysBetween = start.until(end, DAYS);
   * 
   * 
   * Implementations should perform any queries or calculations using the units
   * available in {@link ChronoUnit} or the fields available in {@link ChronoField}.
   * If the unit is not supported an `UnsupportedTemporalTypeException` must be thrown.
   * Implementations must not alter the specified temporal objects.
   *
   * @implSpec
   * Implementations must begin by checking to if the two temporals have the
   * same type using `getClass()`. If they do not, then the result must be
   * obtained by calling `temporal1Inclusive.until(temporal2Exclusive, this)`.
   *
   * @param temporal1Inclusive  the base temporal object, not null
   * @param temporal2Exclusive  the other temporal object, exclusive, not null
   * @return the amount of time between temporal1Inclusive and temporal2Exclusive
   *  in terms of this unit; positive if temporal2Exclusive is later than
   *  temporal1Inclusive, negative if earlier
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to the same type as the start temporal
   * @throws UnsupportedTemporalTypeException if the unit is not supported by the temporal
   * @throws ArithmeticException if numeric overflow occurs
  */
  between(temporal1Inclusive: Temporal, temporal2Exclusive: Temporal): number;
  /**
   * Gets a descriptive name for the unit.
   * 
   * This should be in the plural and upper-first camel case, such as 'Days' or 'Minutes'.
   *
   * @return the name of this unit, not null
  */
  toString(): string;
}
/**
 * A standard set of date periods units.
 * 
 * This set of units provide unit-based access to manipulate a date, time or date-time.
 * The standard set of units can be extended by implementing {@link TemporalUnit}.
 * 
 * These units are intended to be applicable in multiple calendar systems.
 * For example, most non-ISO calendar systems define units of years, months and days,
 * just with slightly different rules.
 * The documentation of each unit explains how it operates.
 *
 * @implSpec
 * This is a final, immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class ChronoUnit extends Enum<ChronoUnit> {
  /**
   * Unit that represents the concept of a nanosecond, the smallest supported unit of time.
   * For the ISO calendar system, it is equal to the 1,000,000,000th part of the second unit.
  */
  static readonly NANOS: ChronoUnit;
  /**
   * Unit that represents the concept of a microsecond.
   * For the ISO calendar system, it is equal to the 1,000,000th part of the second unit.
  */
  static readonly MICROS: ChronoUnit;
  /**
   * Unit that represents the concept of a millisecond.
   * For the ISO calendar system, it is equal to the 1000th part of the second unit.
  */
  static readonly MILLIS: ChronoUnit;
  /**
   * Unit that represents the concept of a second.
   * For the ISO calendar system, it is equal to the second in the SI system
   * of units, except around a leap-second.
  */
  static readonly SECONDS: ChronoUnit;
  /**
   * Unit that represents the concept of a minute.
   * For the ISO calendar system, it is equal to 60 seconds.
  */
  static readonly MINUTES: ChronoUnit;
  /**
   * Unit that represents the concept of an hour.
   * For the ISO calendar system, it is equal to 60 minutes.
  */
  static readonly HOURS: ChronoUnit;
  /**
   * Unit that represents the concept of half a day, as used in AM/PM.
   * For the ISO calendar system, it is equal to 12 hours.
  */
  static readonly HALF_DAYS: ChronoUnit;
  /**
   * Unit that represents the concept of a day.
   * For the ISO calendar system, it is the standard day from midnight to midnight.
   * The estimated duration of a day is `24 Hours`.
   * 
   * When used with other calendar systems it must correspond to the day defined by
   * the rising and setting of the Sun on Earth. It is not required that days begin
   * at midnight - when converting between calendar systems, the date should be
   * equivalent at midday.
  */
  static readonly DAYS: ChronoUnit;
  /**
   * Unit that represents the concept of a week.
   * For the ISO calendar system, it is equal to 7 days.
   * 
   * When used with other calendar systems it must correspond to an integral number of days.
  */
  static readonly WEEKS: ChronoUnit;
  /**
   * Unit that represents the concept of a month.
   * For the ISO calendar system, the length of the month varies by month-of-year.
   * The estimated duration of a month is one twelfth of `365.2425 Days`.
   * 
   * When used with other calendar systems it must correspond to an integral number of days.
  */
  static readonly MONTHS: ChronoUnit;
  /**
   * Unit that represents the concept of a year.
   * For the ISO calendar system, it is equal to 12 months.
   * The estimated duration of a year is `365.2425 Days`.
   * 
   * When used with other calendar systems it must correspond to an integral number of days
   * or months roughly equal to a year defined by the passage of the Earth around the Sun.
  */
  static readonly YEARS: ChronoUnit;
  /**
   * Unit that represents the concept of a decade.
   * For the ISO calendar system, it is equal to 10 years.
   * 
   * When used with other calendar systems it must correspond to an integral number of days
   * and is normally an integral number of years.
  */
  static readonly DECADES: ChronoUnit;
  /**
   * Unit that represents the concept of a century.
   * For the ISO calendar system, it is equal to 100 years.
   * 
   * When used with other calendar systems it must correspond to an integral number of days
   * and is normally an integral number of years.
  */
  static readonly CENTURIES: ChronoUnit;
  /**
   * Unit that represents the concept of a millennium.
   * For the ISO calendar system, it is equal to 1000 years.
   * 
   * When used with other calendar systems it must correspond to an integral number of days
   * and is normally an integral number of years.
  */
  static readonly MILLENNIA: ChronoUnit;
  /**
   * Unit that represents the concept of an era.
   * The ISO calendar system doesn't have eras thus it is impossible to add
   * an era to a date or date-time.
   * The estimated duration of the era is artificially defined as `1,000,000,000 Years`.
   * 
   * When used with other calendar systems there are no restrictions on the unit.
  */
  static readonly ERAS: ChronoUnit;
  /**
   * Artificial unit that represents the concept of forever.
   * This is primarily used with {@link TemporalField} to represent unbounded fields
   * such as the year or era.
   * The estimated duration of this unit is artificially defined as the largest duration
   * supported by {@link Duration}.
  */
  static readonly FOREVER: ChronoUnit;
  static valueOf(name: string): ChronoUnit;
  static values(): ChronoUnit[];
  /**
   * Gets the estimated duration of this unit in the ISO calendar system.
   * 
   * All of the units in this class have an estimated duration.
   * Days vary due to daylight saving time, while months have different lengths.
   *
   * @return the estimated duration of this unit, not null
  */
  get duration(): Duration;
  /**
   * Checks if the duration of the unit is an estimate.
   * 
   * All time units in this class are considered to be accurate, while all date
   * units in this class are considered to be estimated.
   * 
   * This definition ignores leap seconds, but considers that Days vary due to
   * daylight saving time and months have different lengths.
   *
   * @return true if the duration is estimated, false if accurate
  */
  isDurationEstimated(): boolean;
  /**
   * Checks if this unit is a date unit.
   * 
   * All units from days to eras inclusive are date-based.
   * Time-based units and `FOREVER` return false.
   *
   * @return true if a date unit, false if a time unit
  */
  isDateBased(): boolean;
  /**
   * Checks if this unit is a time unit.
   * 
   * All units from nanos to half-days inclusive are time-based.
   * Date-based units and `FOREVER` return false.
   *
   * @return true if a time unit, false if a date unit
  */
  isTimeBased(): boolean;
  isSupportedBy(temporal: Temporal): boolean;
  addTo<R>(temporal: R, amount: number): R;
  between(temporal1Inclusive: Temporal, temporal2Exclusive: Temporal): number;
  toString(): string;
}
/**
 * Localized definitions of the day-of-week, week-of-month and week-of-year fields.
 * 
 * A standard week is seven days long, but cultures have different definitions for some
 * other aspects of a week. This class represents the definition of the week, for the
 * purpose of providing {@link TemporalField} instances.
 * 
 * WeekFields provides five fields,
 * {@link #dayOfWeek()}, {@link #weekOfMonth()}, {@link #weekOfYear()},
 * {@link #weekOfWeekBasedYear()}, and {@link #weekBasedYear()}
 * that provide access to the values from any {@linkplain Temporal temporal object}.
 * 
 * The computations for day-of-week, week-of-month, and week-of-year are based
 * on the  {@linkplain ChronoField#YEAR proleptic-year},
 * {@linkplain ChronoField#MONTH_OF_YEAR month-of-year},
 * {@linkplain ChronoField#DAY_OF_MONTH day-of-month}, and
 * {@linkplain ChronoField#DAY_OF_WEEK ISO day-of-week} which are based on the
 * {@linkplain ChronoField#EPOCH_DAY epoch-day} and the chronology.
 * The values may not be aligned with the {@linkplain ChronoField#YEAR_OF_ERA year-of-Era}
 * depending on the Chronology.
 * A week is defined by:
 * 
 * The first day-of-week.
 * For example, the ISO-8601 standard considers Monday to be the first day-of-week.
 * The minimal number of days in the first week.
 * For example, the ISO-8601 standard counts the first week as needing at least 4 days.
 * 
 * Together these two values allow a year or month to be divided into weeks.
 *
 * Week of Month
 * One field is used: week-of-month.
 * The calculation ensures that weeks never overlap a month boundary.
 * The month is divided into periods where each period starts on the defined first day-of-week.
 * The earliest period is referred to as week 0 if it has less than the minimal number of days
 * and week 1 if it has at least the minimal number of days.
 *
 * 
 * Examples of WeekFields
 * 
 * DateDay-of-week
 *  First day: MondayMinimal days: 4First day: MondayMinimal days: 5
 * 
 * 
 * 2008-12-31Wednesday
 *  Week 5 of December 2008Week 5 of December 2008
 * 2009-01-01Thursday
 *  Week 1 of January 2009Week 0 of January 2009
 * 2009-01-04Sunday
 *  Week 1 of January 2009Week 0 of January 2009
 * 2009-01-05Monday
 *  Week 2 of January 2009Week 1 of January 2009
 * 
 * 
 *
 * Week of Year
 * One field is used: week-of-year.
 * The calculation ensures that weeks never overlap a year boundary.
 * The year is divided into periods where each period starts on the defined first day-of-week.
 * The earliest period is referred to as week 0 if it has less than the minimal number of days
 * and week 1 if it has at least the minimal number of days.
 *
 * Week Based Year
 * Two fields are used for week-based-year, one for the
 * {@link #weekOfWeekBasedYear() week-of-week-based-year} and one for
 * {@link #weekBasedYear() week-based-year}.  In a week-based-year, each week
 * belongs to only a single year.  Week 1 of a year is the first week that
 * starts on the first day-of-week and has at least the minimum number of days.
 * The first and last weeks of a year may contain days from the
 * previous calendar year or next calendar year respectively.
 *
 * 
 * Examples of WeekFields for week-based-year
 * 
 * DateDay-of-week
 *  First day: MondayMinimal days: 4First day: MondayMinimal days: 5
 * 
 * 
 * 2008-12-31Wednesday
 *  Week 1 of 2009Week 53 of 2008
 * 2009-01-01Thursday
 *  Week 1 of 2009Week 53 of 2008
 * 2009-01-04Sunday
 *  Week 1 of 2009Week 53 of 2008
 * 2009-01-05Monday
 *  Week 2 of 2009Week 1 of 2009
 * 
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class WeekFields extends Serializable {
  /**
   * The ISO-8601 definition, where a week starts on Monday and the first week
   * has a minimum of 4 days.
   * 
   * The ISO-8601 standard defines a calendar system based on weeks.
   * It uses the week-based-year and week-of-week-based-year concepts to split
   * up the passage of days instead of the standard year/month/day.
   * 
   * Note that the first week may start in the previous calendar year.
   * Note also that the first few days of a calendar year may be in the
   * week-based-year corresponding to the previous calendar year.
  */
  static readonly ISO: WeekFields;
  /**
   * The common definition of a week that starts on Sunday and the first week
   * has a minimum of 1 day.
   * 
   * Defined as starting on Sunday and with a minimum of 1 day in the month.
   * This week definition is in use in the US and other European countries.
  */
  static readonly SUNDAY_START: WeekFields;
  /**
   * The unit that represents week-based-years for the purpose of addition and subtraction.
   * 
   * This allows a number of week-based-years to be added to, or subtracted from, a date.
   * The unit is equal to either 52 or 53 weeks.
   * The estimated duration of a week-based-year is the same as that of a standard ISO
   * year at `365.2425 Days`.
   * 
   * The rules for addition add the number of week-based-years to the existing value
   * for the week-based-year field retaining the week-of-week-based-year
   * and day-of-week, unless the week number it too large for the target year.
   * In that case, the week is set to the last week of the year
   * with the same day-of-week.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly WEEK_BASED_YEARS: TemporalUnit;
  /**
   * Obtains an instance of `WeekFields` appropriate for a locale.
   * 
   * This will look up appropriate values from the provider of localization data.
   * If the locale contains "fw" (First day of week) and/or "rg"
   * (Region Override) 
   * Unicode extensions, returned instance will reflect the values specified with
   * those extensions. If both "fw" and "rg" are specified, the value from
   * the "fw" extension supersedes the implicit one from the "rg" extension.
   *
   * For example, users who are interested in using an English locale,
   * but want the first day of the week that corresponds with the ISO-8601
   * standard can call
   * {@snippet lang=java :
   * Locale enIsoLoc = Locale.forLanguageTag("en-u-fw-mon");
   * WeekFields.of(enIsoLoc).getFirstDayOfWeek(); // returns MONDAY
   * }
   *
   * @param locale  the locale to use, not null
   * @return the week-definition, not null
  */
  static of(locale: Locale): WeekFields;
  /**
   * Obtains an instance of `WeekFields` from the first day-of-week and minimal days.
   * 
   * The first day-of-week defines the ISO `DayOfWeek` that is day 1 of the week.
   * The minimal number of days in the first week defines how many days must be present
   * in a month or year, starting from the first day-of-week, before the week is counted
   * as the first week. A value of 1 will count the first day of the month or year as part
   * of the first week, whereas a value of 7 will require the whole seven days to be in
   * the new month or year.
   * 
   * WeekFields instances are singletons; for each unique combination
   * of `firstDayOfWeek` and `minimalDaysInFirstWeek`
   * the same instance will be returned.
   *
   * @param firstDayOfWeek  the first day of the week, not null
   * @param minimalDaysInFirstWeek  the minimal number of days in the first week, from 1 to 7
   * @return the week-definition, not null
   * @throws IllegalArgumentException if the minimal days value is less than one
   *      or greater than 7
  */
  static of(firstDayOfWeek: DayOfWeek, minimalDaysInFirstWeek: number): WeekFields;
  /**
   * Gets the first day-of-week.
   * 
   * The first day-of-week varies by culture.
   * For example, the US uses Sunday, while France and the ISO-8601 standard use Monday.
   * This method returns the first day using the standard `DayOfWeek` enum.
   *
   * @return the first day-of-week, not null
  */
  get firstDayOfWeek(): DayOfWeek;
  /**
   * Gets the minimal number of days in the first week.
   * 
   * The number of days considered to define the first week of a month or year
   * varies by culture.
   * For example, the ISO-8601 requires 4 days (more than half a week) to
   * be present before counting the first week.
   *
   * @return the minimal number of days in the first week of a month or year, from 1 to 7
  */
  get minimalDaysInFirstWeek(): number;
  /**
   * Returns a field to access the day of week based on this `WeekFields`.
   * 
   * This is similar to {@link ChronoField#DAY_OF_WEEK} but uses values for
   * the day-of-week based on this `WeekFields`.
   * The days are numbered from 1 to 7 where the
   * {@link #getFirstDayOfWeek() first day-of-week} is assigned the value 1.
   * 
   * For example, if the first day-of-week is Sunday, then that will have the
   * value 1, with other days ranging from Monday as 2 to Saturday as 7.
   * 
   * In the resolving phase of parsing, a localized day-of-week will be converted
   * to a standardized `ChronoField` day-of-week.
   * The day-of-week must be in the valid range 1 to 7.
   * Other fields in this class build dates using the standardized day-of-week.
   *
   * @return a field providing access to the day-of-week with localized numbering, not null
  */
  dayOfWeek(): TemporalField;
  /**
   * Returns a field to access the week of month based on this `WeekFields`.
   * 
   * This represents the concept of the count of weeks within the month where weeks
   * start on a fixed day-of-week, such as Monday.
   * This field is typically used with {@link WeekFields#dayOfWeek()}.
   * 
   * Week one (1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
   * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the month.
   * Thus, week one may start up to `minDays` days before the start of the month.
   * If the first week starts after the start of the month then the period before is week zero (0).
   * 
   * For example:
   * - if the 1st day of the month is a Monday, week one starts on the 1st and there is no week zero
   * - if the 2nd day of the month is a Monday, week one starts on the 2nd and the 1st is in week zero
   * - if the 4th day of the month is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero
   * - if the 5th day of the month is a Monday, week two starts on the 5th and the 1st to 4th is in week one
   * 
   * This field can be used with any calendar system.
   * 
   * In the resolving phase of parsing, a date can be created from a year,
   * week-of-month, month-of-year and day-of-week.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all four fields are
   * validated against their range of valid values. The week-of-month field
   * is validated to ensure that the resulting month is the month requested.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all four fields are
   * validated against their range of valid values. The week-of-month field
   * is validated from 0 to 6, meaning that the resulting date can be in a
   * different month to that specified.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
   * are validated against the range of valid values. The resulting date is calculated
   * equivalent to the following four stage approach.
   * First, create a date on the first day of the first week of January in the requested year.
   * Then take the month-of-year, subtract one, and add the amount in months to the date.
   * Then take the week-of-month, subtract one, and add the amount in weeks to the date.
   * Finally, adjust to the correct day-of-week within the localized week.
   *
   * @return a field providing access to the week-of-month, not null
  */
  weekOfMonth(): TemporalField;
  /**
   * Returns a field to access the week of year based on this `WeekFields`.
   * 
   * This represents the concept of the count of weeks within the year where weeks
   * start on a fixed day-of-week, such as Monday.
   * This field is typically used with {@link WeekFields#dayOfWeek()}.
   * 
   * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
   * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
   * Thus, week one may start up to `minDays` days before the start of the year.
   * If the first week starts after the start of the year then the period before is week zero (0).
   * 
   * For example:
   * - if the 1st day of the year is a Monday, week one starts on the 1st and there is no week zero
   * - if the 2nd day of the year is a Monday, week one starts on the 2nd and the 1st is in week zero
   * - if the 4th day of the year is a Monday, week one starts on the 4th and the 1st to 3rd is in week zero
   * - if the 5th day of the year is a Monday, week two starts on the 5th and the 1st to 4th is in week one
   * 
   * This field can be used with any calendar system.
   * 
   * In the resolving phase of parsing, a date can be created from a year,
   * week-of-year and day-of-week.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
   * validated against their range of valid values. The week-of-year field
   * is validated to ensure that the resulting year is the year requested.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
   * validated against their range of valid values. The week-of-year field
   * is validated from 0 to 54, meaning that the resulting date can be in a
   * different year to that specified.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
   * are validated against the range of valid values. The resulting date is calculated
   * equivalent to the following three stage approach.
   * First, create a date on the first day of the first week in the requested year.
   * Then take the week-of-year, subtract one, and add the amount in weeks to the date.
   * Finally, adjust to the correct day-of-week within the localized week.
   *
   * @return a field providing access to the week-of-year, not null
  */
  weekOfYear(): TemporalField;
  /**
   * Returns a field to access the week of a week-based-year based on this `WeekFields`.
   * 
   * This represents the concept of the count of weeks within the year where weeks
   * start on a fixed day-of-week, such as Monday and each week belongs to exactly one year.
   * This field is typically used with {@link WeekFields#dayOfWeek()} and
   * {@link WeekFields#weekBasedYear()}.
   * 
   * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
   * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
   * If the first week starts after the start of the year then the period before
   * is in the last week of the previous year.
   * 
   * For example:
   * - if the 1st day of the year is a Monday, week one starts on the 1st
   * - if the 2nd day of the year is a Monday, week one starts on the 2nd and
   *   the 1st is in the last week of the previous year
   * - if the 4th day of the year is a Monday, week one starts on the 4th and
   *   the 1st to 3rd is in the last week of the previous year
   * - if the 5th day of the year is a Monday, week two starts on the 5th and
   *   the 1st to 4th is in week one
   * 
   * This field can be used with any calendar system.
   * 
   * In the resolving phase of parsing, a date can be created from a week-based-year,
   * week-of-year and day-of-week.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
   * validated against their range of valid values. The week-of-year field
   * is validated to ensure that the resulting week-based-year is the
   * week-based-year requested.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
   * validated against their range of valid values. The week-of-week-based-year field
   * is validated from 1 to 53, meaning that the resulting date can be in the
   * following week-based-year to that specified.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
   * are validated against the range of valid values. The resulting date is calculated
   * equivalent to the following three stage approach.
   * First, create a date on the first day of the first week in the requested week-based-year.
   * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
   * Finally, adjust to the correct day-of-week within the localized week.
   *
   * @return a field providing access to the week-of-week-based-year, not null
  */
  weekOfWeekBasedYear(): TemporalField;
  /**
   * Returns a field to access the year of a week-based-year based on this `WeekFields`.
   * 
   * This represents the concept of the year where weeks start on a fixed day-of-week,
   * such as Monday and each week belongs to exactly one year.
   * This field is typically used with {@link WeekFields#dayOfWeek()} and
   * {@link WeekFields#weekOfWeekBasedYear()}.
   * 
   * Week one(1) is the week starting on the {@link WeekFields#getFirstDayOfWeek}
   * where there are at least {@link WeekFields#getMinimalDaysInFirstWeek()} days in the year.
   * Thus, week one may start before the start of the year.
   * If the first week starts after the start of the year then the period before
   * is in the last week of the previous year.
   * 
   * This field can be used with any calendar system.
   * 
   * In the resolving phase of parsing, a date can be created from a week-based-year,
   * week-of-year and day-of-week.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
   * validated against their range of valid values. The week-of-year field
   * is validated to ensure that the resulting week-based-year is the
   * week-based-year requested.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
   * validated against their range of valid values. The week-of-week-based-year field
   * is validated from 1 to 53, meaning that the resulting date can be in the
   * following week-based-year to that specified.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, the year and day-of-week
   * are validated against the range of valid values. The resulting date is calculated
   * equivalent to the following three stage approach.
   * First, create a date on the first day of the first week in the requested week-based-year.
   * Then take the week-of-week-based-year, subtract one, and add the amount in weeks to the date.
   * Finally, adjust to the correct day-of-week within the localized week.
   *
   * @return a field providing access to the week-based-year, not null
  */
  weekBasedYear(): TemporalField;
  /**
   * Checks if this `WeekFields` is equal to the specified object.
   * 
   * The comparison is based on the entire state of the rules, which is
   * the first day-of-week and minimal days.
   *
   * @param object  the other rules to compare to, null returns false
   * @return true if this is equal to the specified rules
  */
  equals(object: any): boolean;
  /**
   * A hash code for this `WeekFields`.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * A string representation of this `WeekFields` instance.
   *
   * @return the string representation, not null
  */
  toString(): string;
}
/**
 * The range of valid values for a date-time field.
 * 
 * All {@link TemporalField} instances have a valid range of values.
 * For example, the ISO day-of-month runs from 1 to somewhere between 28 and 31.
 * This class captures that valid range.
 * 
 * It is important to be aware of the limitations of this class.
 * Only the minimum and maximum values are provided.
 * It is possible for there to be invalid values within the outer range.
 * For example, a weird field may have valid values of 1, 2, 4, 6, 7, thus
 * have a range of '1 - 7', despite that fact that values 3 and 5 are invalid.
 * 
 * Instances of this class are not tied to a specific field.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ValueRange extends Serializable {
  /**
   * Obtains a fixed value range.
   * 
   * This factory obtains a range where the minimum and maximum values are fixed.
   * For example, the ISO month-of-year always runs from 1 to 12.
   *
   * @param min  the minimum value
   * @param max  the maximum value
   * @return the ValueRange for min, max, not null
   * @throws IllegalArgumentException if the minimum is greater than the maximum
  */
  static of(min: number, max: number): ValueRange;
  /**
   * Obtains a variable value range.
   * 
   * This factory obtains a range where the minimum value is fixed and the maximum value may vary.
   * For example, the ISO day-of-month always starts at 1, but ends between 28 and 31.
   *
   * @param min  the minimum value
   * @param maxSmallest  the smallest maximum value
   * @param maxLargest  the largest maximum value
   * @return the ValueRange for min, smallest max, largest max, not null
   * @throws IllegalArgumentException if
   *     the minimum is greater than the smallest maximum,
   *  or the smallest maximum is greater than the largest maximum
  */
  static of(min: number, maxSmallest: number, maxLargest: number): ValueRange;
  /**
   * Obtains a fully variable value range.
   * 
   * This factory obtains a range where both the minimum and maximum value may vary.
   *
   * @param minSmallest  the smallest minimum value
   * @param minLargest  the largest minimum value
   * @param maxSmallest  the smallest maximum value
   * @param maxLargest  the largest maximum value
   * @return the ValueRange for smallest min, largest min, smallest max, largest max, not null
   * @throws IllegalArgumentException if
   *     the smallest minimum is greater than the smallest maximum,
   *  or the smallest maximum is greater than the largest maximum,
   *  or the largest minimum is greater than the largest maximum,
   *  or the smallest minimum is greater than the largest minimum
  */
  static of(minSmallest: number, minLargest: number, maxSmallest: number, maxLargest: number): ValueRange;
  /**
   * Is the value range fixed and fully known.
   * 
   * For example, the ISO day-of-month runs from 1 to between 28 and 31.
   * Since there is uncertainty about the maximum value, the range is not fixed.
   * However, for the month of January, the range is always 1 to 31, thus it is fixed.
   *
   * @return true if the set of values is fixed
  */
  isFixed(): boolean;
  /**
   * Gets the minimum value that the field can take.
   * 
   * For example, the ISO day-of-month always starts at 1.
   * The minimum is therefore 1.
   *
   * @return the minimum value for this field
  */
  get minimum(): number;
  /**
   * Gets the largest possible minimum value that the field can take.
   * 
   * For example, the ISO day-of-month always starts at 1.
   * The largest minimum is therefore 1.
   *
   * @return the largest possible minimum value for this field
  */
  get largestMinimum(): number;
  /**
   * Gets the smallest possible maximum value that the field can take.
   * 
   * For example, the ISO day-of-month runs to between 28 and 31 days.
   * The smallest maximum is therefore 28.
   *
   * @return the smallest possible maximum value for this field
  */
  get smallestMaximum(): number;
  /**
   * Gets the maximum value that the field can take.
   * 
   * For example, the ISO day-of-month runs to between 28 and 31 days.
   * The maximum is therefore 31.
   *
   * @return the maximum value for this field
  */
  get maximum(): number;
  /**
   * Checks if all values in the range fit in an `int`.
   * 
   * This checks that all valid values are within the bounds of an `int`.
   * 
   * For example, the ISO month-of-year has values from 1 to 12, which fits in an `int`.
   * By comparison, ISO nano-of-day runs from 1 to 86,400,000,000,000 which does not fit in an `int`.
   * 
   * This implementation uses {@link #getMinimum()} and {@link #getMaximum()}.
   *
   * @return true if a valid value always fits in an `int`
  */
  isIntValue(): boolean;
  /**
   * Checks if the value is within the valid range.
   * 
   * This checks that the value is within the stored range of values.
   *
   * @param value  the value to check
   * @return true if the value is valid
  */
  isValidValue(value: number): boolean;
  /**
   * Checks if the value is within the valid range and that all values
   * in the range fit in an `int`.
   * 
   * This method combines {@link #isIntValue()} and {@link #isValidValue(long)}.
   *
   * @param value  the value to check
   * @return true if the value is valid and fits in an `int`
  */
  isValidIntValue(value: number): boolean;
  /**
   * Checks that the specified value is valid.
   * 
   * This validates that the value is within the valid range of values.
   * The field is only used to improve the error message.
   *
   * @param value  the value to check
   * @param field  the field being checked, may be null
   * @return the value that was passed in
   * @see #isValidValue(long)
  */
  checkValidValue(value: number, field: TemporalField): number;
  /**
   * Checks that the specified value is valid and fits in an `int`.
   * 
   * This validates that the value is within the valid range of values and that
   * all valid values are within the bounds of an `int`.
   * The field is only used to improve the error message.
   *
   * @param value  the value to check
   * @param field  the field being checked, may be null
   * @return the value that was passed in
   * @see #isValidIntValue(long)
  */
  checkValidIntValue(value: number, field: TemporalField): number;
  /**
   * Checks if this range is equal to another range.
   * 
   * The comparison is based on the four values, minimum, largest minimum,
   * smallest maximum and maximum.
   * Only objects of type `ValueRange` are compared, other types return false.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other range
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this range.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this range as a `String`.
   * 
   * The format will be '{min}/{largestMin} - {smallestMax}/{max}',
   * where the largestMin or smallestMax sections may be omitted, together
   * with associated slash, if they are the same as the min or max.
   *
   * @return a string representation of this range, not null
  */
  toString(): string;
}
/**
 * A set of date fields that provide access to Julian Days.
 * 
 * The Julian Day is a standard way of expressing date and time commonly used in the scientific community.
 * It is expressed as a decimal number of whole days where days start at midday.
 * This class represents variations on Julian Days that count whole days from midnight.
 * 
 * The fields are implemented relative to {@link ChronoField#EPOCH_DAY EPOCH_DAY}.
 * The fields are supported, and can be queried and set if `EPOCH_DAY` is available.
 * The fields work with all chronologies.
 *
 * @implSpec
 * This is an immutable and thread-safe class.
 *
 * @since 1.8
*/
export class JulianFields {
  /**
   * Julian Day field.
   * 
   * This is an integer-based version of the Julian Day Number.
   * Julian Day is a well-known system that represents the count of whole days since day 0,
   * which is defined to be January 1, 4713 BCE in the Julian calendar, and -4713-11-24 Gregorian.
   * The field  has "JulianDay" as 'name', and 'DAYS' as 'baseUnit'.
   * The field always refers to the local date-time, ignoring the offset or zone.
   * 
   * For date-times, 'JULIAN_DAY.getFrom()' assumes the same value from
   * midnight until just before the next midnight.
   * When 'JULIAN_DAY.adjustInto()' is applied to a date-time, the time of day portion remains unaltered.
   * 'JULIAN_DAY.adjustInto()' and 'JULIAN_DAY.getFrom()' only apply to `Temporal` objects that
   * can be converted into {@link ChronoField#EPOCH_DAY}.
   * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
   * 
   * In the resolving phase of parsing, a date can be created from a Julian Day field.
   * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
   * the Julian Day value is validated against the range of valid values.
   * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
   *
   * Astronomical and Scientific Notes
   * The standard astronomical definition uses a fraction to indicate the time-of-day,
   * where each day is counted from midday to midday. For example,
   * a fraction of 0 represents midday, a fraction of 0.25
   * represents 18:00, a fraction of 0.5 represents midnight and a fraction
   * of 0.75 represents 06:00.
   * 
   * By contrast, this implementation has no fractional part, and counts
   * days from midnight to midnight.
   * This implementation uses an integer and days starting at midnight.
   * The integer value for the Julian Day Number is the astronomical Julian Day value at midday
   * of the date in question.
   * This amounts to the astronomical Julian Day, rounded to an integer `JDN = floor(JD + 0.5)`.
   *
   *      *  | ISO date          |  Julian Day Number | Astronomical Julian Day |
   *  | 1970-01-01T00:00  |         2,440,588  |         2,440,587.5     |
   *  | 1970-01-01T06:00  |         2,440,588  |         2,440,587.75    |
   *  | 1970-01-01T12:00  |         2,440,588  |         2,440,588.0     |
   *  | 1970-01-01T18:00  |         2,440,588  |         2,440,588.25    |
   *  | 1970-01-02T00:00  |         2,440,589  |         2,440,588.5     |
   *  | 1970-01-02T06:00  |         2,440,589  |         2,440,588.75    |
   *  | 1970-01-02T12:00  |         2,440,589  |         2,440,589.0     |
   * 
   * 
   * Julian Days are sometimes taken to imply Universal Time or UTC, but this
   * implementation always uses the Julian Day number for the local date,
   * regardless of the offset or time-zone.
  */
  static readonly JULIAN_DAY: TemporalField;
  /**
   * Modified Julian Day field.
   * 
   * This is an integer-based version of the Modified Julian Day Number.
   * Modified Julian Day (MJD) is a well-known system that counts days continuously.
   * It is defined relative to astronomical Julian Day as  `MJD = JD - 2400000.5`.
   * Each Modified Julian Day runs from midnight to midnight.
   * The field always refers to the local date-time, ignoring the offset or zone.
   * 
   * For date-times, 'MODIFIED_JULIAN_DAY.getFrom()' assumes the same value from
   * midnight until just before the next midnight.
   * When 'MODIFIED_JULIAN_DAY.adjustInto()' is applied to a date-time, the time of day portion remains unaltered.
   * 'MODIFIED_JULIAN_DAY.adjustInto()' and 'MODIFIED_JULIAN_DAY.getFrom()' only apply to `Temporal` objects
   * that can be converted into {@link ChronoField#EPOCH_DAY}.
   * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
   * 
   * This implementation is an integer version of MJD with the decimal part rounded to floor.
   * 
   * In the resolving phase of parsing, a date can be created from a Modified Julian Day field.
   * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
   * the Modified Julian Day value is validated against the range of valid values.
   * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
   *
   * Astronomical and Scientific Notes
   *      *  | ISO date          | Modified Julian Day |      Decimal MJD |
   *  | 1970-01-01T00:00  |             40,587  |       40,587.0   |
   *  | 1970-01-01T06:00  |             40,587  |       40,587.25  |
   *  | 1970-01-01T12:00  |             40,587  |       40,587.5   |
   *  | 1970-01-01T18:00  |             40,587  |       40,587.75  |
   *  | 1970-01-02T00:00  |             40,588  |       40,588.0   |
   *  | 1970-01-02T06:00  |             40,588  |       40,588.25  |
   *  | 1970-01-02T12:00  |             40,588  |       40,588.5   |
   * 
   *
   * Modified Julian Days are sometimes taken to imply Universal Time or UTC, but this
   * implementation always uses the Modified Julian Day for the local date,
   * regardless of the offset or time-zone.
  */
  static readonly MODIFIED_JULIAN_DAY: TemporalField;
  /**
   * Rata Die field.
   * 
   * Rata Die counts whole days continuously starting day 1 at midnight at the beginning of 0001-01-01 (ISO).
   * The field always refers to the local date-time, ignoring the offset or zone.
   * 
   * For date-times, 'RATA_DIE.getFrom()' assumes the same value from
   * midnight until just before the next midnight.
   * When 'RATA_DIE.adjustInto()' is applied to a date-time, the time of day portion remains unaltered.
   * 'RATA_DIE.adjustInto()' and 'RATA_DIE.getFrom()' only apply to `Temporal` objects
   * that can be converted into {@link ChronoField#EPOCH_DAY}.
   * An {@link UnsupportedTemporalTypeException} is thrown for any other type of object.
   * 
   * In the resolving phase of parsing, a date can be created from a Rata Die field.
   * In {@linkplain ResolverStyle#STRICT strict mode} and {@linkplain ResolverStyle#SMART smart mode}
   * the Rata Die value is validated against the range of valid values.
   * In {@linkplain ResolverStyle#LENIENT lenient mode} no validation occurs.
  */
  static readonly RATA_DIE: TemporalField;
}
/**
 * Framework-level interface defining an amount of time, such as
 * "6 hours", "8 days" or "2 years and 3 months".
 * 
 * This is the base interface type for amounts of time.
 * An amount is distinct from a date or time-of-day in that it is not tied
 * to any specific point on the time-line.
 * 
 * The amount can be thought of as a `Map` of {@link TemporalUnit} to
 * `long`, exposed via {@link #getUnits()} and {@link #get(TemporalUnit)}.
 * A simple case might have a single unit-value pair, such as "6 hours".
 * A more complex case may have multiple unit-value pairs, such as
 * "7 years, 3 months and 5 days".
 * 
 * There are two common implementations.
 * {@link Period} is a date-based implementation, storing years, months and days.
 * {@link Duration} is a time-based implementation, storing seconds and nanoseconds,
 * but providing some access using other duration based units such as minutes,
 * hours and fixed 24-hour days.
 * 
 * This interface is a framework-level interface that should not be widely
 * used in application code. Instead, applications should create and pass
 * around instances of concrete types, such as `Period` and `Duration`.
 *
 * @implSpec
 * This interface places no restrictions on the mutability of implementations,
 * however immutability is strongly recommended.
 *
 * @since 1.8
*/
export class TemporalAmount {
  /**
   * Returns the value of the requested unit.
   * The units returned from {@link #getUnits()} uniquely define the
   * value of the `TemporalAmount`.  A value must be returned
   * for each unit listed in `getUnits`.
   *
   * @implSpec
   * Implementations may declare support for units not listed by {@link #getUnits()}.
   * Typically, the implementation would define additional units
   * as conversions for the convenience of developers.
   *
   * @param unit the `TemporalUnit` for which to return the value
   * @return the long value of the unit
   * @throws DateTimeException if a value for the unit cannot be obtained
   * @throws UnsupportedTemporalTypeException if the `unit` is not supported
  */
  get(unit: TemporalUnit): number;
  /**
   * Returns the list of units uniquely defining the value of this TemporalAmount.
   * The list of `TemporalUnits` is defined by the implementation class.
   * The list is a snapshot of the units at the time `getUnits`
   * is called and is not mutable.
   * The units are ordered from longest duration to the shortest duration
   * of the unit.
   *
   * @implSpec
   * The list of units completely and uniquely represents the
   * state of the object without omissions, overlaps or duplication.
   * The units are in order from longest duration to shortest.
   *
   * @return the List of `TemporalUnits`; not null
  */
  get units(): TemporalUnit[];
  /**
   * Adds to the specified temporal object.
   * 
   * Adds the amount to the specified temporal object using the logic
   * encapsulated in the implementing class.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#plus(TemporalAmount)}:
   *      *   // These two lines are equivalent, but the second approach is recommended
   *   dateTime = amount.addTo(dateTime);
   *   dateTime = dateTime.plus(adder);
   * 
   * It is recommended to use the second approach, `plus(TemporalAmount)`,
   * as it is a lot clearer to read in code.
   *
   * @implSpec
   * The implementation must take the input object and add to it.
   * The implementation defines the logic of the addition and is responsible for
   * documenting that logic. It may use any method on `Temporal` to
   * query the temporal object and perform the addition.
   * The returned object must have the same observable type as the input object
   * 
   * The input object must not be altered.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable temporal objects.
   * 
   * The input temporal object may be in a calendar system other than ISO.
   * Implementations may choose to document compatibility with other calendar systems,
   * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.
   * 
   * This method may be called from multiple threads in parallel.
   * It must be thread-safe when invoked.
   *
   * @param temporal  the temporal object to add the amount to, not null
   * @return an object of the same observable type with the addition made, not null
   * @throws DateTimeException if unable to add
   * @throws ArithmeticException if numeric overflow occurs
  */
  addTo(temporal: Temporal): Temporal;
  /**
   * Subtracts this object from the specified temporal object.
   * 
   * Subtracts the amount from the specified temporal object using the logic
   * encapsulated in the implementing class.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#minus(TemporalAmount)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = amount.subtractFrom(dateTime);
   *   dateTime = dateTime.minus(amount);
   * 
   * It is recommended to use the second approach, `minus(TemporalAmount)`,
   * as it is a lot clearer to read in code.
   *
   * @implSpec
   * The implementation must take the input object and subtract from it.
   * The implementation defines the logic of the subtraction and is responsible for
   * documenting that logic. It may use any method on `Temporal` to
   * query the temporal object and perform the subtraction.
   * The returned object must have the same observable type as the input object
   * 
   * The input object must not be altered.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable temporal objects.
   * 
   * The input temporal object may be in a calendar system other than ISO.
   * Implementations may choose to document compatibility with other calendar systems,
   * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.
   * 
   * This method may be called from multiple threads in parallel.
   * It must be thread-safe when invoked.
   *
   * @param temporal  the temporal object to subtract the amount from, not null
   * @return an object of the same observable type with the subtraction made, not null
   * @throws DateTimeException if unable to subtract
   * @throws ArithmeticException if numeric overflow occurs
  */
  subtractFrom(temporal: Temporal): Temporal;
}
/**
 * Framework-level interface defining read-write access to a temporal object,
 * such as a date, time, offset or some combination of these.
 * 
 * This is the base interface type for date, time and offset objects that
 * are complete enough to be manipulated using plus and minus.
 * It is implemented by those classes that can provide and manipulate information
 * as {@linkplain TemporalField fields} or {@linkplain TemporalQuery queries}.
 * See {@link TemporalAccessor} for the read-only version of this interface.
 * 
 * Most date and time information can be represented as a number.
 * These are modeled using `TemporalField` with the number held using
 * a `long` to handle large values. Year, month and day-of-month are
 * simple examples of fields, but they also include instant and offsets.
 * See {@link ChronoField} for the standard set of fields.
 * 
 * Two pieces of date/time information cannot be represented by numbers,
 * the {@linkplain java.time.chrono.Chronology chronology} and the
 * {@linkplain java.time.ZoneId time-zone}.
 * These can be accessed via {@link #query(TemporalQuery) queries} using
 * the static methods defined on {@link TemporalQuery}.
 * 
 * This interface is a framework-level interface that should not be widely
 * used in application code. Instead, applications should create and pass
 * around instances of concrete types, such as `LocalDate`.
 * There are many reasons for this, part of which is that implementations
 * of this interface may be in calendar systems other than ISO.
 * See {@link java.time.chrono.ChronoLocalDate} for a fuller discussion of the issues.
 *
 * When to implement
 * 
 * A class should implement this interface if it meets three criteria:
 * 
 * it provides access to date/time/offset information, as per `TemporalAccessor`
 * the set of fields are contiguous from the largest to the smallest
 * the set of fields are complete, such that no other field is needed to define the
 *  valid range of values for the fields that are represented
 * 
 * 
 * Four examples make this clear:
 * 
 * `LocalDate` implements this interface as it represents a set of fields
 *  that are contiguous from days to forever and require no external information to determine
 *  the validity of each date. It is therefore able to implement plus/minus correctly.
 * `LocalTime` implements this interface as it represents a set of fields
 *  that are contiguous from nanos to within days and require no external information to determine
 *  validity. It is able to implement plus/minus correctly, by wrapping around the day.
 * `MonthDay`, the combination of month-of-year and day-of-month, does not implement
 *  this interface.  While the combination is contiguous, from days to months within years,
 *  the combination does not have sufficient information to define the valid range of values
 *  for day-of-month.  As such, it is unable to implement plus/minus correctly.
 * The combination day-of-week and day-of-month ("Friday the 13th") should not implement
 *  this interface. It does not represent a contiguous set of fields, as days to weeks overlaps
 *  days to months.
 * 
 *
 * @implSpec
 * This interface places no restrictions on the mutability of implementations,
 * however immutability is strongly recommended.
 * All implementations must be {@link Comparable}.
 *
 * @since 1.8
*/
export class Temporal extends TemporalAccessor {
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to, or subtracted from, this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   *
   * @implSpec
   * Implementations must check and handle all units defined in {@link ChronoUnit}.
   * If the unit is supported, then true must be returned, otherwise false must be returned.
   * 
   * If the field is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Returns an adjusted object of the same type as this object with the adjustment made.
   * 
   * This adjusts this date-time according to the rules of the specified adjuster.
   * A simple adjuster might simply set the one of the fields, such as the year field.
   * A more complex adjuster might set the date to the last day of the month.
   * A selection of common adjustments is provided in
   * {@link java.time.temporal.TemporalAdjusters TemporalAdjusters}.
   * These include finding the "last day of the month" and "next Wednesday".
   * The adjuster is responsible for handling special cases, such as the varying
   * lengths of month and leap years.
   * 
   * Some example code indicating how and why this method is used:
   *      *  date = date.with(Month.JULY);        // most key classes implement TemporalAdjuster
   *  date = date.with(lastDayOfMonth());  // static import from Adjusters
   *  date = date.with(next(WEDNESDAY));   // static import from Adjusters and DayOfWeek
   * 
   *
   * @implSpec
   * 
   * Implementations must not alter either this object or the specified temporal object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  return adjuster.adjustInto(this);
   * 
   *
   * @param adjuster  the adjuster to use, not null
   * @return an object of the same type with the specified adjustment made, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(adjuster: TemporalAdjuster): Temporal;
  /**
   * Returns an object of the same type as this object with the specified field altered.
   * 
   * This returns a new object based on this one with the value for the specified field changed.
   * For example, on a `LocalDate`, this could be used to set the year, month or day-of-month.
   * The returned object will have the same observable type as this object.
   * 
   * In some cases, changing a field is not fully defined. For example, if the target object is
   * a date representing the 31st January, then changing the month to February would be unclear.
   * In cases like this, the field is responsible for resolving the result. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported, then the adjustment must be performed.
   * If unsupported, then an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.adjustInto(Temporal, long)`
   * passing `this` as the first argument.
   * 
   * Implementations must not alter this object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   *
   * @param field  the field to set in the result, not null
   * @param newValue  the new value of the field in the result
   * @return an object of the same type with the specified field set, not null
   * @throws DateTimeException if the field cannot be set
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  with(field: TemporalField, newValue: number): Temporal;
  /**
   * Returns an object of the same type as this object with an amount added.
   * 
   * This adjusts this temporal, adding according to the rules of the specified amount.
   * The amount is typically a {@link java.time.Period} but may be any other type implementing
   * the {@link TemporalAmount} interface, such as {@link java.time.Duration}.
   * 
   * Some example code indicating how and why this method is used:
   *      *  date = date.plus(period);                // add a Period instance
   *  date = date.plus(duration);              // add a Duration instance
   *  date = date.plus(workingDays(6));        // example user-written workingDays method
   * 
   * 
   * Note that calling `plus` followed by `minus` is not guaranteed to
   * return the same date-time.
   *
   * @implSpec
   * 
   * Implementations must not alter either this object or the specified temporal object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  return amount.addTo(this);
   * 
   *
   * @param amount  the amount to add, not null
   * @return an object of the same type with the specified adjustment made, not null
   * @throws DateTimeException if the addition cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amount: TemporalAmount): Temporal;
  /**
   * Returns an object of the same type as this object with the specified period added.
   * 
   * This method returns a new object based on this one with the specified period added.
   * For example, on a `LocalDate`, this could be used to add a number of years, months or days.
   * The returned object will have the same observable type as this object.
   * 
   * In some cases, changing a field is not fully defined. For example, if the target object is
   * a date representing the 31st January, then adding one month would be unclear.
   * In cases like this, the field is responsible for resolving the result. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   *
   * @implSpec
   * Implementations must check and handle all units defined in {@link ChronoUnit}.
   * If the unit is supported, then the addition must be performed.
   * If unsupported, then an `UnsupportedTemporalTypeException` must be thrown.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.addTo(Temporal, long)`
   * passing `this` as the first argument.
   * 
   * Implementations must not alter this object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   *
   * @param amountToAdd  the amount of the specified unit to add, may be negative
   * @param unit  the unit of the amount to add, not null
   * @return an object of the same type with the specified period added, not null
   * @throws DateTimeException if the unit cannot be added
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: number, unit: TemporalUnit): Temporal;
  /**
   * Returns an object of the same type as this object with an amount subtracted.
   * 
   * This adjusts this temporal, subtracting according to the rules of the specified amount.
   * The amount is typically a {@link java.time.Period} but may be any other type implementing
   * the {@link TemporalAmount} interface, such as {@link java.time.Duration}.
   * 
   * Some example code indicating how and why this method is used:
   *      *  date = date.minus(period);               // subtract a Period instance
   *  date = date.minus(duration);             // subtract a Duration instance
   *  date = date.minus(workingDays(6));       // example user-written workingDays method
   * 
   * 
   * Note that calling `plus` followed by `minus` is not guaranteed to
   * return the same date-time.
   *
   * @implSpec
   * 
   * Implementations must not alter either this object or the specified temporal object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  return amount.subtractFrom(this);
   * 
   *
   * @param amount  the amount to subtract, not null
   * @return an object of the same type with the specified adjustment made, not null
   * @throws DateTimeException if the subtraction cannot be made
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amount: TemporalAmount): Temporal;
  /**
   * Returns an object of the same type as this object with the specified period subtracted.
   * 
   * This method returns a new object based on this one with the specified period subtracted.
   * For example, on a `LocalDate`, this could be used to subtract a number of years, months or days.
   * The returned object will have the same observable type as this object.
   * 
   * In some cases, changing a field is not fully defined. For example, if the target object is
   * a date representing the 31st March, then subtracting one month would be unclear.
   * In cases like this, the field is responsible for resolving the result. Typically it will choose
   * the previous valid date, which would be the last valid day of February in this example.
   *
   * @implSpec
   * Implementations must behave in a manor equivalent to the default method behavior.
   * 
   * Implementations must not alter this object.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable implementations.
   * 
   * The default implementation must behave equivalent to this code:
   *      *  return (amountToSubtract == Long.MIN_VALUE ?
   *      plus(Long.MAX_VALUE, unit).plus(1, unit) : plus(-amountToSubtract, unit));
   * 
   *
   * @param amountToSubtract  the amount of the specified unit to subtract, may be negative
   * @param unit  the unit of the amount to subtract, not null
   * @return an object of the same type with the specified period subtracted, not null
   * @throws DateTimeException if the unit cannot be subtracted
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: number, unit: TemporalUnit): Temporal;
  /**
   * Calculates the amount of time until another temporal in terms of the specified unit.
   * 
   * This calculates the amount of time between two temporal objects
   * in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified temporal.
   * The end point is converted to be of the same type as the start point if different.
   * The result will be negative if the end is before the start.
   * For example, the amount in hours between two temporal objects can be
   * calculated using `startTime.until(endTime, HOURS)`.
   * 
   * The calculation returns a whole number, representing the number of
   * complete units between the two temporals.
   * For example, the amount in hours between the times 11:30 and 13:29
   * will only be one hour as it is one minute short of two hours.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   temporal = start.until(end, unit);
   *   temporal = unit.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * For example, this method allows the number of days between two dates to
   * be calculated:
   *      *  long daysBetween = start.until(end, DAYS);
   *  // or alternatively
   *  long daysBetween = DAYS.between(start, end);
   * 
   *
   * @implSpec
   * Implementations must begin by checking to ensure that the input temporal
   * object is of the same observable type as the implementation.
   * They must then perform the calculation for all instances of {@link ChronoUnit}.
   * An `UnsupportedTemporalTypeException` must be thrown for `ChronoUnit`
   * instances that are unsupported.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * In summary, implementations must behave in a manner equivalent to this pseudo-code:
   *      *  // convert the end temporal to the same type as this class
   *  if (unit instanceof ChronoUnit) {
   *    // if unit is supported, then calculate and return result
   *    // else throw UnsupportedTemporalTypeException for unsupported units
   *  }
   *  return unit.between(this, convertedEndTemporal);
   * 
   * 
   * Note that the unit's `between` method must only be invoked if the
   * two temporal objects have exactly the same type evaluated by `getClass()`.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param endExclusive  the end temporal, exclusive, converted to be of the
   *  same type as this object, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this temporal object and the specified one
   *  in terms of the unit; positive if the specified object is later than this one,
   *  negative if it is earlier than this one
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to the same type as this temporal
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if the date-time can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and {@link #get(TemporalField) get}
   * methods will throw an exception.
   *
   * @implSpec
   * Implementations must check and handle all fields defined in {@link ChronoField}.
   * If the field is supported, then true must be returned, otherwise false must be returned.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * 
   * Implementations must ensure that no observable state is altered when this
   * read-only method is invoked.
   *
   * @param field  the field to check, null returns false
   * @return true if this date-time can be queried for the field, false if not
  */
  isSupported(field: TemporalField): boolean;
}
/**
 * Strategy for querying a temporal object.
 * 
 * Queries are a key tool for extracting information from temporal objects.
 * They exist to externalize the process of querying, permitting different
 * approaches, as per the strategy design pattern.
 * Examples might be a query that checks if the date is the day before February 29th
 * in a leap year, or calculates the number of days to your next birthday.
 * 
 * The {@link TemporalField} interface provides another mechanism for querying
 * temporal objects. That interface is limited to returning a `long`.
 * By contrast, queries can return any type.
 * 
 * There are two equivalent ways of using a `TemporalQuery`.
 * The first is to invoke the method on this interface directly.
 * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:
 *  *   // these two lines are equivalent, but the second approach is recommended
 *   temporal = thisQuery.queryFrom(temporal);
 *   temporal = temporal.query(thisQuery);
 * 
 * It is recommended to use the second approach, `query(TemporalQuery)`,
 * as it is a lot clearer to read in code.
 * 
 * The most common implementations are method references, such as
 * `LocalDate::from` and `ZoneId::from`.
 * Additional common queries are provided as static methods in {@link TemporalQueries}.
 *
 * @implSpec
 * This interface places no restrictions on the mutability of implementations,
 * however immutability is strongly recommended.
 *
 * @param  the type returned from the query
 *
 * @since 1.8
*/
export class TemporalQuery<R> {
  /**
   * Queries the specified temporal object.
   * 
   * This queries the specified temporal object to return an object using the logic
   * encapsulated in the implementing class.
   * Examples might be a query that checks if the date is the day before February 29th
   * in a leap year, or calculates the number of days to your next birthday.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisQuery.queryFrom(temporal);
   *   temporal = temporal.query(thisQuery);
   * 
   * It is recommended to use the second approach, `query(TemporalQuery)`,
   * as it is a lot clearer to read in code.
   *
   * @implSpec
   * The implementation must take the input object and query it.
   * The implementation defines the logic of the query and is responsible for
   * documenting that logic.
   * It may use any method on `TemporalAccessor` to determine the result.
   * The input object must not be altered.
   * 
   * The input temporal object may be in a calendar system other than ISO.
   * Implementations may choose to document compatibility with other calendar systems,
   * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.
   * 
   * This method may be called from multiple threads in parallel.
   * It must be thread-safe when invoked.
   *
   * @param temporal  the temporal object to query, not null
   * @return the queried value, may return null to indicate not found
   * @throws DateTimeException if unable to query
   * @throws ArithmeticException if numeric overflow occurs
  */
  queryFrom(temporal: TemporalAccessor): R;
}
/**
 * Fields and units specific to the ISO-8601 calendar system,
 * including quarter-of-year and week-based-year.
 * 
 * This class defines fields and units that are specific to the ISO calendar system.
 *
 * Quarter of year
 * The ISO-8601 standard is based on the standard civic 12 month year.
 * This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.
 * 
 * January, February and March are in Q1.
 * April, May and June are in Q2.
 * July, August and September are in Q3.
 * October, November and December are in Q4.
 * 
 * The complete date is expressed using three fields:
 * 
 * {@link #DAY_OF_QUARTER DAY_OF_QUARTER} - the day within the quarter, from 1 to 90, 91 or 92
 * {@link #QUARTER_OF_YEAR QUARTER_OF_YEAR} - the quarter within the year, from 1 to 4
 * {@link ChronoField#YEAR YEAR} - the standard ISO year
 * 
 *
 * Week based years
 * The ISO-8601 standard was originally intended as a data interchange format,
 * defining a string format for dates and times. However, it also defines an
 * alternate way of expressing the date, based on the concept of week-based-year.
 * 
 * The date is expressed using three fields:
 * 
 * {@link ChronoField#DAY_OF_WEEK DAY_OF_WEEK} - the standard field defining the
 *  day-of-week from Monday (1) to Sunday (7)
 * {@link #WEEK_OF_WEEK_BASED_YEAR} - the week within the week-based-year
 * {@link #WEEK_BASED_YEAR WEEK_BASED_YEAR} - the week-based-year
 * 
 * The week-based-year itself is defined relative to the standard ISO proleptic year.
 * It differs from the standard year in that it always starts on a Monday.
 * 
 * The first week of a week-based-year is the first Monday-based week of the standard
 * ISO year that has at least 4 days in the new year.
 * 
 * If January 1st is Monday then week 1 starts on January 1st
 * If January 1st is Tuesday then week 1 starts on December 31st of the previous standard year
 * If January 1st is Wednesday then week 1 starts on December 30th of the previous standard year
 * If January 1st is Thursday then week 1 starts on December 29th of the previous standard year
 * If January 1st is Friday then week 1 starts on January 4th
 * If January 1st is Saturday then week 1 starts on January 3rd
 * If January 1st is Sunday then week 1 starts on January 2nd
 * 
 * There are 52 weeks in most week-based years, however on occasion there are 53 weeks.
 * 
 * For example:
 *
 * 
 * Examples of Week based Years
 * 
 * DateDay-of-weekField values
 * 
 * 
 * 2008-12-28SundayWeek 52 of week-based-year 2008
 * 2008-12-29MondayWeek 1 of week-based-year 2009
 * 2008-12-31WednesdayWeek 1 of week-based-year 2009
 * 2009-01-01ThursdayWeek 1 of week-based-year 2009
 * 2009-01-04SundayWeek 1 of week-based-year 2009
 * 2009-01-05MondayWeek 2 of week-based-year 2009
 * 
 * 
 *
 * @implSpec
 * 
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class IsoFields {
  /**
   * The field that represents the day-of-quarter.
   * 
   * This field allows the day-of-quarter value to be queried and set.
   * The day-of-quarter has values from 1 to 90 in Q1 of a standard year, from 1 to 91
   * in Q1 of a leap year, from 1 to 91 in Q2 and from 1 to 92 in Q3 and Q4.
   * 
   * The day-of-quarter can only be calculated if the day-of-year, month-of-year and year
   * are available.
   * 
   * When setting this field, the value is allowed to be partially lenient, taking any
   * value from 1 to 92. If the quarter has less than 92 days, then day 92, and
   * potentially day 91, is in the following quarter.
   * 
   * In the resolving phase of parsing, a date can be created from a year,
   * quarter-of-year and day-of-quarter.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
   * validated against their range of valid values. The day-of-quarter field
   * is validated from 1 to 90, 91 or 92 depending on the year and quarter.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
   * validated against their range of valid values. The day-of-quarter field is
   * validated between 1 and 92, ignoring the actual range based on the year and quarter.
   * If the day-of-quarter exceeds the actual range by one day, then the resulting date
   * is one day later. If the day-of-quarter exceeds the actual range by two days,
   * then the resulting date is two days later.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, only the year is validated
   * against the range of valid values. The resulting date is calculated equivalent to
   * the following three stage approach. First, create a date on the first of January
   * in the requested year. Then take the quarter-of-year, subtract one, and add the
   * amount in quarters to the date. Finally, take the day-of-quarter, subtract one,
   * and add the amount in days to the date.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly DAY_OF_QUARTER: TemporalField;
  /**
   * The field that represents the quarter-of-year.
   * 
   * This field allows the quarter-of-year value to be queried and set.
   * The quarter-of-year has values from 1 to 4.
   * 
   * The quarter-of-year can only be calculated if the month-of-year is available.
   * 
   * In the resolving phase of parsing, a date can be created from a year,
   * quarter-of-year and day-of-quarter.
   * See {@link #DAY_OF_QUARTER} for details.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly QUARTER_OF_YEAR: TemporalField;
  /**
   * The field that represents the week-of-week-based-year.
   * 
   * This field allows the week of the week-based-year value to be queried and set.
   * The week-of-week-based-year has values from 1 to 52, or 53 if the
   * week-based-year has 53 weeks.
   * 
   * In the resolving phase of parsing, a date can be created from a
   * week-based-year, week-of-week-based-year and day-of-week.
   * 
   * In {@linkplain ResolverStyle#STRICT strict mode}, all three fields are
   * validated against their range of valid values. The week-of-week-based-year
   * field is validated from 1 to 52 or 53 depending on the week-based-year.
   * 
   * In {@linkplain ResolverStyle#SMART smart mode}, all three fields are
   * validated against their range of valid values. The week-of-week-based-year
   * field is validated between 1 and 53, ignoring the week-based-year.
   * If the week-of-week-based-year is 53, but the week-based-year only has
   * 52 weeks, then the resulting date is in week 1 of the following week-based-year.
   * 
   * In {@linkplain ResolverStyle#LENIENT lenient mode}, only the week-based-year
   * is validated against the range of valid values. If the day-of-week is outside
   * the range 1 to 7, then the resulting date is adjusted by a suitable number of
   * weeks to reduce the day-of-week to the range 1 to 7. If the week-of-week-based-year
   * value is outside the range 1 to 52, then any excess weeks are added or subtracted
   * from the resulting date.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly WEEK_OF_WEEK_BASED_YEAR: TemporalField;
  /**
   * The field that represents the week-based-year.
   * 
   * This field allows the week-based-year value to be queried and set.
   * 
   * The field has a range that matches {@link LocalDate#MAX} and {@link LocalDate#MIN}.
   * 
   * In the resolving phase of parsing, a date can be created from a
   * week-based-year, week-of-week-based-year and day-of-week.
   * See {@link #WEEK_OF_WEEK_BASED_YEAR} for details.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly WEEK_BASED_YEAR: TemporalField;
  /**
   * The unit that represents week-based-years for the purpose of addition and subtraction.
   * 
   * This allows a number of week-based-years to be added to, or subtracted from, a date.
   * The unit is equal to either 52 or 53 weeks.
   * The estimated duration of a week-based-year is the same as that of a standard ISO
   * year at `365.2425 Days`.
   * 
   * The rules for addition add the number of week-based-years to the existing value
   * for the week-based-year field. If the resulting week-based-year only has 52 weeks,
   * then the date will be in week 1 of the following week-based-year.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly WEEK_BASED_YEARS: TemporalUnit;
  /**
   * Unit that represents the concept of a quarter-year.
   * For the ISO calendar system, it is equal to 3 months.
   * The estimated duration of a quarter-year is one quarter of `365.2425 Days`.
   * 
   * This unit is an immutable and thread-safe singleton.
  */
  static readonly QUARTER_YEARS: TemporalUnit;
}
/**
 * Common and useful TemporalAdjusters.
 * 
 * Adjusters are a key tool for modifying temporal objects.
 * They exist to externalize the process of adjustment, permitting different
 * approaches, as per the strategy design pattern.
 * Examples might be an adjuster that sets the date avoiding weekends, or one that
 * sets the date to the last day of the month.
 * 
 * There are two equivalent ways of using a `TemporalAdjuster`.
 * The first is to invoke the method on the interface directly.
 * The second is to use {@link Temporal#with(TemporalAdjuster)}:
 *  *   // these two lines are equivalent, but the second approach is recommended
 *   temporal = thisAdjuster.adjustInto(temporal);
 *   temporal = temporal.with(thisAdjuster);
 * 
 * It is recommended to use the second approach, `with(TemporalAdjuster)`,
 * as it is a lot clearer to read in code.
 * 
 * This class contains a standard set of adjusters, available as static methods.
 * These include:
 * 
 * finding the first or last day of the month
 * finding the first day of next month
 * finding the first or last day of the year
 * finding the first day of next year
 * finding the first or last day-of-week within a month, such as "first Wednesday in June"
 * finding the next or previous day-of-week, such as "next Thursday"
 * 
 *
 * @implSpec
 * All the implementations supplied by the static methods are immutable.
 *
 * @see TemporalAdjuster
 * @since 1.8
*/
export class TemporalAdjusters {
  /**
   * Obtains a `TemporalAdjuster` that wraps a date adjuster.
   * 
   * The `TemporalAdjuster` is based on the low level `Temporal` interface.
   * This method allows an adjustment from `LocalDate` to `LocalDate`
   * to be wrapped to match the temporal-based interface.
   * This is provided for convenience to make user-written adjusters simpler.
   * 
   * In general, user-written adjusters should be static constants:
   * {@code
   *  static TemporalAdjuster TWO_DAYS_LATER =
   *       TemporalAdjusters.ofDateAdjuster(date -> date.plusDays(2));
   * }
   *
   * @param dateBasedAdjuster  the date-based adjuster, not null
   * @return the temporal adjuster wrapping on the date adjuster, not null
  */
  static ofDateAdjuster(dateBasedAdjuster: UnaryOperator<LocalDate>): TemporalAdjuster;
  /**
   * Returns the "first day of month" adjuster, which returns a new date set to
   * the first day of the current month.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2011-01-01.
   * The input 2011-02-15 will return 2011-02-01.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  temporal.with(DAY_OF_MONTH, 1);
   * 
   *
   * @return the first day-of-month adjuster, not null
  */
  static firstDayOfMonth(): TemporalAdjuster;
  /**
   * Returns the "last day of month" adjuster, which returns a new date set to
   * the last day of the current month.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2011-01-31.
   * The input 2011-02-15 will return 2011-02-28.
   * The input 2012-02-15 will return 2012-02-29 (leap year).
   * The input 2011-04-15 will return 2011-04-30.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  long lastDay = temporal.range(DAY_OF_MONTH).getMaximum();
   *  temporal.with(DAY_OF_MONTH, lastDay);
   * 
   *
   * @return the last day-of-month adjuster, not null
  */
  static lastDayOfMonth(): TemporalAdjuster;
  /**
   * Returns the "first day of next month" adjuster, which returns a new date set to
   * the first day of the next month.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2011-02-01.
   * The input 2011-02-15 will return 2011-03-01.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  temporal.with(DAY_OF_MONTH, 1).plus(1, MONTHS);
   * 
   *
   * @return the first day of next month adjuster, not null
  */
  static firstDayOfNextMonth(): TemporalAdjuster;
  /**
   * Returns the "first day of year" adjuster, which returns a new date set to
   * the first day of the current year.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2011-01-01.
   * The input 2011-02-15 will return 2011-01-01.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  temporal.with(DAY_OF_YEAR, 1);
   * 
   *
   * @return the first day-of-year adjuster, not null
  */
  static firstDayOfYear(): TemporalAdjuster;
  /**
   * Returns the "last day of year" adjuster, which returns a new date set to
   * the last day of the current year.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2011-12-31.
   * The input 2011-02-15 will return 2011-12-31.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  long lastDay = temporal.range(DAY_OF_YEAR).getMaximum();
   *  temporal.with(DAY_OF_YEAR, lastDay);
   * 
   *
   * @return the last day-of-year adjuster, not null
  */
  static lastDayOfYear(): TemporalAdjuster;
  /**
   * Returns the "first day of next year" adjuster, which returns a new date set to
   * the first day of the next year.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 will return 2012-01-01.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It is equivalent to:
   *      *  temporal.with(DAY_OF_YEAR, 1).plus(1, YEARS);
   * 
   *
   * @return the first day of next month adjuster, not null
  */
  static firstDayOfNextYear(): TemporalAdjuster;
  /**
   * Returns the first in month adjuster, which returns a new date
   * in the same month with the first matching day-of-week.
   * This is used for expressions like 'first Tuesday in March'.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-12-15 for (MONDAY) will return 2011-12-05.
   * The input 2011-12-15 for (FRIDAY) will return 2011-12-02.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` and `DAY_OF_MONTH` fields
   * and the `DAYS` unit, and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week, not null
   * @return the first in month adjuster, not null
  */
  static firstInMonth(dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the last in month adjuster, which returns a new date
   * in the same month with the last matching day-of-week.
   * This is used for expressions like 'last Tuesday in March'.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-12-15 for (MONDAY) will return 2011-12-26.
   * The input 2011-12-15 for (FRIDAY) will return 2011-12-30.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` and `DAY_OF_MONTH` fields
   * and the `DAYS` unit, and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week, not null
   * @return the first in month adjuster, not null
  */
  static lastInMonth(dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the day-of-week in month adjuster, which returns a new date
   * with the ordinal day-of-week based on the month.
   * This is used for expressions like the 'second Tuesday in March'.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-12-15 for (1,TUESDAY) will return 2011-12-06.
   * The input 2011-12-15 for (2,TUESDAY) will return 2011-12-13.
   * The input 2011-12-15 for (3,TUESDAY) will return 2011-12-20.
   * The input 2011-12-15 for (4,TUESDAY) will return 2011-12-27.
   * The input 2011-12-15 for (5,TUESDAY) will return 2012-01-03.
   * The input 2011-12-15 for (-1,TUESDAY) will return 2011-12-27 (last in month).
   * The input 2011-12-15 for (-4,TUESDAY) will return 2011-12-06 (3 weeks before last in month).
   * The input 2011-12-15 for (-5,TUESDAY) will return 2011-11-29 (4 weeks before last in month).
   * The input 2011-12-15 for (0,TUESDAY) will return 2011-11-29 (last in previous month).
   * 
   * For a positive or zero ordinal, the algorithm is equivalent to finding the first
   * day-of-week that matches within the month and then adding a number of weeks to it.
   * For a negative ordinal, the algorithm is equivalent to finding the last
   * day-of-week that matches within the month and then subtracting a number of weeks to it.
   * The ordinal number of weeks is not validated and is interpreted leniently
   * according to this algorithm. This definition means that an ordinal of zero finds
   * the last matching day-of-week in the previous month.
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` and `DAY_OF_MONTH` fields
   * and the `DAYS` unit, and assumes a seven day week.
   *
   * @param ordinal  the week within the month, unbounded but typically from -5 to 5
   * @param dayOfWeek  the day-of-week, not null
   * @return the day-of-week in month adjuster, not null
  */
  static dayOfWeekInMonth(ordinal: number, dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the next day-of-week adjuster, which adjusts the date to the
   * first occurrence of the specified day-of-week after the date being adjusted.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).
   * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).
   * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-22 (seven days later).
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` field and the `DAYS` unit,
   * and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week to move the date to, not null
   * @return the next day-of-week adjuster, not null
  */
  static next(dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the next-or-same day-of-week adjuster, which adjusts the date to the
   * first occurrence of the specified day-of-week after the date being adjusted
   * unless it is already on that day in which case the same object is returned.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-17 (two days later).
   * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-19 (four days later).
   * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` field and the `DAYS` unit,
   * and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week to check for or move the date to, not null
   * @return the next-or-same day-of-week adjuster, not null
  */
  static nextOrSame(dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the previous day-of-week adjuster, which adjusts the date to the
   * first occurrence of the specified day-of-week before the date being adjusted.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).
   * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).
   * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-08 (seven days earlier).
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` field and the `DAYS` unit,
   * and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week to move the date to, not null
   * @return the previous day-of-week adjuster, not null
  */
  static previous(dayOfWeek: DayOfWeek): TemporalAdjuster;
  /**
   * Returns the previous-or-same day-of-week adjuster, which adjusts the date to the
   * first occurrence of the specified day-of-week before the date being adjusted
   * unless it is already on that day in which case the same object is returned.
   * 
   * The ISO calendar system behaves as follows:
   * The input 2011-01-15 (a Saturday) for parameter (MONDAY) will return 2011-01-10 (five days earlier).
   * The input 2011-01-15 (a Saturday) for parameter (WEDNESDAY) will return 2011-01-12 (three days earlier).
   * The input 2011-01-15 (a Saturday) for parameter (SATURDAY) will return 2011-01-15 (same as input).
   * 
   * The behavior is suitable for use with most calendar systems.
   * It uses the `DAY_OF_WEEK` field and the `DAYS` unit,
   * and assumes a seven day week.
   *
   * @param dayOfWeek  the day-of-week to check for or move the date to, not null
   * @return the previous-or-same day-of-week adjuster, not null
  */
  static previousOrSame(dayOfWeek: DayOfWeek): TemporalAdjuster;
}
/**
 * Strategy for adjusting a temporal object.
 * 
 * Adjusters are a key tool for modifying temporal objects.
 * They exist to externalize the process of adjustment, permitting different
 * approaches, as per the strategy design pattern.
 * Examples might be an adjuster that sets the date avoiding weekends, or one that
 * sets the date to the last day of the month.
 * 
 * There are two equivalent ways of using a `TemporalAdjuster`.
 * The first is to invoke the method on this interface directly.
 * The second is to use {@link Temporal#with(TemporalAdjuster)}:
 *  *   // these two lines are equivalent, but the second approach is recommended
 *   temporal = thisAdjuster.adjustInto(temporal);
 *   temporal = temporal.with(thisAdjuster);
 * 
 * It is recommended to use the second approach, `with(TemporalAdjuster)`,
 * as it is a lot clearer to read in code.
 * 
 * The {@link TemporalAdjusters} class contains a standard set of adjusters,
 * available as static methods.
 * These include:
 * 
 * finding the first or last day of the month
 * finding the first day of next month
 * finding the first or last day of the year
 * finding the first day of next year
 * finding the first or last day-of-week within a month, such as "first Wednesday in June"
 * finding the next or previous day-of-week, such as "next Thursday"
 * 
 *
 * @implSpec
 * This interface places no restrictions on the mutability of implementations,
 * however immutability is strongly recommended.
 *
 * @see TemporalAdjusters
 * @since 1.8
*/
export class TemporalAdjuster {
  /**
   * Adjusts the specified temporal object.
   * 
   * This adjusts the specified temporal object using the logic
   * encapsulated in the implementing class.
   * Examples might be an adjuster that sets the date avoiding weekends, or one that
   * sets the date to the last day of the month.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method directly.
   * The second is to use {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisAdjuster.adjustInto(temporal);
   *   temporal = temporal.with(thisAdjuster);
   * 
   * It is recommended to use the second approach, `with(TemporalAdjuster)`,
   * as it is a lot clearer to read in code.
   *
   * @implSpec
   * The implementation must take the input object and adjust it.
   * The implementation defines the logic of the adjustment and is responsible for
   * documenting that logic. It may use any method on `Temporal` to
   * query the temporal object and perform the adjustment.
   * The returned object must have the same observable type as the input object
   * 
   * The input object must not be altered.
   * Instead, an adjusted copy of the original must be returned.
   * This provides equivalent, safe behavior for immutable and mutable temporal objects.
   * 
   * The input temporal object may be in a calendar system other than ISO.
   * Implementations may choose to document compatibility with other calendar systems,
   * or reject non-ISO temporal objects by {@link TemporalQueries#chronology() querying the chronology}.
   * 
   * This method may be called from multiple threads in parallel.
   * It must be thread-safe when invoked.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same observable type with the adjustment made, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
}
/**
 * Common implementations of `TemporalQuery`.
 * 
 * This class provides common implementations of {@link TemporalQuery}.
 * These are defined here as they must be constants, and the definition
 * of lambdas does not guarantee that. By assigning them once here,
 * they become 'normal' Java constants.
 * 
 * Queries are a key tool for extracting information from temporal objects.
 * They exist to externalize the process of querying, permitting different
 * approaches, as per the strategy design pattern.
 * Examples might be a query that checks if the date is the day before February 29th
 * in a leap year, or calculates the number of days to your next birthday.
 * 
 * The {@link TemporalField} interface provides another mechanism for querying
 * temporal objects. That interface is limited to returning a `long`.
 * By contrast, queries can return any type.
 * 
 * There are two equivalent ways of using a `TemporalQuery`.
 * The first is to invoke the method on this interface directly.
 * The second is to use {@link TemporalAccessor#query(TemporalQuery)}:
 *  *   // these two lines are equivalent, but the second approach is recommended
 *   temporal = thisQuery.queryFrom(temporal);
 *   temporal = temporal.query(thisQuery);
 * 
 * It is recommended to use the second approach, `query(TemporalQuery)`,
 * as it is a lot clearer to read in code.
 * 
 * The most common implementations are method references, such as
 * `LocalDate::from` and `ZoneId::from`.
 * Additional common queries are provided to return:
 * 
 *  a Chronology,
 *  a LocalDate,
 *  a LocalTime,
 *  a ZoneOffset,
 *  a precision,
 *  a zone, or
 *  a zoneId.
 * 
 *
 * @since 1.8
*/
export class TemporalQueries {
  /**
   * A strict query for the `ZoneId`.
   * 
   * This queries a `TemporalAccessor` for the zone.
   * The zone is only returned if the date-time conceptually contains a `ZoneId`.
   * It will not be returned if the date-time only conceptually has an `ZoneOffset`.
   * Thus a {@link java.time.ZonedDateTime} will return the result of `getZone()`,
   * but an {@link java.time.OffsetDateTime} will return null.
   * 
   * In most cases, applications should use {@link #zone()} as this query is too strict.
   * 
   * The result from JDK classes implementing `TemporalAccessor` is as follows:
   * `LocalDate` returns null
   * `LocalTime` returns null
   * `LocalDateTime` returns null
   * `ZonedDateTime` returns the associated zone
   * `OffsetTime` returns null
   * `OffsetDateTime` returns null
   * `ChronoLocalDate` returns null
   * `ChronoLocalDateTime` returns null
   * `ChronoZonedDateTime` returns the associated zone
   * `Era` returns null
   * `DayOfWeek` returns null
   * `Month` returns null
   * `Year` returns null
   * `YearMonth` returns null
   * `MonthDay` returns null
   * `ZoneOffset` returns null
   * `Instant` returns null
   *
   * @return a query that can obtain the zone ID of a temporal, not null
  */
  static zoneId(): TemporalQuery<ZoneId>;
  /**
   * A query for the `Chronology`.
   * 
   * This queries a `TemporalAccessor` for the chronology.
   * If the target `TemporalAccessor` represents a date, or part of a date,
   * then it should return the chronology that the date is expressed in.
   * As a result of this definition, objects only representing time, such as
   * `LocalTime`, will return null.
   * 
   * The result from JDK classes implementing `TemporalAccessor` is as follows:
   * `LocalDate` returns `IsoChronology.INSTANCE`
   * `LocalTime` returns null (does not represent a date)
   * `LocalDateTime` returns `IsoChronology.INSTANCE`
   * `ZonedDateTime` returns `IsoChronology.INSTANCE`
   * `OffsetTime` returns null (does not represent a date)
   * `OffsetDateTime` returns `IsoChronology.INSTANCE`
   * `ChronoLocalDate` returns the associated chronology
   * `ChronoLocalDateTime` returns the associated chronology
   * `ChronoZonedDateTime` returns the associated chronology
   * `Era` returns the associated chronology
   * `DayOfWeek` returns null (shared across chronologies)
   * `Month` returns `IsoChronology.INSTANCE`
   * `Year` returns `IsoChronology.INSTANCE`
   * `YearMonth` returns `IsoChronology.INSTANCE`
   * `MonthDay` returns null `IsoChronology.INSTANCE`
   * `ZoneOffset` returns null (does not represent a date)
   * `Instant` returns null (does not represent a date)
   * 
   * The method {@link java.time.chrono.Chronology#from(TemporalAccessor)} can be used as a
   * `TemporalQuery` via a method reference, `Chronology::from`.
   * That method is equivalent to this query, except that it throws an
   * exception if a chronology cannot be obtained.
   *
   * @return a query that can obtain the chronology of a temporal, not null
  */
  static chronology(): TemporalQuery<Chronology>;
  /**
   * A query for the smallest supported unit.
   * 
   * This queries a `TemporalAccessor` for the time precision.
   * If the target `TemporalAccessor` represents a consistent or complete date-time,
   * date or time then this must return the smallest precision actually supported.
   * Note that fields such as `NANO_OF_DAY` and `NANO_OF_SECOND`
   * are defined to always return ignoring the precision, thus this is the only
   * way to find the actual smallest supported unit.
   * For example, were `GregorianCalendar` to implement `TemporalAccessor`
   * it would return a precision of `MILLIS`.
   * 
   * The result from JDK classes implementing `TemporalAccessor` is as follows:
   * `LocalDate` returns `DAYS`
   * `LocalTime` returns `NANOS`
   * `LocalDateTime` returns `NANOS`
   * `ZonedDateTime` returns `NANOS`
   * `OffsetTime` returns `NANOS`
   * `OffsetDateTime` returns `NANOS`
   * `ChronoLocalDate` returns `DAYS`
   * `ChronoLocalDateTime` returns `NANOS`
   * `ChronoZonedDateTime` returns `NANOS`
   * `Era` returns `ERAS`
   * `DayOfWeek` returns `DAYS`
   * `Month` returns `MONTHS`
   * `Year` returns `YEARS`
   * `YearMonth` returns `MONTHS`
   * `MonthDay` returns null (does not represent a complete date or time)
   * `ZoneOffset` returns null (does not represent a date or time)
   * `Instant` returns `NANOS`
   *
   * @return a query that can obtain the precision of a temporal, not null
  */
  static precision(): TemporalQuery<TemporalUnit>;
  /**
   * A lenient query for the `ZoneId`, falling back to the `ZoneOffset`.
   * 
   * This queries a `TemporalAccessor` for the zone.
   * It first tries to obtain the zone, using {@link #zoneId()}.
   * If that is not found it tries to obtain the {@link #offset()}.
   * Thus a {@link java.time.ZonedDateTime} will return the result of `getZone()`,
   * while an {@link java.time.OffsetDateTime} will return the result of `getOffset()`.
   * 
   * In most cases, applications should use this query rather than `#zoneId()`.
   * 
   * The method {@link ZoneId#from(TemporalAccessor)} can be used as a
   * `TemporalQuery` via a method reference, `ZoneId::from`.
   * That method is equivalent to this query, except that it throws an
   * exception if a zone cannot be obtained.
   *
   * @return a query that can obtain the zone ID or offset of a temporal, not null
  */
  static zone(): TemporalQuery<ZoneId>;
  /**
   * A query for `ZoneOffset` returning null if not found.
   * 
   * This returns a `TemporalQuery` that can be used to query a temporal
   * object for the offset. The query will return null if the temporal
   * object cannot supply an offset.
   * 
   * The query implementation examines the {@link ChronoField#OFFSET_SECONDS OFFSET_SECONDS}
   * field and uses it to create a `ZoneOffset`.
   * 
   * The method {@link java.time.ZoneOffset#from(TemporalAccessor)} can be used as a
   * `TemporalQuery` via a method reference, `ZoneOffset::from`.
   * This query and `ZoneOffset::from` will return the same result if the
   * temporal object contains an offset. If the temporal object does not contain
   * an offset, then the method reference will throw an exception, whereas this
   * query will return null.
   *
   * @return a query that can obtain the offset of a temporal, not null
  */
  static offset(): TemporalQuery<ZoneOffset>;
  /**
   * A query for `LocalDate` returning null if not found.
   * 
   * This returns a `TemporalQuery` that can be used to query a temporal
   * object for the local date. The query will return null if the temporal
   * object cannot supply a local date.
   * 
   * The query implementation examines the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field and uses it to create a `LocalDate`.
   * 
   * The method {@link LocalDate#from(TemporalAccessor)} can be used as a
   * `TemporalQuery` via a method reference, `LocalDate::from`.
   * This query and `LocalDate::from` will return the same result if the
   * temporal object contains a date. If the temporal object does not contain
   * a date, then the method reference will throw an exception, whereas this
   * query will return null.
   *
   * @return a query that can obtain the date of a temporal, not null
  */
  static localDate(): TemporalQuery<LocalDate>;
  /**
   * A query for `LocalTime` returning null if not found.
   * 
   * This returns a `TemporalQuery` that can be used to query a temporal
   * object for the local time. The query will return null if the temporal
   * object cannot supply a local time.
   * 
   * The query implementation examines the {@link ChronoField#NANO_OF_DAY NANO_OF_DAY}
   * field and uses it to create a `LocalTime`.
   * 
   * The method {@link LocalTime#from(TemporalAccessor)} can be used as a
   * `TemporalQuery` via a method reference, `LocalTime::from`.
   * This query and `LocalTime::from` will return the same result if the
   * temporal object contains a time. If the temporal object does not contain
   * a time, then the method reference will throw an exception, whereas this
   * query will return null.
   *
   * @return a query that can obtain the time of a temporal, not null
  */
  static localTime(): TemporalQuery<LocalTime>;
}
/**
 * A standard set of fields.
 * 
 * This set of fields provide field-based access to manipulate a date, time or date-time.
 * The standard set of fields can be extended by implementing {@link TemporalField}.
 * 
 * These fields are intended to be applicable in multiple calendar systems.
 * For example, most non-ISO calendar systems define dates as a year, month and day,
 * just with slightly different rules.
 * The documentation of each field explains how it operates.
 *
 * @implSpec
 * This is a final, immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class ChronoField extends Enum<ChronoField> {
  /**
   * The nano-of-second.
   * 
   * This counts the nanosecond within the second, from 0 to 999,999,999.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the nano-of-second handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_MINUTE}, {@link #SECOND_OF_DAY} or
   * {@link #INSTANT_SECONDS} filling unknown precision with zero.
   * 
   * When this field is used for setting a value, it should set as much precision as the
   * object stores, using integer division to remove excess precision.
   * For example, if the `TemporalAccessor` stores time to millisecond precision,
   * then the nano-of-second must be divided by 1,000,000 before replacing the milli-of-second.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The field is resolved in combination with `MILLI_OF_SECOND` and `MICRO_OF_SECOND`.
  */
  static readonly NANO_OF_SECOND: ChronoField;
  /**
   * The nano-of-day.
   * 
   * This counts the nanosecond within the day, from 0 to (24 * 60 * 60 * 1,000,000,000) - 1.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the nano-of-day handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_DAY} filling unknown precision with zero.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The value is split to form `NANO_OF_SECOND`, `SECOND_OF_MINUTE`,
   * `MINUTE_OF_HOUR` and `HOUR_OF_DAY` fields.
  */
  static readonly NANO_OF_DAY: ChronoField;
  /**
   * The micro-of-second.
   * 
   * This counts the microsecond within the second, from 0 to 999,999.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the micro-of-second handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_MINUTE}, {@link #SECOND_OF_DAY} or
   * {@link #INSTANT_SECONDS} filling unknown precision with zero.
   * 
   * When this field is used for setting a value, it should behave in the same way as
   * setting {@link #NANO_OF_SECOND} with the value multiplied by 1,000.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The field is resolved in combination with `MILLI_OF_SECOND` to produce
   * `NANO_OF_SECOND`.
  */
  static readonly MICRO_OF_SECOND: ChronoField;
  /**
   * The micro-of-day.
   * 
   * This counts the microsecond within the day, from 0 to (24 * 60 * 60 * 1,000,000) - 1.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the micro-of-day handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_DAY} filling unknown precision with zero.
   * 
   * When this field is used for setting a value, it should behave in the same way as
   * setting {@link #NANO_OF_DAY} with the value multiplied by 1,000.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The value is split to form `MICRO_OF_SECOND`, `SECOND_OF_MINUTE`,
   * `MINUTE_OF_HOUR` and `HOUR_OF_DAY` fields.
  */
  static readonly MICRO_OF_DAY: ChronoField;
  /**
   * The milli-of-second.
   * 
   * This counts the millisecond within the second, from 0 to 999.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the milli-of-second handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_MINUTE}, {@link #SECOND_OF_DAY} or
   * {@link #INSTANT_SECONDS} filling unknown precision with zero.
   * 
   * When this field is used for setting a value, it should behave in the same way as
   * setting {@link #NANO_OF_SECOND} with the value multiplied by 1,000,000.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The field is resolved in combination with `MICRO_OF_SECOND` to produce
   * `NANO_OF_SECOND`.
  */
  static readonly MILLI_OF_SECOND: ChronoField;
  /**
   * The milli-of-day.
   * 
   * This counts the millisecond within the day, from 0 to (24 * 60 * 60 * 1,000) - 1.
   * This field has the same meaning for all calendar systems.
   * 
   * This field is used to represent the milli-of-day handling any fraction of the second.
   * Implementations of `TemporalAccessor` should provide a value for this field if
   * they can return a value for {@link #SECOND_OF_DAY} filling unknown precision with zero.
   * 
   * When this field is used for setting a value, it should behave in the same way as
   * setting {@link #NANO_OF_DAY} with the value multiplied by 1,000,000.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The value is split to form `MILLI_OF_SECOND`, `SECOND_OF_MINUTE`,
   * `MINUTE_OF_HOUR` and `HOUR_OF_DAY` fields.
  */
  static readonly MILLI_OF_DAY: ChronoField;
  /**
   * The second-of-minute.
   * 
   * This counts the second within the minute, from 0 to 59.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
  */
  static readonly SECOND_OF_MINUTE: ChronoField;
  /**
   * The second-of-day.
   * 
   * This counts the second within the day, from 0 to (24 * 60 * 60) - 1.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The value is split to form `SECOND_OF_MINUTE`, `MINUTE_OF_HOUR`
   * and `HOUR_OF_DAY` fields.
  */
  static readonly SECOND_OF_DAY: ChronoField;
  /**
   * The minute-of-hour.
   * 
   * This counts the minute within the hour, from 0 to 59.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
  */
  static readonly MINUTE_OF_HOUR: ChronoField;
  /**
   * The minute-of-day.
   * 
   * This counts the minute within the day, from 0 to (24 * 60) - 1.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The value is split to form `MINUTE_OF_HOUR` and `HOUR_OF_DAY` fields.
  */
  static readonly MINUTE_OF_DAY: ChronoField;
  /**
   * The hour-of-am-pm.
   * 
   * This counts the hour within the AM/PM, from 0 to 11.
   * This is the hour that would be observed on a standard 12-hour digital clock.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated from 0 to 11 in strict and smart mode.
   * In lenient mode the value is not validated. It is combined with
   * `AMPM_OF_DAY` to form `HOUR_OF_DAY` by multiplying
   * the `AMPM_OF_DAY` value by 12.
   * 
   * See {@link #CLOCK_HOUR_OF_AMPM} for the related field that counts hours from 1 to 12.
  */
  static readonly HOUR_OF_AMPM: ChronoField;
  /**
   * The clock-hour-of-am-pm.
   * 
   * This counts the hour within the AM/PM, from 1 to 12.
   * This is the hour that would be observed on a standard 12-hour analog wall clock.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated from 1 to 12 in strict mode and from
   * 0 to 12 in smart mode. In lenient mode the value is not validated.
   * The field is converted to an `HOUR_OF_AMPM` with the same value,
   * unless the value is 12, in which case it is converted to 0.
   * 
   * See {@link #HOUR_OF_AMPM} for the related field that counts hours from 0 to 11.
  */
  static readonly CLOCK_HOUR_OF_AMPM: ChronoField;
  /**
   * The hour-of-day.
   * 
   * This counts the hour within the day, from 0 to 23.
   * This is the hour that would be observed on a standard 24-hour digital clock.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated in strict and smart mode but not in lenient mode.
   * The field is combined with `MINUTE_OF_HOUR`, `SECOND_OF_MINUTE` and
   * `NANO_OF_SECOND` to produce a `LocalTime`.
   * In lenient mode, any excess days are added to the parsed date, or
   * made available via {@link java.time.format.DateTimeFormatter#parsedExcessDays()}.
   * 
   * See {@link #CLOCK_HOUR_OF_DAY} for the related field that counts hours from 1 to 24.
  */
  static readonly HOUR_OF_DAY: ChronoField;
  /**
   * The clock-hour-of-day.
   * 
   * This counts the hour within the day, from 1 to 24.
   * This is the hour that would be observed on a 24-hour analog wall clock.
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated from 1 to 24 in strict mode and from
   * 0 to 24 in smart mode. In lenient mode the value is not validated.
   * The field is converted to an `HOUR_OF_DAY` with the same value,
   * unless the value is 24, in which case it is converted to 0.
   * 
   * See {@link #HOUR_OF_DAY} for the related field that counts hours from 0 to 23.
  */
  static readonly CLOCK_HOUR_OF_DAY: ChronoField;
  /**
   * The am-pm-of-day.
   * 
   * This counts the AM/PM within the day, from 0 (AM) to 1 (PM).
   * This field has the same meaning for all calendar systems.
   * 
   * When parsing this field it behaves equivalent to the following:
   * The value is validated from 0 to 1 in strict and smart mode.
   * In lenient mode the value is not validated. It is combined with
   * `HOUR_OF_AMPM` (if not present, it defaults to '6') to form
   * `HOUR_OF_DAY` by multiplying the `AMPM_OF_DAY` value
   * by 12.
  */
  static readonly AMPM_OF_DAY: ChronoField;
  /**
   * The day-of-week, such as Tuesday.
   * 
   * This represents the standard concept of the day of the week.
   * In the default ISO calendar system, this has values from Monday (1) to Sunday (7).
   * The {@link DayOfWeek} class can be used to interpret the result.
   * 
   * Most non-ISO calendar systems also define a seven day week that aligns with ISO.
   * Those calendar systems must also use the same numbering system, from Monday (1) to
   * Sunday (7), which allows `DayOfWeek` to be used.
   * 
   * Calendar systems that do not have a standard seven day week should implement this field
   * if they have a similar concept of named or numbered days within a period similar
   * to a week. It is recommended that the numbering starts from 1.
  */
  static readonly DAY_OF_WEEK: ChronoField;
  /**
   * The aligned day-of-week within a month.
   * 
   * This represents concept of the count of days within the period of a week
   * where the weeks are aligned to the start of the month.
   * This field is typically used with {@link #ALIGNED_WEEK_OF_MONTH}.
   * 
   * For example, in a calendar systems with a seven day week, the first aligned-week-of-month
   * starts on day-of-month 1, the second aligned-week starts on day-of-month 8, and so on.
   * Within each of these aligned-weeks, the days are numbered from 1 to 7 and returned
   * as the value of this field.
   * As such, day-of-month 1 to 7 will have aligned-day-of-week values from 1 to 7.
   * And day-of-month 8 to 14 will repeat this with aligned-day-of-week values from 1 to 7.
   * 
   * Calendar systems that do not have a seven day week should typically implement this
   * field in the same way, but using the alternate week length.
  */
  static readonly ALIGNED_DAY_OF_WEEK_IN_MONTH: ChronoField;
  /**
   * The aligned day-of-week within a year.
   * 
   * This represents concept of the count of days within the period of a week
   * where the weeks are aligned to the start of the year.
   * This field is typically used with {@link #ALIGNED_WEEK_OF_YEAR}.
   * 
   * For example, in a calendar systems with a seven day week, the first aligned-week-of-year
   * starts on day-of-year 1, the second aligned-week starts on day-of-year 8, and so on.
   * Within each of these aligned-weeks, the days are numbered from 1 to 7 and returned
   * as the value of this field.
   * As such, day-of-year 1 to 7 will have aligned-day-of-week values from 1 to 7.
   * And day-of-year 8 to 14 will repeat this with aligned-day-of-week values from 1 to 7.
   * 
   * Calendar systems that do not have a seven day week should typically implement this
   * field in the same way, but using the alternate week length.
  */
  static readonly ALIGNED_DAY_OF_WEEK_IN_YEAR: ChronoField;
  /**
   * The day-of-month.
   * 
   * This represents the concept of the day within the month.
   * In the default ISO calendar system, this has values from 1 to 31 in most months.
   * April, June, September, November have days from 1 to 30, while February has days
   * from 1 to 28, or 29 in a leap year.
   * 
   * Non-ISO calendar systems should implement this field using the most recognized
   * day-of-month values for users of the calendar system.
   * Normally, this is a count of days from 1 to the length of the month.
  */
  static readonly DAY_OF_MONTH: ChronoField;
  /**
   * The day-of-year.
   * 
   * This represents the concept of the day within the year.
   * In the default ISO calendar system, this has values from 1 to 365 in standard
   * years and 1 to 366 in leap years.
   * 
   * Non-ISO calendar systems should implement this field using the most recognized
   * day-of-year values for users of the calendar system.
   * Normally, this is a count of days from 1 to the length of the year.
   * 
   * Note that a non-ISO calendar system may have year numbering system that changes
   * at a different point to the natural reset in the month numbering. An example
   * of this is the Japanese calendar system where a change of era, which resets
   * the year number to 1, can happen on any date. The era and year reset also cause
   * the day-of-year to be reset to 1, but not the month-of-year or day-of-month.
  */
  static readonly DAY_OF_YEAR: ChronoField;
  /**
   * The epoch-day, based on the Java epoch of 1970-01-01 (ISO).
   * 
   * This field is the sequential count of days where 1970-01-01 (ISO) is zero.
   * Note that this uses the local time-line, ignoring offset and time-zone.
   * 
   * This field is strictly defined to have the same meaning in all calendar systems.
   * This is necessary to ensure interoperation between calendars.
   * 
   * Range of EpochDay is between (LocalDate.MIN.toEpochDay(), LocalDate.MAX.toEpochDay())
   * both inclusive.
  */
  static readonly EPOCH_DAY: ChronoField;
  /**
   * The aligned week within a month.
   * 
   * This represents concept of the count of weeks within the period of a month
   * where the weeks are aligned to the start of the month.
   * This field is typically used with {@link #ALIGNED_DAY_OF_WEEK_IN_MONTH}.
   * 
   * For example, in a calendar systems with a seven day week, the first aligned-week-of-month
   * starts on day-of-month 1, the second aligned-week starts on day-of-month 8, and so on.
   * Thus, day-of-month values 1 to 7 are in aligned-week 1, while day-of-month values
   * 8 to 14 are in aligned-week 2, and so on.
   * 
   * Calendar systems that do not have a seven day week should typically implement this
   * field in the same way, but using the alternate week length.
  */
  static readonly ALIGNED_WEEK_OF_MONTH: ChronoField;
  /**
   * The aligned week within a year.
   * 
   * This represents concept of the count of weeks within the period of a year
   * where the weeks are aligned to the start of the year.
   * This field is typically used with {@link #ALIGNED_DAY_OF_WEEK_IN_YEAR}.
   * 
   * For example, in a calendar systems with a seven day week, the first aligned-week-of-year
   * starts on day-of-year 1, the second aligned-week starts on day-of-year 8, and so on.
   * Thus, day-of-year values 1 to 7 are in aligned-week 1, while day-of-year values
   * 8 to 14 are in aligned-week 2, and so on.
   * 
   * Calendar systems that do not have a seven day week should typically implement this
   * field in the same way, but using the alternate week length.
  */
  static readonly ALIGNED_WEEK_OF_YEAR: ChronoField;
  /**
   * The month-of-year, such as March.
   * 
   * This represents the concept of the month within the year.
   * In the default ISO calendar system, this has values from January (1) to December (12).
   * 
   * Non-ISO calendar systems should implement this field using the most recognized
   * month-of-year values for users of the calendar system.
   * Normally, this is a count of months starting from 1.
  */
  static readonly MONTH_OF_YEAR: ChronoField;
  /**
   * The proleptic-month based, counting months sequentially from year 0.
   * 
   * This field is the sequential count of months where the first month
   * in proleptic-year zero has the value zero.
   * Later months have increasingly larger values.
   * Earlier months have increasingly small values.
   * There are no gaps or breaks in the sequence of months.
   * Note that this uses the local time-line, ignoring offset and time-zone.
   * 
   * In the default ISO calendar system, June 2012 would have the value
   * `(2012 * 12 + 6 - 1)`. This field is primarily for internal use.
   * 
   * Non-ISO calendar systems must implement this field as per the definition above.
   * It is just a simple zero-based count of elapsed months from the start of proleptic-year 0.
   * All calendar systems with a full proleptic-year definition will have a year zero.
   * If the calendar system has a minimum year that excludes year zero, then one must
   * be extrapolated in order for this method to be defined.
  */
  static readonly PROLEPTIC_MONTH: ChronoField;
  /**
   * The year within the era.
   * 
   * This represents the concept of the year within the era.
   * This field is typically used with {@link #ERA}.
   * 
   * The standard mental model for a date is based on three concepts - year, month and day.
   * These map onto the `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.
   * Note that there is no reference to eras.
   * The full model for a date requires four concepts - era, year, month and day. These map onto
   * the `ERA`, `YEAR_OF_ERA`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.
   * Whether this field or `YEAR` is used depends on which mental model is being used.
   * See {@link ChronoLocalDate} for more discussion on this topic.
   * 
   * In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'.
   * The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.
   * The era 'BCE' is the previous era, and the year-of-era runs backwards.
   * 
   * For example, subtracting a year each time yield the following:
   * - year-proleptic 2  = 'CE' year-of-era 2
   * - year-proleptic 1  = 'CE' year-of-era 1
   * - year-proleptic 0  = 'BCE' year-of-era 1
   * - year-proleptic -1 = 'BCE' year-of-era 2
   * 
   * Note that the ISO-8601 standard does not actually define eras.
   * Note also that the ISO eras do not align with the well-known AD/BC eras due to the
   * change between the Julian and Gregorian calendar systems.
   * 
   * Non-ISO calendar systems should implement this field using the most recognized
   * year-of-era value for users of the calendar system.
   * Since most calendar systems have only two eras, the year-of-era numbering approach
   * will typically be the same as that used by the ISO calendar system.
   * The year-of-era value should typically always be positive, however this is not required.
  */
  static readonly YEAR_OF_ERA: ChronoField;
  /**
   * The proleptic year, such as 2012.
   * 
   * This represents the concept of the year, counting sequentially and using negative numbers.
   * The proleptic year is not interpreted in terms of the era.
   * See {@link #YEAR_OF_ERA} for an example showing the mapping from proleptic year to year-of-era.
   * 
   * The standard mental model for a date is based on three concepts - year, month and day.
   * These map onto the `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.
   * Note that there is no reference to eras.
   * The full model for a date requires four concepts - era, year, month and day. These map onto
   * the `ERA`, `YEAR_OF_ERA`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` fields.
   * Whether this field or `YEAR_OF_ERA` is used depends on which mental model is being used.
   * See {@link ChronoLocalDate} for more discussion on this topic.
   * 
   * Non-ISO calendar systems should implement this field as follows.
   * If the calendar system has only two eras, before and after a fixed date, then the
   * proleptic-year value must be the same as the year-of-era value for the later era,
   * and increasingly negative for the earlier era.
   * If the calendar system has more than two eras, then the proleptic-year value may be
   * defined with any appropriate value, although defining it to be the same as ISO may be
   * the best option.
  */
  static readonly YEAR: ChronoField;
  /**
   * The era.
   * 
   * This represents the concept of the era, which is the largest division of the time-line.
   * This field is typically used with {@link #YEAR_OF_ERA}.
   * 
   * In the default ISO calendar system, there are two eras defined, 'BCE' and 'CE'.
   * The era 'CE' is the one currently in use and year-of-era runs from 1 to the maximum value.
   * The era 'BCE' is the previous era, and the year-of-era runs backwards.
   * See {@link #YEAR_OF_ERA} for a full example.
   * 
   * Non-ISO calendar systems should implement this field to define eras.
   * The value of the era that was active on 1970-01-01 (ISO) must be assigned the value 1.
   * Earlier eras must have sequentially smaller values.
   * Later eras must have sequentially larger values,
  */
  static readonly ERA: ChronoField;
  /**
   * The instant epoch-seconds.
   * 
   * This represents the concept of the sequential count of seconds where
   * 1970-01-01T00:00Z (ISO) is zero.
   * This field may be used with {@link #NANO_OF_SECOND} to represent the fraction of the second.
   * 
   * An {@link Instant} represents an instantaneous point on the time-line.
   * On their own, an instant has insufficient information to allow a local date-time to be obtained.
   * Only when paired with an offset or time-zone can the local date or time be calculated.
   * 
   * This field is strictly defined to have the same meaning in all calendar systems.
   * This is necessary to ensure interoperation between calendars.
  */
  static readonly INSTANT_SECONDS: ChronoField;
  /**
   * The offset from UTC/Greenwich.
   * 
   * This represents the concept of the offset in seconds of local time from UTC/Greenwich.
   * 
   * A {@link ZoneOffset} represents the period of time that local time differs from UTC/Greenwich.
   * This is usually a fixed number of hours and minutes.
   * It is equivalent to the {@link ZoneOffset#getTotalSeconds() total amount} of the offset in seconds.
   * For example, during the winter Paris has an offset of `+01:00`, which is 3600 seconds.
   * 
   * This field is strictly defined to have the same meaning in all calendar systems.
   * This is necessary to ensure interoperation between calendars.
  */
  static readonly OFFSET_SECONDS: ChronoField;
  static valueOf(name: string): ChronoField;
  static values(): ChronoField[];
  getDisplayName(locale: Locale): string;
  get baseUnit(): TemporalUnit;
  get rangeUnit(): TemporalUnit;
  /**
   * Gets the range of valid values for the field.
   * 
   * All fields can be expressed as a `long` integer.
   * This method returns an object that describes the valid range for that value.
   * 
   * This method returns the range of the field in the ISO-8601 calendar system.
   * This range may be incorrect for other calendar systems.
   * Use {@link Chronology#range(ChronoField)} to access the correct range
   * for a different calendar system.
   * 
   * Note that the result only describes the minimum and maximum valid values
   * and it is important not to read too much into them. For example, there
   * could be values within the range that are invalid for the field.
   *
   * @return the range of valid values for the field, not null
  */
  range(): ValueRange;
  /**
   * Checks if this field represents a component of a date.
   * 
   * Fields from day-of-week to era are date-based.
   *
   * @return true if it is a component of a date
  */
  isDateBased(): boolean;
  /**
   * Checks if this field represents a component of a time.
   * 
   * Fields from nano-of-second to am-pm-of-day are time-based.
   *
   * @return true if it is a component of a time
  */
  isTimeBased(): boolean;
  /**
   * Checks that the specified value is valid for this field.
   * 
   * This validates that the value is within the outer range of valid values
   * returned by {@link #range()}.
   * 
   * This method checks against the range of the field in the ISO-8601 calendar system.
   * This range may be incorrect for other calendar systems.
   * Use {@link Chronology#range(ChronoField)} to access the correct range
   * for a different calendar system.
   *
   * @param value  the value to check
   * @return the value that was passed in
  */
  checkValidValue(value: number): number;
  /**
   * Checks that the specified value is valid and fits in an `int`.
   * 
   * This validates that the value is within the outer range of valid values
   * returned by {@link #range()}.
   * It also checks that all valid values are within the bounds of an `int`.
   * 
   * This method checks against the range of the field in the ISO-8601 calendar system.
   * This range may be incorrect for other calendar systems.
   * Use {@link Chronology#range(ChronoField)} to access the correct range
   * for a different calendar system.
   *
   * @param value  the value to check
   * @return the value that was passed in
  */
  checkValidIntValue(value: number): number;
  isSupportedBy(temporal: TemporalAccessor): boolean;
  rangeRefinedBy(temporal: TemporalAccessor): ValueRange;
  getFrom(temporal: TemporalAccessor): number;
  adjustInto<R>(temporal: R, newValue: number): R;
  toString(): string;
}

}
declare module 'java.time.chrono' {
import { TextStyle, ResolverStyle, DateTimeFormatter } from 'java.time.format';
import { Locale, Set, List, Map, Comparator } from 'java.util';
import { Enum, Comparable } from 'java.lang';
import { LocalDateTime, LocalTime, ZoneId, ZonedDateTime, Instant, Period, Clock, LocalDate, ZoneOffset } from 'java.time';
import { Serializable } from 'java.io';
import { ConcurrentHashMap } from 'java.util.concurrent';
import { ValueRange, TemporalField, TemporalAccessor, Temporal, TemporalUnit, TemporalAmount, ChronoField, TemporalQuery, TemporalAdjuster } from 'java.time.temporal';
import { Path } from 'java.nio.file';
/**
 * A date in the Thai Buddhist calendar system.
 * 
 * This date operates using the {@linkplain ThaiBuddhistChronology Thai Buddhist calendar}.
 * This calendar system is primarily used in Thailand.
 * Dates are aligned such that `2484-01-01 (Buddhist)` is `1941-01-01 (ISO)`.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ThaiBuddhistDate extends ChronoLocalDate {
  /**
   * Obtains the current `ThaiBuddhistDate` from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date using the system clock and default time-zone, not null
  */
  static now(): ThaiBuddhistDate;
  /**
   * Obtains the current `ThaiBuddhistDate` from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date using the system clock, not null
  */
  static now(zone: ZoneId): ThaiBuddhistDate;
  /**
   * Obtains the current `ThaiBuddhistDate` from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@linkplain Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date, not null
   * @throws DateTimeException if the current date cannot be obtained
  */
  static now(clock: Clock): ThaiBuddhistDate;
  /**
   * Obtains a `ThaiBuddhistDate` representing a date in the Thai Buddhist calendar
   * system from the proleptic-year, month-of-year and day-of-month fields.
   * 
   * This returns a `ThaiBuddhistDate` with the specified fields.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param prolepticYear  the Thai Buddhist proleptic-year
   * @param month  the Thai Buddhist month-of-year, from 1 to 12
   * @param dayOfMonth  the Thai Buddhist day-of-month, from 1 to 31
   * @return the date in Thai Buddhist calendar system, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(prolepticYear: number, month: number, dayOfMonth: number): ThaiBuddhistDate;
  /**
   * Obtains a `ThaiBuddhistDate` from a temporal object.
   * 
   * This obtains a date in the Thai Buddhist calendar system based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ThaiBuddhistDate`.
   * 
   * The conversion typically uses the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field, which is standardized across calendar systems.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ThaiBuddhistDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date in Thai Buddhist calendar system, not null
   * @throws DateTimeException if unable to convert to a `ThaiBuddhistDate`
  */
  static from(temporal: TemporalAccessor): ThaiBuddhistDate;
  /**
   * Gets the chronology of this date, which is the Thai Buddhist calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the Thai Buddhist chronology, not null
  */
  get chronology(): ThaiBuddhistChronology;
  /**
   * Gets the era applicable at this date.
   * 
   * The Thai Buddhist calendar system has two eras, 'BE' and 'BEFORE_BE',
   * defined by {@link ThaiBuddhistEra}.
   *
   * @return the era applicable at this date, not null
  */
  get era(): ThaiBuddhistEra;
  /**
   * Returns the length of the month represented by this date.
   * 
   * This returns the length of the month in days.
   * Month lengths match those of the ISO calendar system.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  range(field: TemporalField): ValueRange;
  getLong(field: TemporalField): number;
  with(field: TemporalField, newValue: number): ThaiBuddhistDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): ThaiBuddhistDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): ThaiBuddhistDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): ThaiBuddhistDate;
  plus(amountToAdd: number, unit: TemporalUnit): ThaiBuddhistDate;
  minus(amountToSubtract: number, unit: TemporalUnit): ThaiBuddhistDate;
  atTime(localTime: LocalTime): ChronoLocalDateTime<ThaiBuddhistDate>;
  until(endDate: ChronoLocalDate): ChronoPeriod;
  toEpochDay(): number;
  /**
   * Compares this date to another date, including the chronology.
   * 
   * Compares this `ThaiBuddhistDate` with another ensuring that the date is the same.
   * 
   * Only objects of type `ThaiBuddhistDate` are compared, other types return false.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code based only on the Chronology and the date
  */
  hashCode(): number;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ChronoLocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `ChronoLocalDate` using {@link Chronology#date(TemporalAccessor)}.
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * should be supported by all implementations.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a
   *  `ChronoLocalDate` in the same chronology, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ChronoLocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
}
export interface ThaiBuddhistDate extends ChronoLocalDate, Serializable {}
/**
 * An era in the Japanese Imperial calendar system.
 * 
 * The Japanese government defines the official name and start date of
 * each era. Eras are consecutive and their date ranges do not overlap,
 * so the end date of one era is always the day before the start date
 * of the next era.
 * 
 * The Java SE Platform supports all eras defined by the Japanese government,
 * beginning with the Meiji era. Each era is identified in the Platform by an
 * integer value and a name. The {@link #of(int)} and {@link #valueOf(String)}
 * methods may be used to obtain a singleton instance of `JapaneseEra`
 * for each era. The {@link #values()} method returns the singleton instances
 * of all supported eras.
 * 
 * For convenience, this class declares a number of public static final fields
 * that refer to singleton instances returned by the {@link #values()} method.
 *
 * @apiNote
 * The fields declared in this class may evolve over time, in line with the
 * results of the {@link #values()} method. However, there is not necessarily
 * a 1:1 correspondence between the fields and the singleton instances.
 *
 * @apiNote
 * The Japanese government may announce a new era and define its start
 * date but not its official name. In this scenario, the singleton instance
 * that represents the new era may return a name that is not stable until
 * the official name is defined. Developers should exercise caution when
 * relying on the name returned by any singleton instance that does not
 * correspond to a public static final field.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class JapaneseEra extends Era {
  /**
   * The singleton instance for the 'Meiji' era (1868-01-01 - 1912-07-29)
   * which has the value -1.
  */
  static readonly MEIJI: JapaneseEra;
  /**
   * The singleton instance for the 'Taisho' era (1912-07-30 - 1926-12-24)
   * which has the value 0.
  */
  static readonly TAISHO: JapaneseEra;
  /**
   * The singleton instance for the 'Showa' era (1926-12-25 - 1989-01-07)
   * which has the value 1.
  */
  static readonly SHOWA: JapaneseEra;
  /**
   * The singleton instance for the 'Heisei' era (1989-01-08 - 2019-04-30)
   * which has the value 2.
  */
  static readonly HEISEI: JapaneseEra;
  /**
   * The singleton instance for the 'Reiwa' era (2019-05-01 - )
   * which has the value 3. The end date of this era is not specified, unless
   * the Japanese Government defines it.
   *
   * @since 13
  */
  static readonly REIWA: JapaneseEra;
  /**
   * Obtains an instance of `JapaneseEra` from an `int` value.
   * 
   * The value `1` is associated with the 'Showa' era, because
   * it contains 1970-01-01 (ISO calendar system).
   * The values `-1` and `0` are associated with two earlier
   * eras, Meiji and Taisho, respectively.
   * A value greater than `1` is associated with a later era,
   * beginning with Heisei (`2`).
   * 
   * 
   * Every instance of `JapaneseEra` that is returned from the {@link #values()}
   * method has an int value (available via {@link Era#getValue()} which is
   * accepted by this method.
   *
   * @param japaneseEra  the era to represent
   * @return the `JapaneseEra` singleton, not null
   * @throws DateTimeException if the value is invalid
  */
  static of(japaneseEra: number): JapaneseEra;
  /**
   * Returns the `JapaneseEra` with the name.
   * 
   * The string must match exactly the name of the era.
   * (Extraneous whitespace characters are not permitted.)
   * 
   * Valid era names are the names of eras returned from {@link #values()}.
   *
   * @param japaneseEra  the japaneseEra name; non-null
   * @return the `JapaneseEra` singleton, never null
   * @throws IllegalArgumentException if there is not JapaneseEra with the specified name
  */
  static valueOf(japaneseEra: string): JapaneseEra;
  /**
   * Returns an array of JapaneseEras. The array may contain eras defined
   * by the Japanese government beyond the known era singletons.
   *
   * 
   * This method may be used to iterate over the JapaneseEras as follows:
   *      * for (JapaneseEra c : JapaneseEra.values())
   *     System.out.println(c);
   * 
   *
   * @return an array of JapaneseEras
  */
  static values(): JapaneseEra[];
  /**
   * {@inheritDoc}
   *
   * @param style {@inheritDoc}
   * @param locale {@inheritDoc}
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
  /**
   * Gets the numeric era `int` value.
   * 
   * The {@link #SHOWA} era that contains 1970-01-01 (ISO calendar system) has the value 1.
   * Later eras are numbered from 2 ({@link #HEISEI}).
   * Earlier eras are numbered 0 ({@link #TAISHO}), -1 ({@link #MEIJI})).
   *
   * @return the era value
  */
  get value(): number;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This era is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns the range.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   * 
   * The range of valid Japanese eras can change over time due to the nature
   * of the Japanese calendar system.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  range(field: TemporalField): ValueRange;
  toString(): string;
}
export interface JapaneseEra extends Era, Serializable {}
/**
 * An era of the time-line.
 * 
 * Most calendar systems have a single epoch dividing the time-line into two eras.
 * However, some calendar systems, have multiple eras, such as one for the reign
 * of each leader.
 * In all cases, the era is conceptually the largest division of the time-line.
 * Each chronology defines the Era's that are known Eras and a
 * {@link Chronology#eras Chronology.eras} to get the valid eras.
 * 
 * For example, the Thai Buddhist calendar system divides time into two eras,
 * before and after a single date. By contrast, the Japanese calendar system
 * has one era for the reign of each Emperor.
 * 
 * Instances of `Era` may be compared using the `==` operator.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations must be singletons - final, immutable and thread-safe.
 * It is recommended to use an enum whenever possible.
 *
 * @since 1.8
*/
export class Era extends TemporalAccessor {
  /**
   * Gets the numeric value associated with the era as defined by the chronology.
   * Each chronology defines the predefined Eras and methods to list the Eras
   * of the chronology.
   * 
   * All fields, including eras, have an associated numeric value.
   * The meaning of the numeric value for era is determined by the chronology
   * according to these principles:
   * 
   * The era in use at the epoch 1970-01-01 (ISO) has the value 1.
   * Later eras have sequentially higher values.
   * Earlier eras have sequentially lower values, which may be negative.
   * 
   *
   * @return the numeric era value
  */
  get value(): number;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this era can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns true.
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this era, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This era is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns the range.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   * 
   * The default implementation must return a range for `ERA` from
   * zero to one, suitable for two era calendar systems such as ISO.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * Gets the value of the specified field from this era as an `int`.
   * 
   * This queries this era for the value of the specified field.
   * The returned value will always be within the valid range of values for the field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns the value of the era.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained or
   *         the value is outside the range of valid values for the field
   * @throws UnsupportedTemporalTypeException if the field is not supported or
   *         the range of values exceeds an `int`
   * @throws ArithmeticException if numeric overflow occurs
  */
  get(field: TemporalField): number;
  /**
   * Gets the value of the specified field from this era as a `long`.
   * 
   * This queries this era for the value of the specified field.
   * If it is not possible to return the value, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns the value of the era.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.getFrom(TemporalAccessor)`
   * passing `this` as the argument. Whether the value can be obtained,
   * and what the value represents, is determined by the field.
   *
   * @param field  the field to get, not null
   * @return the value for the field
   * @throws DateTimeException if a value for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the field is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  getLong(field: TemporalField): number;
  /**
   * Queries this era using the specified query.
   * 
   * This queries this era using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same era as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the era changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#ERA} as the field.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisEra.adjustInto(temporal);
   *   temporal = temporal.with(thisEra);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Gets the textual representation of this era.
   * 
   * This returns the textual name used to identify the era,
   * suitable for presentation to the user.
   * The parameters control the style of the returned text and the locale.
   * 
   * If no textual mapping is found then the {@link #getValue() numeric value} is returned.
   *
   * @apiNote This default implementation is suitable for most implementations.
   *
   * @param style  the style of the text required, not null
   * @param locale  the locale to use, not null
   * @return the text value of the era, not null
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
}
export interface Era extends TemporalAccessor, TemporalAdjuster {}
/**
 * The Minguo calendar system.
 * 
 * This chronology defines the rules of the Minguo calendar system.
 * This calendar system is primarily used in the Republic of China, often known as Taiwan.
 * Dates are aligned such that `0001-01-01 (Minguo)` is `1912-01-01 (ISO)`.
 * 
 * The fields are defined as follows:
 * 
 * era - There are two eras, the current 'Republic' (ERA_ROC) and the previous era (ERA_BEFORE_ROC).
 * year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.
 *  For the previous era the year increases from one as time goes backwards.
 *  The value for the current era is equal to the ISO proleptic-year minus 1911.
 * proleptic-year - The proleptic year is the same as the year-of-era for the
 *  current era. For the previous era, years have zero, then negative values.
 *  The value is equal to the ISO proleptic-year minus 1911.
 * month-of-year - The Minguo month-of-year exactly matches ISO.
 * day-of-month - The Minguo day-of-month exactly matches ISO.
 * day-of-year - The Minguo day-of-year exactly matches ISO.
 * leap-year - The Minguo leap-year pattern exactly matches ISO, such that the two calendars
 *  are never out of step.
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class MinguoChronology extends AbstractChronology {
  /**
   * Singleton instance for the Minguo chronology.
  */
  static readonly INSTANCE: MinguoChronology;
  /**
   * Gets the ID of the chronology - 'Minguo'.
   * 
   * The ID uniquely identifies the `Chronology`.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the chronology ID - 'Minguo'
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the underlying calendar system - 'roc'.
   * 
   * The calendar type is an identifier defined by the
   * Unicode Locale Data Markup Language (LDML) specification.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   * It can also be used as part of a locale, accessible via
   * {@link Locale#getUnicodeLocaleType(String)} with the key 'ca'.
   *
   * @return the calendar system type - 'roc'
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains a local date in Minguo calendar system from the
   * era, year-of-era, month-of-year and day-of-month fields.
   *
   * @param era  the Minguo era, not null
   * @param yearOfEra  the year-of-era
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Minguo local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `MinguoEra`
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): MinguoDate;
  /**
   * Obtains a local date in Minguo calendar system from the
   * proleptic-year, month-of-year and day-of-month fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Minguo local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): MinguoDate;
  /**
   * Obtains a local date in Minguo calendar system from the
   * era, year-of-era and day-of-year fields.
   *
   * @param era  the Minguo era, not null
   * @param yearOfEra  the year-of-era
   * @param dayOfYear  the day-of-year
   * @return the Minguo local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `MinguoEra`
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): MinguoDate;
  /**
   * Obtains a local date in Minguo calendar system from the
   * proleptic-year and day-of-year fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param dayOfYear  the day-of-year
   * @return the Minguo local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): MinguoDate;
  /**
   * Obtains a local date in the Minguo calendar system from the epoch-day.
   *
   * @param epochDay  the epoch day
   * @return the Minguo local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): MinguoDate;
  dateNow(): MinguoDate;
  dateNow(zone: ZoneId): MinguoDate;
  dateNow(clock: Clock): MinguoDate;
  date(temporal: TemporalAccessor): MinguoDate;
  localDateTime(temporal: TemporalAccessor): ChronoLocalDateTime<MinguoDate>;
  zonedDateTime(temporal: TemporalAccessor): ChronoZonedDateTime<MinguoDate>;
  zonedDateTime(instant: Instant, zone: ZoneId): ChronoZonedDateTime<MinguoDate>;
  /**
   * Checks if the specified year is a leap year.
   * 
   * Minguo leap years occur exactly in line with ISO leap years.
   * This method does not validate the year passed in, and only has a
   * well-defined result for years in the supported range.
   *
   * @param prolepticYear  the proleptic-year to check, not validated for range
   * @return true if the year is a leap year
  */
  isLeapYear(prolepticYear: number): boolean;
  prolepticYear(era: Era, yearOfEra: number): number;
  eraOf(eraValue: number): MinguoEra;
  eras(): Era[];
  range(field: ChronoField): ValueRange;
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): MinguoDate;
  /**
   * `MinguoChronology` is an ISO based chronology, which supports fields
   * in {@link IsoFields}, such as {@link IsoFields#DAY_OF_QUARTER DAY_OF_QUARTER}
   * and {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR}.
   * @see IsoFields
   * @return `true`
   * @since 19
  */
  isIsoBased(): boolean;
}
export interface MinguoChronology extends AbstractChronology, Serializable {}
/**
 * A date in the Hijrah calendar system.
 * 
 * This date operates using one of several variants of the
 * {@linkplain HijrahChronology Hijrah calendar}.
 * 
 * The Hijrah calendar has a different total of days in a year than
 * Gregorian calendar, and the length of each month is based on the period
 * of a complete revolution of the moon around the earth
 * (as between successive new moons).
 * Refer to the {@link HijrahChronology} for details of supported variants.
 * 
 * Each HijrahDate is created bound to a particular HijrahChronology,
 * The same chronology is propagated to each HijrahDate computed from the date.
 * To use a different Hijrah variant, its HijrahChronology can be used
 * to create new HijrahDate instances.
 * Alternatively, the {@link #withVariant} method can be used to convert
 * to a new HijrahChronology.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class HijrahDate extends ChronoLocalDate {
  /**
   * Obtains the current `HijrahDate` of the Islamic Umm Al-Qura calendar
   * in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date using the system clock and default time-zone, not null
  */
  static now(): HijrahDate;
  /**
   * Obtains the current `HijrahDate` of the Islamic Umm Al-Qura calendar
   * in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date using the system clock, not null
  */
  static now(zone: ZoneId): HijrahDate;
  /**
   * Obtains the current `HijrahDate` of the Islamic Umm Al-Qura calendar
   * from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@linkplain Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date, not null
   * @throws DateTimeException if the current date cannot be obtained
  */
  static now(clock: Clock): HijrahDate;
  /**
   * Obtains a `HijrahDate` of the Islamic Umm Al-Qura calendar
   * from the proleptic-year, month-of-year and day-of-month fields.
   * 
   * This returns a `HijrahDate` with the specified fields.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param prolepticYear  the Hijrah proleptic-year
   * @param month  the Hijrah month-of-year, from 1 to 12
   * @param dayOfMonth  the Hijrah day-of-month, from 1 to 30
   * @return the date in Hijrah calendar system, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(prolepticYear: number, month: number, dayOfMonth: number): HijrahDate;
  /**
   * Obtains a `HijrahDate` of the Islamic Umm Al-Qura calendar from a temporal object.
   * 
   * This obtains a date in the Hijrah calendar system based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `HijrahDate`.
   * 
   * The conversion typically uses the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field, which is standardized across calendar systems.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `HijrahDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date in Hijrah calendar system, not null
   * @throws DateTimeException if unable to convert to a `HijrahDate`
  */
  static from(temporal: TemporalAccessor): HijrahDate;
  /**
   * Gets the chronology of this date, which is the Hijrah calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the Hijrah chronology, not null
  */
  get chronology(): HijrahChronology;
  /**
   * Gets the era applicable at this date.
   * 
   * The Hijrah calendar system has one era, 'AH',
   * defined by {@link HijrahEra}.
   *
   * @return the era applicable at this date, not null
  */
  get era(): HijrahEra;
  /**
   * Returns the length of the month represented by this date.
   * 
   * This returns the length of the month in days.
   * Month lengths in the Hijrah calendar system vary between 29 and 30 days.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  /**
   * Returns the length of the year represented by this date.
   * 
   * This returns the length of the year in days.
   * A Hijrah calendar system year is typically shorter than
   * that of the ISO calendar system.
   *
   * @return the length of the year in days
  */
  lengthOfYear(): number;
  range(field: TemporalField): ValueRange;
  getLong(field: TemporalField): number;
  with(field: TemporalField, newValue: number): HijrahDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException if unable to make the adjustment.
   *     For example, if the adjuster requires an ISO chronology
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): HijrahDate;
  /**
   * Returns a `HijrahDate` with the Chronology requested.
   * 
   * The year, month, and day are checked against the new requested
   * HijrahChronology.  If the chronology has a shorter month length
   * for the month, the day is reduced to be the last day of the month.
   *
   * @param chronology the new HijrahChonology, non-null
   * @return a HijrahDate with the requested HijrahChronology, non-null
  */
  withVariant(chronology: HijrahChronology): HijrahDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): HijrahDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): HijrahDate;
  toEpochDay(): number;
  /**
   * Checks if the year is a leap year, according to the Hijrah calendar system rules.
   *
   * @return true if this date is in a leap year
  */
  isLeapYear(): boolean;
  plus(amountToAdd: number, unit: TemporalUnit): HijrahDate;
  minus(amountToSubtract: number, unit: TemporalUnit): HijrahDate;
  atTime(localTime: LocalTime): ChronoLocalDateTime<HijrahDate>;
  until(endDate: ChronoLocalDate): ChronoPeriod;
  /**
   * Compares this date to another date, including the chronology.
   * 
   * Compares this `HijrahDate` with another ensuring that the date is the same.
   * 
   * Only objects of type `HijrahDate` are compared, other types return false.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date and the Chronologies are equal
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code based only on the Chronology and the date
  */
  hashCode(): number;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ChronoLocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `ChronoLocalDate` using {@link Chronology#date(TemporalAccessor)}.
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * should be supported by all implementations.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a
   *  `ChronoLocalDate` in the same chronology, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ChronoLocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
}
export interface HijrahDate extends ChronoLocalDate, Serializable {}
/**
 * A date-time without a time-zone in an arbitrary chronology, intended
 * for advanced globalization use cases.
 * 
 * Most applications should declare method signatures, fields and variables
 * as {@link LocalDateTime}, not this interface.
 * 
 * A `ChronoLocalDateTime` is the abstract representation of a local date-time
 * where the `Chronology chronology`, or calendar system, is pluggable.
 * The date-time is defined in terms of fields expressed by {@link TemporalField},
 * where most common implementations are defined in {@link ChronoField}.
 * The chronology defines how the calendar system operates and the meaning of
 * the standard fields.
 *
 * When to use this interface
 * The design of the API encourages the use of `LocalDateTime` rather than this
 * interface, even in the case where the application needs to deal with multiple
 * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.
 * 
 * Ensure that the discussion in `ChronoLocalDate` has been read and understood
 * before using this interface.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @param  the concrete type for the date of this date-time
 * @since 1.8
*/
export class ChronoLocalDateTime<D> extends Temporal {
  /**
   * Gets a comparator that compares `ChronoLocalDateTime` in
   * time-line order ignoring the chronology.
   * 
   * This comparator differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date-time and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the position of the date-time on the local time-line.
   * The underlying comparison is equivalent to comparing the epoch-day and nano-of-day.
   *
   * @return a comparator that compares in time-line order ignoring the chronology
   * @see #isAfter
   * @see #isBefore
   * @see #isEqual
  */
  static timeLineOrder(): Comparator<ChronoLocalDateTime<any>>;
  /**
   * Obtains an instance of `ChronoLocalDateTime` from a temporal object.
   * 
   * This obtains a local date-time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoLocalDateTime`.
   * 
   * The conversion extracts and combines the chronology and the date-time
   * from the temporal object. The behavior is equivalent to using
   * {@link Chronology#localDateTime(TemporalAccessor)} with the extracted chronology.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ChronoLocalDateTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date-time, not null
   * @throws DateTimeException if unable to convert to a `ChronoLocalDateTime`
   * @see Chronology#localDateTime(TemporalAccessor)
  */
  static from(temporal: TemporalAccessor): ChronoLocalDateTime<any>;
  /**
   * Gets the chronology of this date-time.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the chronology, not null
  */
  get chronology(): Chronology;
  /**
   * Gets the local date part of this date-time.
   * 
   * This returns a local date with the same year, month and day
   * as this date-time.
   *
   * @return the date part of this date-time, not null
  */
  toLocalDate(): D;
  /**
   * Gets the local time part of this date-time.
   * 
   * This returns a local time with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if the specified field can be queried on this date-time.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * The set of supported fields is defined by the chronology and normally includes
   * all `ChronoField` date and time fields.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field can be queried, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to or subtracted from this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * The set of supported units is defined by the chronology and normally includes
   * all `ChronoUnit` units except `FOREVER`.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): ChronoLocalDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(field: TemporalField, newValue: number): ChronoLocalDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): ChronoLocalDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amountToAdd: number, unit: TemporalUnit): ChronoLocalDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): ChronoLocalDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amountToSubtract: number, unit: TemporalUnit): ChronoLocalDateTime<D>;
  /**
   * Queries this date-time using the specified query.
   * 
   * This queries this date-time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same date and time as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the date and time changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * twice, passing {@link ChronoField#EPOCH_DAY} and
   * {@link ChronoField#NANO_OF_DAY} as the fields.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisLocalDateTime.adjustInto(temporal);
   *   temporal = temporal.with(thisLocalDateTime);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Formats this date-time using the specified formatter.
   * 
   * This date-time will be passed to the formatter to produce a string.
   * 
   * The default implementation must behave as follows:
   *      *  return formatter.format(this);
   * 
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date-time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this time with a time-zone to create a `ChronoZonedDateTime`.
   * 
   * This returns a `ChronoZonedDateTime` formed from this date-time at the
   * specified time-zone. The result will match this date-time as closely as possible.
   * Time-zone rules, such as daylight savings, mean that not every local date-time
   * is valid for the specified zone, thus the local date-time may be adjusted.
   * 
   * The local date-time is resolved to a single instant on the time-line.
   * This is achieved by finding a valid offset from UTC/Greenwich for the local
   * date-time as defined by the {@link ZoneRules rules} of the zone ID.
   *
   * In most cases, there is only one valid offset for a local date-time.
   * In the case of an overlap, where clocks are set back, there are two valid offsets.
   * This method uses the earlier offset typically corresponding to "summer".
   * 
   * In the case of a gap, where clocks jump forward, there is no valid offset.
   * Instead, the local date-time is adjusted to be later by the length of the gap.
   * For a typical one hour daylight savings change, the local date-time will be
   * moved one hour later into the offset typically corresponding to "summer".
   * 
   * To obtain the later offset during an overlap, call
   * {@link ChronoZonedDateTime#withLaterOffsetAtOverlap()} on the result of this method.
   *
   * @param zone  the time-zone to use, not null
   * @return the zoned date-time formed from this date-time, not null
  */
  atZone(zone: ZoneId): ChronoZonedDateTime<D>;
  /**
   * Converts this date-time to an `Instant`.
   * 
   * This combines this local date-time and the specified offset to form
   * an `Instant`.
   * 
   * This default implementation calculates from the epoch-day of the date and the
   * second-of-day of the time.
   *
   * @param offset  the offset to use for the conversion, not null
   * @return an `Instant` representing the same instant, not null
  */
  toInstant(offset: ZoneOffset): Instant;
  /**
   * Converts this date-time to the number of seconds from the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * This combines this local date-time and the specified offset to calculate the
   * epoch-second value, which is the number of elapsed seconds from 1970-01-01T00:00:00Z.
   * Instants on the time-line after the epoch are positive, earlier are negative.
   * 
   * This default implementation calculates from the epoch-day of the date and the
   * second-of-day of the time.
   *
   * @param offset  the offset to use for the conversion, not null
   * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z
  */
  toEpochSecond(offset: ZoneOffset): number;
  /**
   * Compares this date-time to another date-time, including the chronology.
   * 
   * The comparison is based first on the underlying time-line date-time, then
   * on the chronology.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * For example, the following is the comparator order:
   * 
   * `2012-12-03T12:00 (ISO)`
   * `2012-12-04T12:00 (ISO)`
   * `2555-12-04T12:00 (ThaiBuddhist)`
   * `2012-12-05T12:00 (ISO)`
   * 
   * Values #2 and #3 represent the same date-time on the time-line.
   * When two values represent the same date-time, the chronology ID is compared to distinguish them.
   * This step is needed to make the ordering "consistent with equals".
   * 
   * If all the date-time objects being compared are in the same chronology, then the
   * additional chronology stage is not required and only the local date-time is used.
   * 
   * This default implementation performs the comparison defined above.
   *
   * @param other  the other date-time to compare to, not null
   * @return the comparator value, that is the comparison of this local date-time with
   *          the `other` local date-time and this chronology with the `other` chronology,
   *          in order, returning the first non-zero result, and otherwise returning zero
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: ChronoLocalDateTime<any>): number;
  /**
   * Checks if this date-time is after the specified date-time ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date-time and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the time-line position.
   * 
   * This default implementation performs the comparison based on the epoch-day
   * and nano-of-day.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this is after the specified date-time
  */
  isAfter(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is before the specified date-time ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date-time and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the time-line position.
   * 
   * This default implementation performs the comparison based on the epoch-day
   * and nano-of-day.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this is before the specified date-time
  */
  isBefore(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is equal to the specified date-time ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date and time and not the chronology.
   * This allows date-times in different calendar systems to be compared based
   * on the time-line position.
   * 
   * This default implementation performs the comparison based on the epoch-day
   * and nano-of-day.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if the underlying date-time is equal to the specified date-time on the timeline
  */
  isEqual(other: ChronoLocalDateTime<any>): boolean;
  /**
   * Checks if this date-time is equal to another date-time, including the chronology.
   * 
   * Compares this date-time with another ensuring that the date-time and chronology are the same.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date-time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date-time as a `String`.
   * 
   * The output will include the full local date-time.
   *
   * @return a string representation of this date-time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface ChronoLocalDateTime<D> extends Temporal, TemporalAdjuster, Comparable<ChronoLocalDateTime<any>> {}
/**
 * A calendar system, used to organize and identify dates.
 * 
 * The main date and time API is built on the ISO calendar system.
 * The chronology operates behind the scenes to represent the general concept of a calendar system.
 * For example, the Japanese, Minguo, Thai Buddhist and others.
 * 
 * Most other calendar systems also operate on the shared concepts of year, month and day,
 * linked to the cycles of the Earth around the Sun, and the Moon around the Earth.
 * These shared concepts are defined by {@link ChronoField} and are available
 * for use by any `Chronology` implementation:
 *  *   LocalDate isoDate = ...
 *   ThaiBuddhistDate thaiDate = ...
 *   int isoYear = isoDate.get(ChronoField.YEAR);
 *   int thaiYear = thaiDate.get(ChronoField.YEAR);
 * 
 * As shown, although the date objects are in different calendar systems, represented by different
 * `Chronology` instances, both can be queried using the same constant on `ChronoField`.
 * For a full discussion of the implications of this, see {@link ChronoLocalDate}.
 * In general, the advice is to use the known ISO-based `LocalDate`, rather than
 * `ChronoLocalDate`.
 * 
 * While a `Chronology` object typically uses `ChronoField` and is based on
 * an era, year-of-era, month-of-year, day-of-month model of a date, this is not required.
 * A `Chronology` instance may represent a totally different kind of calendar system,
 * such as the Mayan.
 * 
 * In practical terms, the `Chronology` instance also acts as a factory.
 * The {@link #of(String)} method allows an instance to be looked up by identifier,
 * while the {@link #ofLocale(Locale)} method allows lookup by locale.
 * 
 * The `Chronology` instance provides a set of methods to create `ChronoLocalDate` instances.
 * The date classes are used to manipulate specific dates.
 * 
 *  {@link #dateNow() dateNow()}
 *  {@link #dateNow(Clock) dateNow(clock)}
 *  {@link #dateNow(ZoneId) dateNow(zone)}
 *  {@link #date(int, int, int) date(yearProleptic, month, day)}
 *  {@link #date(Era, int, int, int) date(era, yearOfEra, month, day)}
 *  {@link #dateYearDay(int, int) dateYearDay(yearProleptic, dayOfYear)}
 *  {@link #dateYearDay(Era, int, int) dateYearDay(era, yearOfEra, dayOfYear)}
 *  {@link #date(TemporalAccessor) date(TemporalAccessor)}
 * 
 *
 * Adding New Calendars
 * The set of available chronologies can be extended by applications.
 * Adding a new calendar system requires the writing of an implementation of
 * `Chronology`, `ChronoLocalDate` and `Era`.
 * The majority of the logic specific to the calendar system will be in the
 * `ChronoLocalDate` implementation.
 * The `Chronology` implementation acts as a factory.
 * 
 * To permit the discovery of additional chronologies, the {@link java.util.ServiceLoader ServiceLoader}
 * is used. A file must be added to the `META-INF/services` directory with the
 * name 'java.time.chrono.Chronology' listing the implementation classes.
 * See the ServiceLoader for more details on service loading.
 * For lookup by id or calendarType, the system provided calendars are found
 * first followed by application provided calendars.
 * 
 * Each chronology must define a chronology ID that is unique within the system.
 * If the chronology represents a calendar system defined by the
 * CLDR specification then the calendar type is the concatenation of the
 * CLDR type and, if applicable, the CLDR variant.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @since 1.8
*/
export class Chronology extends Comparable<Chronology> {
  /**
   * Obtains an instance of `Chronology` from a temporal object.
   * 
   * This obtains a chronology based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `Chronology`.
   * 
   * The conversion will obtain the chronology using {@link TemporalQueries#chronology()}.
   * If the specified temporal object does not have a chronology, {@link IsoChronology} is returned.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `Chronology::from`.
   *
   * @param temporal  the temporal to convert, not null
   * @return the chronology, not null
   * @throws DateTimeException if unable to convert to a `Chronology`
  */
  static from(temporal: TemporalAccessor): Chronology;
  /**
   * Obtains an instance of `Chronology` from a locale.
   * 
   * This returns a `Chronology` based on the specified locale,
   * typically returning `IsoChronology`. Other calendar systems
   * are only returned if they are explicitly selected within the locale.
   * 
   * The {@link Locale} class provide access to a range of information useful
   * for localizing an application. This includes the language and region,
   * such as "en-GB" for English as used in Great Britain.
   * 
   * The `Locale` class also supports an extension mechanism that
   * can be used to identify a calendar system. The mechanism is a form
   * of key-value pairs, where the calendar system has the key "ca".
   * For example, the locale "en-JP-u-ca-japanese" represents the English
   * language as used in Japan with the Japanese calendar system.
   * 
   * This method finds the desired calendar system in a manner equivalent
   * to passing "ca" to {@link Locale#getUnicodeLocaleType(String)}.
   * If the "ca" key is not present, then `IsoChronology` is returned.
   * 
   * Note that the behavior of this method differs from the older
   * {@link java.util.Calendar#getInstance(Locale)} method.
   * If that method receives a locale of "th_TH" it will return `BuddhistCalendar`.
   * By contrast, this method will return `IsoChronology`.
   * Passing the locale "th-TH-u-ca-buddhist" into either method will
   * result in the Thai Buddhist calendar system and is therefore the
   * recommended approach going forward for Thai calendar system localization.
   * 
   * A similar, but simpler, situation occurs for the Japanese calendar system.
   * The locale "jp_JP_JP" has previously been used to access the calendar.
   * However, unlike the Thai locale, "ja_JP_JP" is automatically converted by
   * `Locale` to the modern and recommended form of "ja-JP-u-ca-japanese".
   * Thus, there is no difference in behavior between this method and
   * `Calendar#getInstance(Locale)`.
   *
   * @param locale  the locale to use to obtain the calendar system, not null
   * @return the calendar system associated with the locale, not null
   * @throws DateTimeException if the locale-specified calendar cannot be found
  */
  static ofLocale(locale: Locale): Chronology;
  /**
   * Obtains an instance of `Chronology` from a chronology ID or
   * calendar system type.
   * 
   * This returns a chronology based on either the ID or the type.
   * The {@link #getId() chronology ID} uniquely identifies the chronology.
   * The {@link #getCalendarType() calendar system type} is defined by the
   * CLDR specification.
   * 
   * The chronology may be a system chronology or a chronology
   * provided by the application via ServiceLoader configuration.
   * 
   * Since some calendars can be customized, the ID or type typically refers
   * to the default customization. For example, the Gregorian calendar can have multiple
   * cutover dates from the Julian, but the lookup only provides the default cutover date.
   *
   * @param id  the chronology ID or calendar system type, not null
   * @return the chronology with the identifier requested, not null
   * @throws DateTimeException if the chronology cannot be found
  */
  static of(id: string): Chronology;
  /**
   * Returns the available chronologies.
   * 
   * Each returned `Chronology` is available for use in the system.
   * The set of chronologies includes the system chronologies and
   * any chronologies provided by the application via ServiceLoader
   * configuration.
   *
   * @return the independent, modifiable set of the available chronology IDs, not null
  */
  static get availableChronologies(): Set<Chronology>;
  /**
   * Gets the ID of the chronology.
   * 
   * The ID uniquely identifies the `Chronology`.
   * It can be used to lookup the `Chronology` using {@link #of(String)}.
   *
   * @return the chronology ID, not null
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the calendar system.
   * 
   * The calendar type is an identifier defined by the CLDR and
   * Unicode Locale Data Markup Language (LDML) specifications
   * to uniquely identify a calendar.
   * The `getCalendarType` is the concatenation of the CLDR calendar type
   * and the variant, if applicable, is appended separated by "-".
   * The calendar type is used to lookup the `Chronology` using {@link #of(String)}.
   *
   * @return the calendar system type, null if the calendar is not defined by CLDR/LDML
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains a local date in this chronology from the era, year-of-era,
   * month-of-year and day-of-month fields.
   *
   * @implSpec
   * The default implementation combines the era and year-of-era into a proleptic
   * year before calling {@link #date(int, int, int)}.
   *
   * @param era  the era of the correct type for the chronology, not null
   * @param yearOfEra  the chronology year-of-era
   * @param month  the chronology month-of-year
   * @param dayOfMonth  the chronology day-of-month
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not of the correct type for the chronology
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): ChronoLocalDate;
  /**
   * Obtains a local date in this chronology from the proleptic-year,
   * month-of-year and day-of-month fields.
   *
   * @param prolepticYear  the chronology proleptic-year
   * @param month  the chronology month-of-year
   * @param dayOfMonth  the chronology day-of-month
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): ChronoLocalDate;
  /**
   * Obtains a local date in this chronology from the era, year-of-era and
   * day-of-year fields.
   *
   * @implSpec
   * The default implementation combines the era and year-of-era into a proleptic
   * year before calling {@link #dateYearDay(int, int)}.
   *
   * @param era  the era of the correct type for the chronology, not null
   * @param yearOfEra  the chronology year-of-era
   * @param dayOfYear  the chronology day-of-year
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not of the correct type for the chronology
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): ChronoLocalDate;
  /**
   * Obtains a local date in this chronology from the proleptic-year and
   * day-of-year fields.
   *
   * @param prolepticYear  the chronology proleptic-year
   * @param dayOfYear  the chronology day-of-year
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): ChronoLocalDate;
  /**
   * Obtains a local date in this chronology from the epoch-day.
   * 
   * The definition of {@link ChronoField#EPOCH_DAY EPOCH_DAY} is the same
   * for all calendar systems, thus it can be used for conversion.
   *
   * @param epochDay  the epoch day
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): ChronoLocalDate;
  /**
   * Obtains the current local date in this chronology from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @implSpec
   * The default implementation invokes {@link #dateNow(Clock)}.
   *
   * @return the current local date using the system clock and default time-zone, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(): ChronoLocalDate;
  /**
   * Obtains the current local date in this chronology from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @implSpec
   * The default implementation invokes {@link #dateNow(Clock)}.
   *
   * @param zone  the zone ID to use, not null
   * @return the current local date using the system clock, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(zone: ZoneId): ChronoLocalDate;
  /**
   * Obtains the current local date in this chronology from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @implSpec
   * The default implementation invokes {@link #date(TemporalAccessor)}.
   *
   * @param clock  the clock to use, not null
   * @return the current local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(clock: Clock): ChronoLocalDate;
  /**
   * Obtains a local date in this chronology from another temporal object.
   * 
   * This obtains a date in this chronology based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoLocalDate`.
   * 
   * The conversion typically uses the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field, which is standardized across calendar systems.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `aChronology::date`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the local date in this chronology, not null
   * @throws DateTimeException if unable to create the date
   * @see ChronoLocalDate#from(TemporalAccessor)
  */
  date(temporal: TemporalAccessor): ChronoLocalDate;
  /**
   * Obtains a local date-time in this chronology from another temporal object.
   * 
   * This obtains a date-time in this chronology based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoLocalDateTime`.
   * 
   * The conversion extracts and combines the `ChronoLocalDate` and the
   * `LocalTime` from the temporal object.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * The result uses this chronology.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `aChronology::localDateTime`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the local date-time in this chronology, not null
   * @throws DateTimeException if unable to create the date-time
   * @see ChronoLocalDateTime#from(TemporalAccessor)
  */
  localDateTime(temporal: TemporalAccessor): ChronoLocalDateTime<ChronoLocalDate>;
  /**
   * Obtains a `ChronoZonedDateTime` in this chronology from another temporal object.
   * 
   * This obtains a zoned date-time in this chronology based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoZonedDateTime`.
   * 
   * The conversion will first obtain a `ZoneId` from the temporal object,
   * falling back to a `ZoneOffset` if necessary. It will then try to obtain
   * an `Instant`, falling back to a `ChronoLocalDateTime` if necessary.
   * The result will be either the combination of `ZoneId` or `ZoneOffset`
   * with `Instant` or `ChronoLocalDateTime`.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * The result uses this chronology.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `aChronology::zonedDateTime`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the zoned date-time in this chronology, not null
   * @throws DateTimeException if unable to create the date-time
   * @see ChronoZonedDateTime#from(TemporalAccessor)
  */
  zonedDateTime(temporal: TemporalAccessor): ChronoZonedDateTime<ChronoLocalDate>;
  /**
   * Obtains a `ChronoZonedDateTime` in this chronology from an `Instant`.
   * 
   * This obtains a zoned date-time with the same instant as that specified.
   *
   * @param instant  the instant to create the date-time from, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  zonedDateTime(instant: Instant, zone: ZoneId): ChronoZonedDateTime<ChronoLocalDate>;
  /**
   * Checks if the specified year is a leap year.
   * 
   * A leap-year is a year of a longer length than normal.
   * The exact meaning is determined by the chronology according to the following constraints.
   * 
   * a leap-year must imply a year-length longer than a non leap-year.
   * a chronology that does not support the concept of a year must return false.
   * the correct result must be returned for all years within the
   *     valid range of years for the chronology.
   * 
   * 
   * Outside the range of valid years an implementation is free to return
   * either a best guess or false.
   * An implementation must not throw an exception, even if the year is
   * outside the range of valid years.
   *
   * @param prolepticYear  the proleptic-year to check, not validated for range
   * @return true if the year is a leap year
  */
  isLeapYear(prolepticYear: number): boolean;
  /**
   * Calculates the proleptic-year given the era and year-of-era.
   * 
   * This combines the era and year-of-era into the single proleptic-year field.
   * 
   * If the chronology makes active use of eras, such as `JapaneseChronology`
   * then the year-of-era will be validated against the era.
   * For other chronologies, validation is optional.
   *
   * @param era  the era of the correct type for the chronology, not null
   * @param yearOfEra  the chronology year-of-era
   * @return the proleptic-year
   * @throws DateTimeException if unable to convert to a proleptic-year,
   *  such as if the year is invalid for the era
   * @throws ClassCastException if the `era` is not of the correct type for the chronology
  */
  prolepticYear(era: Era, yearOfEra: number): number;
  /**
   * Creates the chronology era object from the numeric value.
   * 
   * The era is, conceptually, the largest division of the time-line.
   * Most calendar systems have a single epoch dividing the time-line into two eras.
   * However, some have multiple eras, such as one for the reign of each leader.
   * The exact meaning is determined by the chronology according to the following constraints.
   * 
   * The era in use at 1970-01-01 must have the value 1.
   * Later eras must have sequentially higher values.
   * Earlier eras must have sequentially lower values.
   * Each chronology must refer to an enum or similar singleton to provide the era values.
   * 
   * This method returns the singleton era of the correct type for the specified era value.
   *
   * @param eraValue  the era value
   * @return the calendar system era, not null
   * @throws DateTimeException if unable to create the era
  */
  eraOf(eraValue: number): Era;
  /**
   * Gets the list of eras for the chronology.
   * 
   * Most calendar systems have an era, within which the year has meaning.
   * If the calendar system does not support the concept of eras, an empty
   * list must be returned.
   *
   * @return the list of eras for the chronology, may be immutable, not null
  */
  eras(): Era[];
  /**
   * Gets the range of valid values for the specified field.
   * 
   * All fields can be expressed as a `long` integer.
   * This method returns an object that describes the valid range for that value.
   * 
   * Note that the result only describes the minimum and maximum valid values
   * and it is important not to read too much into them. For example, there
   * could be values within the range that are invalid for the field.
   * 
   * This method will return a result whether or not the chronology supports the field.
   *
   * @param field  the field to get the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
  */
  range(field: ChronoField): ValueRange;
  /**
   * Gets the textual representation of this chronology.
   * 
   * This returns the textual name used to identify the chronology,
   * suitable for presentation to the user.
   * The parameters control the style of the returned text and the locale.
   *
   * @implSpec
   * The default implementation behaves as though the formatter was used to
   * format the chronology textual name.
   *
   * @param style  the style of the text required, not null
   * @param locale  the locale to use, not null
   * @return the text value of the chronology, not null
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
  /**
   * Resolves parsed `ChronoField` values into a date during parsing.
   * 
   * Most `TemporalField` implementations are resolved using the
   * resolve method on the field. By contrast, the `ChronoField` class
   * defines fields that only have meaning relative to the chronology.
   * As such, `ChronoField` date fields are resolved here in the
   * context of a specific chronology.
   * 
   * The default implementation, which explains typical resolve behaviour,
   * is provided in {@link AbstractChronology}.
   *
   * @param fieldValues  the map of fields to values, which can be updated, not null
   * @param resolverStyle  the requested type of resolve, not null
   * @return the resolved date, null if insufficient information to create a date
   * @throws DateTimeException if the date cannot be resolved, typically
   *  because of a conflict in the input data
  */
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): ChronoLocalDate;
  /**
   * Obtains a period for this chronology based on years, months and days.
   * 
   * This returns a period tied to this chronology using the specified
   * years, months and days.  All supplied chronologies use periods
   * based on years, months and days, however the `ChronoPeriod` API
   * allows the period to be represented using other units.
   *
   * @implSpec
   * The default implementation returns an implementation class suitable
   * for most calendar systems. It is based solely on the three units.
   * Normalization, addition and subtraction derive the number of months
   * in a year from the {@link #range(ChronoField)}. If the number of
   * months within a year is fixed, then the calculation approach for
   * addition, subtraction and normalization is slightly different.
   * 
   * If implementing an unusual calendar system that is not based on
   * years, months and days, or where you want direct control, then
   * the `ChronoPeriod` interface must be directly implemented.
   * 
   * The returned period is immutable and thread-safe.
   *
   * @param years  the number of years, may be negative
   * @param months  the number of years, may be negative
   * @param days  the number of years, may be negative
   * @return the period in terms of this chronology, not null
  */
  period(years: number, months: number, days: number): ChronoPeriod;
  /**
   * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
   * 
   * The number of seconds is calculated using the proleptic-year,
   * month, day-of-month, hour, minute, second, and zoneOffset.
   *
   * @param prolepticYear the chronology proleptic-year
   * @param month the chronology month-of-year
   * @param dayOfMonth the chronology day-of-month
   * @param hour the hour-of-day, from 0 to 23
   * @param minute the minute-of-hour, from 0 to 59
   * @param second the second-of-minute, from 0 to 59
   * @param zoneOffset the zone offset, not null
   * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
   * @throws DateTimeException if any of the values are out of range
   * @since 9
  */
  epochSecond(prolepticYear: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, zoneOffset: ZoneOffset): number;
  /**
   * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
   * 
   * The number of seconds is calculated using the era, year-of-era,
   * month, day-of-month, hour, minute, second, and zoneOffset.
   *
   * @param era  the era of the correct type for the chronology, not null
   * @param yearOfEra the chronology year-of-era
   * @param month the chronology month-of-year
   * @param dayOfMonth the chronology day-of-month
   * @param hour the hour-of-day, from 0 to 23
   * @param minute the minute-of-hour, from 0 to 59
   * @param second the second-of-minute, from 0 to 59
   * @param zoneOffset the zone offset, not null
   * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
   * @throws DateTimeException if any of the values are out of range
   * @since 9
  */
  epochSecond(era: Era, yearOfEra: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, zoneOffset: ZoneOffset): number;
  /**
   * Checks if this chronology is ISO based.
   * 
   * An ISO based chronology has the same basic structure as the {@link IsoChronology
   * ISO chronology}, i.e., the chronology has the same number of months, the number
   * of days in each month, and day-of-year and leap years are the same as ISO chronology.
   * It also supports the concept of week-based-year of ISO chronology.
   * For example, the {@link MinguoChronology Minguo}, {@link ThaiBuddhistChronology
   * ThaiThaiBuddhist} and {@link JapaneseChronology Japanese} chronologies are ISO based.
   *
   * @implSpec
   * The default implementation returns `false`.
   *
   * @return `true` only if all the fields of {@link IsoFields} are supported by
   *          this chronology. Otherwise, returns `false`.
   * @see IsoChronology
   * @see JapaneseChronology
   * @see MinguoChronology
   * @see ThaiBuddhistChronology
   * @see IsoFields
   * @since 19
  */
  isIsoBased(): boolean;
  /**
   * Compares this chronology to another chronology.
   * 
   * The comparison order first by the chronology ID string, then by any
   * additional information specific to the subclass.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @param other  the other chronology to compare to, not null
   * @return the comparator value, that is this ID string compared with the `other`'s ID string
   *          unless the ID strings are equal and
   *          the chronology distinguishes instances using additional information
  */
  compareTo(other: Chronology): number;
  /**
   * Checks if this chronology is equal to another chronology.
   * 
   * The comparison is based on the entire state of the object.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other chronology
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this chronology.
   * 
   * The hash code should be based on the entire state of the object.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this chronology as a `String`.
   * 
   * The format should include the entire state of the object.
   *
   * @return a string representation of this chronology, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
/**
 * The Thai Buddhist calendar system.
 * 
 * This chronology defines the rules of the Thai Buddhist calendar system.
 * This calendar system is primarily used in Thailand.
 * Dates are aligned such that `2484-01-01 (Buddhist)` is `1941-01-01 (ISO)`.
 * 
 * The fields are defined as follows:
 * 
 * era - There are two eras, the current 'Buddhist' (ERA_BE) and the previous era (ERA_BEFORE_BE).
 * year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one.
 *  For the previous era the year increases from one as time goes backwards.
 *  The value for the current era is equal to the ISO proleptic-year plus 543.
 * proleptic-year - The proleptic year is the same as the year-of-era for the
 *  current era. For the previous era, years have zero, then negative values.
 *  The value is equal to the ISO proleptic-year plus 543.
 * month-of-year - The ThaiBuddhist month-of-year exactly matches ISO.
 * day-of-month - The ThaiBuddhist day-of-month exactly matches ISO.
 * day-of-year - The ThaiBuddhist day-of-year exactly matches ISO.
 * leap-year - The ThaiBuddhist leap-year pattern exactly matches ISO, such that the two calendars
 *  are never out of step.
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ThaiBuddhistChronology extends AbstractChronology {
  /**
   * Singleton instance of the Buddhist chronology.
  */
  static readonly INSTANCE: ThaiBuddhistChronology;
  /**
   * Gets the ID of the chronology - 'ThaiBuddhist'.
   * 
   * The ID uniquely identifies the `Chronology`.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the chronology ID - 'ThaiBuddhist'
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the underlying calendar system - 'buddhist'.
   * 
   * The calendar type is an identifier defined by the
   * Unicode Locale Data Markup Language (LDML) specification.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   * It can also be used as part of a locale, accessible via
   * {@link Locale#getUnicodeLocaleType(String)} with the key 'ca'.
   *
   * @return the calendar system type - 'buddhist'
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains a local date in Thai Buddhist calendar system from the
   * era, year-of-era, month-of-year and day-of-month fields.
   *
   * @param era  the Thai Buddhist era, not null
   * @param yearOfEra  the year-of-era
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Thai Buddhist local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `ThaiBuddhistEra`
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): ThaiBuddhistDate;
  /**
   * Obtains a local date in Thai Buddhist calendar system from the
   * proleptic-year, month-of-year and day-of-month fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Thai Buddhist local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): ThaiBuddhistDate;
  /**
   * Obtains a local date in Thai Buddhist calendar system from the
   * era, year-of-era and day-of-year fields.
   *
   * @param era  the Thai Buddhist era, not null
   * @param yearOfEra  the year-of-era
   * @param dayOfYear  the day-of-year
   * @return the Thai Buddhist local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `ThaiBuddhistEra`
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): ThaiBuddhistDate;
  /**
   * Obtains a local date in Thai Buddhist calendar system from the
   * proleptic-year and day-of-year fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param dayOfYear  the day-of-year
   * @return the Thai Buddhist local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): ThaiBuddhistDate;
  /**
   * Obtains a local date in the Thai Buddhist calendar system from the epoch-day.
   *
   * @param epochDay  the epoch day
   * @return the Thai Buddhist local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): ThaiBuddhistDate;
  dateNow(): ThaiBuddhistDate;
  dateNow(zone: ZoneId): ThaiBuddhistDate;
  dateNow(clock: Clock): ThaiBuddhistDate;
  date(temporal: TemporalAccessor): ThaiBuddhistDate;
  localDateTime(temporal: TemporalAccessor): ChronoLocalDateTime<ThaiBuddhistDate>;
  zonedDateTime(temporal: TemporalAccessor): ChronoZonedDateTime<ThaiBuddhistDate>;
  zonedDateTime(instant: Instant, zone: ZoneId): ChronoZonedDateTime<ThaiBuddhistDate>;
  /**
   * Checks if the specified year is a leap year.
   * 
   * Thai Buddhist leap years occur exactly in line with ISO leap years.
   * This method does not validate the year passed in, and only has a
   * well-defined result for years in the supported range.
   *
   * @param prolepticYear  the proleptic-year to check, not validated for range
   * @return true if the year is a leap year
  */
  isLeapYear(prolepticYear: number): boolean;
  prolepticYear(era: Era, yearOfEra: number): number;
  eraOf(eraValue: number): ThaiBuddhistEra;
  eras(): Era[];
  range(field: ChronoField): ValueRange;
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): ThaiBuddhistDate;
  /**
   * `ThaiBuddhistChronology` is an ISO based chronology, which supports fields
   * in {@link IsoFields}, such as {@link IsoFields#DAY_OF_QUARTER DAY_OF_QUARTER}
   * and {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR}.
   * @see IsoFields
   * @return `true`
   * @since 19
  */
  isIsoBased(): boolean;
}
export interface ThaiBuddhistChronology extends AbstractChronology, Serializable {}
/**
 * An era in the Minguo calendar system.
 * 
 * The Minguo calendar system has two eras.
 * The current era, for years from 1 onwards, is known as the 'Republic of China' era.
 * All previous years, zero or earlier in the proleptic count or one and greater
 * in the year-of-era count, are part of the 'Before Republic of China' era.
 *
 * 
 * Minguo years and eras
 * 
 * 
 * year-of-era
 * era
 * proleptic-year
 * ISO proleptic-year
 * 
 * 
 * 
 * 
 * 2ROC21913
 * 
 * 
 * 1ROC11912
 * 
 * 
 * 1BEFORE_ROC01911
 * 
 * 
 * 2BEFORE_ROC-11910
 * 
 * 
 * 
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `MinguoEra`.
 * Use `getValue()` instead.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class MinguoEra extends Enum<MinguoEra> {
  /**
   * The singleton instance for the era before the current one, 'Before Republic of China Era',
   * which has the numeric value 0.
  */
  static readonly BEFORE_ROC: MinguoEra;
  /**
   * The singleton instance for the current era, 'Republic of China Era',
   * which has the numeric value 1.
  */
  static readonly ROC: MinguoEra;
  static valueOf(name: string): MinguoEra;
  static values(): MinguoEra[];
  /**
   * Obtains an instance of `MinguoEra` from an `int` value.
   * 
   * `MinguoEra` is an enum representing the Minguo eras of BEFORE_ROC/ROC.
   * This factory allows the enum to be obtained from the `int` value.
   *
   * @param minguoEra  the BEFORE_ROC/ROC value to represent, from 0 (BEFORE_ROC) to 1 (ROC)
   * @return the era singleton, not null
   * @throws DateTimeException if the value is invalid
  */
  static of(minguoEra: number): MinguoEra;
  /**
   * Gets the numeric era `int` value.
   * 
   * The era BEFORE_ROC has the value 0, while the era ROC has the value 1.
   *
   * @return the era value, from 0 (BEFORE_ROC) to 1 (ROC)
  */
  get value(): number;
  /**
   * {@inheritDoc}
   *
   * @param style {@inheritDoc}
   * @param locale {@inheritDoc}
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
}
/**
 * A date in the Minguo calendar system.
 * 
 * This date operates using the {@linkplain MinguoChronology Minguo calendar}.
 * This calendar system is primarily used in the Republic of China, often known as Taiwan.
 * Dates are aligned such that `0001-01-01 (Minguo)` is `1912-01-01 (ISO)`.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class MinguoDate extends ChronoLocalDate {
  /**
   * Obtains the current `MinguoDate` from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date using the system clock and default time-zone, not null
  */
  static now(): MinguoDate;
  /**
   * Obtains the current `MinguoDate` from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date using the system clock, not null
  */
  static now(zone: ZoneId): MinguoDate;
  /**
   * Obtains the current `MinguoDate` from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@linkplain Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date, not null
   * @throws DateTimeException if the current date cannot be obtained
  */
  static now(clock: Clock): MinguoDate;
  /**
   * Obtains a `MinguoDate` representing a date in the Minguo calendar
   * system from the proleptic-year, month-of-year and day-of-month fields.
   * 
   * This returns a `MinguoDate` with the specified fields.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   *
   * @param prolepticYear  the Minguo proleptic-year
   * @param month  the Minguo month-of-year, from 1 to 12
   * @param dayOfMonth  the Minguo day-of-month, from 1 to 31
   * @return the date in Minguo calendar system, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(prolepticYear: number, month: number, dayOfMonth: number): MinguoDate;
  /**
   * Obtains a `MinguoDate` from a temporal object.
   * 
   * This obtains a date in the Minguo calendar system based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `MinguoDate`.
   * 
   * The conversion typically uses the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field, which is standardized across calendar systems.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `MinguoDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date in Minguo calendar system, not null
   * @throws DateTimeException if unable to convert to a `MinguoDate`
  */
  static from(temporal: TemporalAccessor): MinguoDate;
  /**
   * Gets the chronology of this date, which is the Minguo calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the Minguo chronology, not null
  */
  get chronology(): MinguoChronology;
  /**
   * Gets the era applicable at this date.
   * 
   * The Minguo calendar system has two eras, 'ROC' and 'BEFORE_ROC',
   * defined by {@link MinguoEra}.
   *
   * @return the era applicable at this date, not null
  */
  get era(): MinguoEra;
  /**
   * Returns the length of the month represented by this date.
   * 
   * This returns the length of the month in days.
   * Month lengths match those of the ISO calendar system.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  range(field: TemporalField): ValueRange;
  getLong(field: TemporalField): number;
  with(field: TemporalField, newValue: number): MinguoDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): MinguoDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): MinguoDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): MinguoDate;
  plus(amountToAdd: number, unit: TemporalUnit): MinguoDate;
  minus(amountToSubtract: number, unit: TemporalUnit): MinguoDate;
  atTime(localTime: LocalTime): ChronoLocalDateTime<MinguoDate>;
  until(endDate: ChronoLocalDate): ChronoPeriod;
  toEpochDay(): number;
  /**
   * Compares this date to another date, including the chronology.
   * 
   * Compares this `MinguoDate` with another ensuring that the date is the same.
   * 
   * Only objects of type `MinguoDate` are compared, other types return false.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code based only on the Chronology and the date
  */
  hashCode(): number;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ChronoLocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `ChronoLocalDate` using {@link Chronology#date(TemporalAccessor)}.
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * should be supported by all implementations.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a
   *  `ChronoLocalDate` in the same chronology, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ChronoLocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
}
export interface MinguoDate extends ChronoLocalDate, Serializable {}
/**
 * An era in the ISO calendar system.
 * 
 * The ISO-8601 standard does not define eras.
 * A definition has therefore been created with two eras - 'Current era' (CE) for
 * years on or after 0001-01-01 (ISO), and 'Before current era' (BCE) for years before that.
 *
 * 
 * ISO years and eras
 * 
 * 
 * year-of-era
 * era
 * proleptic-year
 * 
 * 
 * 
 * 
 * 2CE2
 * 
 * 
 * 1CE1
 * 
 * 
 * 1BCE0
 * 
 * 
 * 2BCE-1
 * 
 * 
 * 
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `IsoEra`.
 * Use `getValue()` instead.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class IsoEra extends Enum<IsoEra> {
  /**
   * The singleton instance for the era before the current one, 'Before Current Era',
   * which has the numeric value 0.
  */
  static readonly BCE: IsoEra;
  /**
   * The singleton instance for the current era, 'Current Era',
   * which has the numeric value 1.
  */
  static readonly CE: IsoEra;
  static valueOf(name: string): IsoEra;
  static values(): IsoEra[];
  /**
   * Obtains an instance of `IsoEra` from an `int` value.
   * 
   * `IsoEra` is an enum representing the ISO eras of BCE/CE.
   * This factory allows the enum to be obtained from the `int` value.
   *
   * @param isoEra  the BCE/CE value to represent, from 0 (BCE) to 1 (CE)
   * @return the era singleton, not null
   * @throws DateTimeException if the value is invalid
  */
  static of(isoEra: number): IsoEra;
  /**
   * Gets the numeric era `int` value.
   * 
   * The era BCE has the value 0, while the era CE has the value 1.
   *
   * @return the era value, from 0 (BCE) to 1 (CE)
  */
  get value(): number;
}
/**
 * The Hijrah calendar is a lunar calendar supporting Islamic calendars.
 * 
 * The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah
 * calendar has several variants based on differences in when the new moon is
 * determined to have occurred and where the observation is made.
 * In some variants the length of each month is
 * computed algorithmically from the astronomical data for the moon and earth and
 * in others the length of the month is determined by an authorized sighting
 * of the new moon. For the algorithmically based calendars the calendar
 * can project into the future.
 * For sighting based calendars only historical data from past
 * sightings is available.
 * 
 * The length of each month is 29 or 30 days.
 * Ordinary years have 354 days; leap years have 355 days.
 *
 * 
 * CLDR and LDML identify variants:
 * 
 * Variants of Hijrah Calendars
 * 
 * 
 * Chronology ID
 * Calendar Type
 * Locale extension, see {@link java.util.Locale}
 * Description
 * 
 * 
 * 
 * 
 * Hijrah-umalqura
 * islamic-umalqura
 * ca-islamic-umalqura
 * Islamic - Umm Al-Qura calendar of Saudi Arabia
 * 
 * 
 * 
 * Additional variants may be available through {@link Chronology#getAvailableChronologies()}.
 *
 * Example
 * 
 * Selecting the chronology from the locale uses {@link Chronology#ofLocale}
 * to find the Chronology based on Locale supported BCP 47 extension mechanism
 * to request a specific calendar ("ca"). For example,
 * 
 *  *      Locale locale = Locale.forLanguageTag("en-US-u-ca-islamic-umalqura");
 *      Chronology chrono = Chronology.ofLocale(locale);
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @implNote
 * Each Hijrah variant is configured individually. Each variant is defined by a
 * property resource that defines the `ID`, the `calendar type`,
 * the start of the calendar, the alignment with the
 * ISO calendar, and the length of each month for a range of years.
 * The variants are loaded by HijrahChronology as a resource from
 * hijrah-config-<calendar type>.properties.
 * 
 * The Hijrah property resource is a set of properties that describe the calendar.
 * The syntax is defined by `java.util.Properties#load(Reader)`.
 * 
 * Configuration of Hijrah Calendar
 * 
 * 
 * Property Name
 * Property value
 * Description
 * 
 * 
 * 
 * 
 * id
 * Chronology Id, for example, "Hijrah-umalqura"
 * The Id of the calendar in common usage
 * 
 * 
 * type
 * Calendar type, for example, "islamic-umalqura"
 * LDML defines the calendar types
 * 
 * 
 * version
 * Version, for example: "1.8.0_1"
 * The version of the Hijrah variant data
 * 
 * 
 * iso-start
 * ISO start date, formatted as `yyyy-MM-dd`, for example: "1900-04-30"
 * The ISO date of the first day of the minimum Hijrah year.
 * 
 * 
 * yyyy - a numeric 4 digit year, for example "1434"
 * The value is a sequence of 12 month lengths,
 * for example: "29 30 29 30 29 30 30 30 29 30 29 29"
 * The lengths of the 12 months of the year separated by whitespace.
 * A numeric year property must be present for every year without any gaps.
 * The month lengths must be between 29-32 inclusive.
 * 
 * 
 * 
 * 
 * 
 * Additional variants may be added by providing configuration properties files in
 * `/conf/chronology` directory. The properties
 * files should follow the naming convention of
 * `hijrah-config-_.properties`.
 *
 * @since 1.8
*/
export class HijrahChronology extends AbstractChronology {
  /**
   * Singleton instance of the Islamic Umm Al-Qura calendar of Saudi Arabia.
   * Other Hijrah chronology variants may be available from
   * {@link Chronology#getAvailableChronologies}.
  */
  static readonly INSTANCE: HijrahChronology;
  /**
   * Gets the ID of the chronology.
   * 
   * The ID uniquely identifies the `Chronology`. It can be used to
   * lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the chronology ID, non-null
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the Islamic calendar.
   * 
   * The calendar type is an identifier defined by the
   * Unicode Locale Data Markup Language (LDML) specification.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the calendar system type; non-null if the calendar has
   *    a standard type, otherwise null
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains a local date in Hijrah calendar system from the
   * era, year-of-era, month-of-year and day-of-month fields.
   *
   * @param era  the Hijrah era, not null
   * @param yearOfEra  the year-of-era
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Hijrah local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `HijrahEra`
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): HijrahDate;
  /**
   * Obtains a local date in Hijrah calendar system from the
   * proleptic-year, month-of-year and day-of-month fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Hijrah local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): HijrahDate;
  /**
   * Obtains a local date in Hijrah calendar system from the
   * era, year-of-era and day-of-year fields.
   *
   * @param era  the Hijrah era, not null
   * @param yearOfEra  the year-of-era
   * @param dayOfYear  the day-of-year
   * @return the Hijrah local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `HijrahEra`
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): HijrahDate;
  /**
   * Obtains a local date in Hijrah calendar system from the
   * proleptic-year and day-of-year fields.
   *
   * @param prolepticYear  the proleptic-year
   * @param dayOfYear  the day-of-year
   * @return the Hijrah local date, not null
   * @throws DateTimeException if the value of the year is out of range,
   *  or if the day-of-year is invalid for the year
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): HijrahDate;
  /**
   * Obtains a local date in the Hijrah calendar system from the epoch-day.
   *
   * @param epochDay  the epoch day
   * @return the Hijrah local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): HijrahDate;
  dateNow(): HijrahDate;
  dateNow(zone: ZoneId): HijrahDate;
  dateNow(clock: Clock): HijrahDate;
  date(temporal: TemporalAccessor): HijrahDate;
  localDateTime(temporal: TemporalAccessor): ChronoLocalDateTime<HijrahDate>;
  zonedDateTime(temporal: TemporalAccessor): ChronoZonedDateTime<HijrahDate>;
  zonedDateTime(instant: Instant, zone: ZoneId): ChronoZonedDateTime<HijrahDate>;
  isLeapYear(prolepticYear: number): boolean;
  prolepticYear(era: Era, yearOfEra: number): number;
  /**
   * Creates the HijrahEra object from the numeric value.
   * The Hijrah calendar system has only one era covering the
   * proleptic years greater than zero.
   * This method returns the singleton HijrahEra for the value 1.
   *
   * @param eraValue  the era value
   * @return the calendar system era, not null
   * @throws DateTimeException if unable to create the era
  */
  eraOf(eraValue: number): HijrahEra;
  eras(): Era[];
  range(field: ChronoField): ValueRange;
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): HijrahDate;
}
export interface HijrahChronology extends AbstractChronology, Serializable {}
/**
 * An era in the Thai Buddhist calendar system.
 * 
 * The Thai Buddhist calendar system has two eras.
 * The current era, for years from 1 onwards, is known as the 'Buddhist' era.
 * All previous years, zero or earlier in the proleptic count or one and greater
 * in the year-of-era count, are part of the 'Before Buddhist' era.
 *
 * 
 * Buddhist years and eras
 * 
 * 
 * year-of-era
 * era
 * proleptic-year
 * ISO proleptic-year
 * 
 * 
 * 
 * 
 * 2BE2-542
 * 
 * 
 * 1BE1-543
 * 
 * 
 * 1BEFORE_BE0-544
 * 
 * 
 * 2BEFORE_BE-1-545
 * 
 * 
 * 
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `ThaiBuddhistEra`.
 * Use `getValue()` instead.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class ThaiBuddhistEra extends Enum<ThaiBuddhistEra> {
  /**
   * The singleton instance for the era before the current one, 'Before Buddhist Era',
   * which has the numeric value 0.
  */
  static readonly BEFORE_BE: ThaiBuddhistEra;
  /**
   * The singleton instance for the current era, 'Buddhist Era',
   * which has the numeric value 1.
  */
  static readonly BE: ThaiBuddhistEra;
  static valueOf(name: string): ThaiBuddhistEra;
  static values(): ThaiBuddhistEra[];
  /**
   * Obtains an instance of `ThaiBuddhistEra` from an `int` value.
   * 
   * `ThaiBuddhistEra` is an enum representing the Thai Buddhist eras of BEFORE_BE/BE.
   * This factory allows the enum to be obtained from the `int` value.
   *
   * @param thaiBuddhistEra  the era to represent, from 0 to 1
   * @return the BuddhistEra singleton, never null
   * @throws DateTimeException if the era is invalid
  */
  static of(thaiBuddhistEra: number): ThaiBuddhistEra;
  /**
   * Gets the numeric era `int` value.
   * 
   * The era BEFORE_BE has the value 0, while the era BE has the value 1.
   *
   * @return the era value, from 0 (BEFORE_BE) to 1 (BE)
  */
  get value(): number;
  /**
   * {@inheritDoc}
   *
   * @param style {@inheritDoc}
   * @param locale {@inheritDoc}
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
}
/**
 * The Japanese Imperial calendar system.
 * 
 * This chronology defines the rules of the Japanese Imperial calendar system.
 * This calendar system is primarily used in Japan.
 * The Japanese Imperial calendar system is the same as the ISO calendar system
 * apart from the era-based year numbering.
 * 
 * Japan introduced the Gregorian calendar starting with Meiji 6.
 * Only Meiji and later eras are supported;
 * dates before Meiji 6, January 1 are not supported.
 * 
 * The supported `ChronoField` instances are:
 * 
 * `DAY_OF_WEEK`
 * `DAY_OF_MONTH`
 * `DAY_OF_YEAR`
 * `EPOCH_DAY`
 * `MONTH_OF_YEAR`
 * `PROLEPTIC_MONTH`
 * `YEAR_OF_ERA`
 * `YEAR`
 * `ERA`
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class JapaneseChronology extends AbstractChronology {
  /**
   * Singleton instance for Japanese chronology.
  */
  static readonly INSTANCE: JapaneseChronology;
  /**
   * Gets the ID of the chronology - 'Japanese'.
   * 
   * The ID uniquely identifies the `Chronology`.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the chronology ID - 'Japanese'
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the underlying calendar system - 'japanese'.
   * 
   * The calendar type is an identifier defined by the
   * Unicode Locale Data Markup Language (LDML) specification.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   * It can also be used as part of a locale, accessible via
   * {@link Locale#getUnicodeLocaleType(String)} with the key 'ca'.
   *
   * @return the calendar system type - 'japanese'
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains a local date in Japanese calendar system from the
   * era, year-of-era, month-of-year and day-of-month fields.
   * 
   * The Japanese month and day-of-month are the same as those in the
   * ISO calendar system. They are not reset when the era changes.
   * For example:
   *      *  6th Jan Showa 64 = ISO 1989-01-06
   *  7th Jan Showa 64 = ISO 1989-01-07
   *  8th Jan Heisei 1 = ISO 1989-01-08
   *  9th Jan Heisei 1 = ISO 1989-01-09
   * 
   *
   * @param era  the Japanese era, not null
   * @param yearOfEra  the year-of-era
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Japanese local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `JapaneseEra`
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): JapaneseDate;
  /**
   * Obtains a local date in Japanese calendar system from the
   * proleptic-year, month-of-year and day-of-month fields.
   * 
   * The Japanese proleptic year, month and day-of-month are the same as those
   * in the ISO calendar system. They are not reset when the era changes.
   *
   * @param prolepticYear  the proleptic-year
   * @param month  the month-of-year
   * @param dayOfMonth  the day-of-month
   * @return the Japanese local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): JapaneseDate;
  /**
   * Obtains a local date in Japanese calendar system from the
   * era, year-of-era and day-of-year fields.
   * 
   * The day-of-year in this factory is expressed relative to the start of the year-of-era.
   * This definition changes the normal meaning of day-of-year only in those years
   * where the year-of-era is reset to one due to a change in the era.
   * For example:
   *      *  6th Jan Showa 64 = day-of-year 6
   *  7th Jan Showa 64 = day-of-year 7
   *  8th Jan Heisei 1 = day-of-year 1
   *  9th Jan Heisei 1 = day-of-year 2
   * 
   *
   * @param era  the Japanese era, not null
   * @param yearOfEra  the year-of-era
   * @param dayOfYear  the day-of-year
   * @return the Japanese local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the `era` is not a `JapaneseEra`
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): JapaneseDate;
  /**
   * Obtains a local date in Japanese calendar system from the
   * proleptic-year and day-of-year fields.
   * 
   * The day-of-year in this factory is expressed relative to the start of the proleptic year.
   * The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system.
   * They are not reset when the era changes.
   *
   * @param prolepticYear  the proleptic-year
   * @param dayOfYear  the day-of-year
   * @return the Japanese local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): JapaneseDate;
  /**
   * Obtains a local date in the Japanese calendar system from the epoch-day.
   *
   * @param epochDay  the epoch day
   * @return the Japanese local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): JapaneseDate;
  dateNow(): JapaneseDate;
  dateNow(zone: ZoneId): JapaneseDate;
  dateNow(clock: Clock): JapaneseDate;
  date(temporal: TemporalAccessor): JapaneseDate;
  localDateTime(temporal: TemporalAccessor): ChronoLocalDateTime<JapaneseDate>;
  zonedDateTime(temporal: TemporalAccessor): ChronoZonedDateTime<JapaneseDate>;
  zonedDateTime(instant: Instant, zone: ZoneId): ChronoZonedDateTime<JapaneseDate>;
  /**
   * Checks if the specified year is a leap year.
   * 
   * Japanese calendar leap years occur exactly in line with ISO leap years.
   * This method does not validate the year passed in, and only has a
   * well-defined result for years in the supported range.
   *
   * @param prolepticYear  the proleptic-year to check, not validated for range
   * @return true if the year is a leap year
  */
  isLeapYear(prolepticYear: number): boolean;
  prolepticYear(era: Era, yearOfEra: number): number;
  /**
   * Returns the calendar system era object from the given numeric value.
   *
   * The numeric values supported by this method are the same as the
   * numeric values supported by {@link JapaneseEra#of(int)}.
   *
   * @param eraValue  the era value
   * @return the Japanese `Era` for the given numeric era value
   * @throws DateTimeException if `eraValue` is invalid
  */
  eraOf(eraValue: number): JapaneseEra;
  eras(): Era[];
  range(field: ChronoField): ValueRange;
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): JapaneseDate;
  /**
   * `JapaneseChronology` is an ISO based chronology, which supports fields
   * in {@link IsoFields}, such as {@link IsoFields#DAY_OF_QUARTER DAY_OF_QUARTER}
   * and {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR}.
   * @see IsoFields
   * @return `true`
   * @since 19
  */
  isIsoBased(): boolean;
}
export interface JapaneseChronology extends AbstractChronology, Serializable {}
/**
 * An abstract implementation of a calendar system, used to organize and identify dates.
 * 
 * The main date and time API is built on the ISO calendar system.
 * The chronology operates behind the scenes to represent the general concept of a calendar system.
 * 
 * See {@link Chronology} for more details.
 *
 * @implSpec
 * This class is separated from the `Chronology` interface so that the static methods
 * are not inherited. While `Chronology` can be implemented directly, it is strongly
 * recommended to extend this abstract class instead.
 * 
 * This class must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @since 1.8
*/
export class AbstractChronology extends Chronology {
  /**
   * Resolves parsed `ChronoField` values into a date during parsing.
   * 
   * Most `TemporalField` implementations are resolved using the
   * resolve method on the field. By contrast, the `ChronoField` class
   * defines fields that only have meaning relative to the chronology.
   * As such, `ChronoField` date fields are resolved here in the
   * context of a specific chronology.
   * 
   * `ChronoField` instances are resolved by this method, which may
   * be overridden in subclasses.
   * 
   * `EPOCH_DAY` - If present, this is converted to a date and
   *  all other date fields are then cross-checked against the date.
   * `PROLEPTIC_MONTH` - If present, then it is split into the
   *  `YEAR` and `MONTH_OF_YEAR`. If the mode is strict or smart
   *  then the field is validated.
   * `YEAR_OF_ERA` and `ERA` - If both are present, then they
   *  are combined to form a `YEAR`. In lenient mode, the `YEAR_OF_ERA`
   *  range is not validated, in smart and strict mode it is. The `ERA` is
   *  validated for range in all three modes. If only the `YEAR_OF_ERA` is
   *  present, and the mode is smart or lenient, then the last available era
   *  is assumed. In strict mode, no era is assumed and the `YEAR_OF_ERA` is
   *  left untouched. If only the `ERA` is present, then it is left untouched.
   * `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` -
   *  If all three are present, then they are combined to form a date.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is smart or strict, then the month and day are validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first day of the first month in the requested year,
   *  then adding the difference in months, then the difference in days.
   *  If the mode is smart, and the day-of-month is greater than the maximum for
   *  the year-month, then the day-of-month is adjusted to the last day-of-month.
   *  If the mode is strict, then the three fields must form a valid date.
   * `YEAR` and `DAY_OF_YEAR` -
   *  If both are present, then they are combined to form a date.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first day of the requested year, then adding
   *  the difference in days.
   *  If the mode is smart or strict, then the two fields must form a valid date.
   * `YEAR`, `MONTH_OF_YEAR`, `ALIGNED_WEEK_OF_MONTH` and
   *  `ALIGNED_DAY_OF_WEEK_IN_MONTH` -
   *  If all four are present, then they are combined to form a date.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first day of the first month in the requested year, then adding
   *  the difference in months, then the difference in weeks, then in days.
   *  If the mode is smart or strict, then the all four fields are validated to
   *  their outer ranges. The date is then combined in a manner equivalent to
   *  creating a date on the first day of the requested year and month, then adding
   *  the amount in weeks and days to reach their values. If the mode is strict,
   *  the date is additionally validated to check that the day and week adjustment
   *  did not change the month.
   * `YEAR`, `MONTH_OF_YEAR`, `ALIGNED_WEEK_OF_MONTH` and
   *  `DAY_OF_WEEK` - If all four are present, then they are combined to
   *  form a date. The approach is the same as described above for
   *  years, months and weeks in `ALIGNED_DAY_OF_WEEK_IN_MONTH`.
   *  The day-of-week is adjusted as the next or same matching day-of-week once
   *  the years, months and weeks have been handled.
   * `YEAR`, `ALIGNED_WEEK_OF_YEAR` and `ALIGNED_DAY_OF_WEEK_IN_YEAR` -
   *  If all three are present, then they are combined to form a date.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first day of the requested year, then adding
   *  the difference in weeks, then in days.
   *  If the mode is smart or strict, then the all three fields are validated to
   *  their outer ranges. The date is then combined in a manner equivalent to
   *  creating a date on the first day of the requested year, then adding
   *  the amount in weeks and days to reach their values. If the mode is strict,
   *  the date is additionally validated to check that the day and week adjustment
   *  did not change the year.
   * `YEAR`, `ALIGNED_WEEK_OF_YEAR` and `DAY_OF_WEEK` -
   *  If all three are present, then they are combined to form a date.
   *  The approach is the same as described above for years and weeks in
   *  `ALIGNED_DAY_OF_WEEK_IN_YEAR`. The day-of-week is adjusted as the
   *  next or same matching day-of-week once the years and weeks have been handled.
   * 
   * 
   * The default implementation is suitable for most calendar systems.
   * If {@link java.time.temporal.ChronoField#YEAR_OF_ERA} is found without an {@link java.time.temporal.ChronoField#ERA}
   * then the last era in {@link #eras()} is used.
   * The implementation assumes a 7 day week, that the first day-of-month
   * has the value 1, that first day-of-year has the value 1, and that the
   * first of the month and year always exists.
   *
   * @param fieldValues  the map of fields to values, which can be updated, not null
   * @param resolverStyle  the requested type of resolve, not null
   * @return the resolved date, null if insufficient information to create a date
   * @throws java.time.DateTimeException if the date cannot be resolved, typically
   *  because of a conflict in the input data
  */
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): ChronoLocalDate;
  /**
   * Compares this chronology to another chronology.
   * 
   * The comparison order first by the chronology ID string, then by any
   * additional information specific to the subclass.
   * It is "consistent with equals", as defined by {@link Comparable}.
   *
   * @implSpec
   * This implementation compares the chronology ID.
   * Subclasses must compare any additional state that they store.
   *
   * @param other  the other chronology to compare to, not null
   * @return the comparator value, that is this ID string compared with the `other`'s ID string
  */
  compareTo(other: Chronology): number;
  /**
   * Checks if this chronology is equal to another chronology.
   * 
   * The comparison is based on the entire state of the object.
   *
   * @implSpec
   * This implementation checks the type and calls
   * {@link #compareTo(java.time.chrono.Chronology)}.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other chronology
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this chronology.
   * 
   * The hash code should be based on the entire state of the object.
   *
   * @implSpec
   * This implementation is based on the chronology ID and class.
   * Subclasses should add any additional state that they store.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this chronology as a `String`, using the chronology ID.
   *
   * @return a string representation of this chronology, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
/**
 * The ISO calendar system.
 * 
 * This chronology defines the rules of the ISO calendar system.
 * This calendar system is based on the ISO-8601 standard, which is the
 * de facto world calendar.
 * 
 * The fields are defined as follows:
 * 
 * era - There are two eras, 'Current Era' (CE) and 'Before Current Era' (BCE).
 * year-of-era - The year-of-era is the same as the proleptic-year for the current CE era.
 *  For the BCE era before the ISO epoch the year increases from 1 upwards as time goes backwards.
 * proleptic-year - The proleptic year is the same as the year-of-era for the
 *  current era. For the previous era, years have zero, then negative values.
 * month-of-year - There are 12 months in an ISO year, numbered from 1 to 12.
 * day-of-month - There are between 28 and 31 days in each of the ISO month, numbered from 1 to 31.
 *  Months 4, 6, 9 and 11 have 30 days, Months 1, 3, 5, 7, 8, 10 and 12 have 31 days.
 *  Month 2 has 28 days, or 29 in a leap year.
 * day-of-year - There are 365 days in a standard ISO year and 366 in a leap year.
 *  The days are numbered from 1 to 365 or 1 to 366.
 * leap-year - Leap years occur every 4 years, except where the year is divisble by 100 and not divisble by 400.
 * 
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class IsoChronology extends AbstractChronology {
  /**
   * Singleton instance of the ISO chronology.
  */
  static readonly INSTANCE: IsoChronology;
  /**
   * Gets the ID of the chronology - 'ISO'.
   * 
   * The ID uniquely identifies the `Chronology`.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   *
   * @return the chronology ID - 'ISO'
   * @see #getCalendarType()
  */
  get id(): string;
  /**
   * Gets the calendar type of the underlying calendar system - 'iso8601'.
   * 
   * The calendar type is an identifier defined by the
   * Unicode Locale Data Markup Language (LDML) specification.
   * It can be used to lookup the `Chronology` using {@link Chronology#of(String)}.
   * It can also be used as part of a locale, accessible via
   * {@link Locale#getUnicodeLocaleType(String)} with the key 'ca'.
   *
   * @return the calendar system type - 'iso8601'
   * @see #getId()
  */
  get calendarType(): string;
  /**
   * Obtains an ISO local date from the era, year-of-era, month-of-year
   * and day-of-month fields.
   *
   * @param era  the ISO era, not null
   * @param yearOfEra  the ISO year-of-era
   * @param month  the ISO month-of-year
   * @param dayOfMonth  the ISO day-of-month
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
   * @throws ClassCastException if the type of `era` is not `IsoEra`
  */
  date(era: Era, yearOfEra: number, month: number, dayOfMonth: number): LocalDate;
  /**
   * Obtains an ISO local date from the proleptic-year, month-of-year
   * and day-of-month fields.
   * 
   * This is equivalent to {@link LocalDate#of(int, int, int)}.
   *
   * @param prolepticYear  the ISO proleptic-year
   * @param month  the ISO month-of-year
   * @param dayOfMonth  the ISO day-of-month
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(prolepticYear: number, month: number, dayOfMonth: number): LocalDate;
  /**
   * Obtains an ISO local date from the era, year-of-era and day-of-year fields.
   *
   * @param era  the ISO era, not null
   * @param yearOfEra  the ISO year-of-era
   * @param dayOfYear  the ISO day-of-year
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(era: Era, yearOfEra: number, dayOfYear: number): LocalDate;
  /**
   * Obtains an ISO local date from the proleptic-year and day-of-year fields.
   * 
   * This is equivalent to {@link LocalDate#ofYearDay(int, int)}.
   *
   * @param prolepticYear  the ISO proleptic-year
   * @param dayOfYear  the ISO day-of-year
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateYearDay(prolepticYear: number, dayOfYear: number): LocalDate;
  /**
   * Obtains an ISO local date from the epoch-day.
   * 
   * This is equivalent to {@link LocalDate#ofEpochDay(long)}.
   *
   * @param epochDay  the epoch day
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateEpochDay(epochDay: number): LocalDate;
  /**
   * Obtains an ISO local date from another date-time object.
   * 
   * This is equivalent to {@link LocalDate#from(TemporalAccessor)}.
   *
   * @param temporal  the date-time object to convert, not null
   * @return the ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  date(temporal: TemporalAccessor): LocalDate;
  /**
   * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
   * 
   * The number of seconds is calculated using the year,
   * month, day-of-month, hour, minute, second, and zoneOffset.
   *
   * @param prolepticYear  the year, from MIN_YEAR to MAX_YEAR
   * @param month  the month-of-year, from 1 to 12
   * @param dayOfMonth  the day-of-month, from 1 to 31
   * @param hour  the hour-of-day, from 0 to 23
   * @param minute  the minute-of-hour, from 0 to 59
   * @param second  the second-of-minute, from 0 to 59
   * @param zoneOffset the zone offset, not null
   * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
   * @throws DateTimeException if the value of any argument is out of range,
   *         or if the day-of-month is invalid for the month-of-year
   * @since 9
  */
  epochSecond(prolepticYear: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, zoneOffset: ZoneOffset): number;
  /**
   * Obtains an ISO local date-time from another date-time object.
   * 
   * This is equivalent to {@link LocalDateTime#from(TemporalAccessor)}.
   *
   * @param temporal  the date-time object to convert, not null
   * @return the ISO local date-time, not null
   * @throws DateTimeException if unable to create the date-time
  */
  localDateTime(temporal: TemporalAccessor): LocalDateTime;
  /**
   * Obtains an ISO zoned date-time from another date-time object.
   * 
   * This is equivalent to {@link ZonedDateTime#from(TemporalAccessor)}.
   *
   * @param temporal  the date-time object to convert, not null
   * @return the ISO zoned date-time, not null
   * @throws DateTimeException if unable to create the date-time
  */
  zonedDateTime(temporal: TemporalAccessor): ZonedDateTime;
  /**
   * Obtains an ISO zoned date-time in this chronology from an `Instant`.
   * 
   * This is equivalent to {@link ZonedDateTime#ofInstant(Instant, ZoneId)}.
   *
   * @param instant  the instant to create the date-time from, not null
   * @param zone  the time-zone, not null
   * @return the zoned date-time, not null
   * @throws DateTimeException if the result exceeds the supported range
  */
  zonedDateTime(instant: Instant, zone: ZoneId): ZonedDateTime;
  /**
   * Obtains the current ISO local date from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current ISO local date using the system clock and default time-zone, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(): LocalDate;
  /**
   * Obtains the current ISO local date from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current ISO local date using the system clock, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(zone: ZoneId): LocalDate;
  /**
   * Obtains the current ISO local date from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@link Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current ISO local date, not null
   * @throws DateTimeException if unable to create the date
  */
  dateNow(clock: Clock): LocalDate;
  /**
   * Checks if the year is a leap year, according to the ISO proleptic
   * calendar system rules.
   * 
   * This method applies the current rules for leap years across the whole time-line.
   * In general, a year is a leap year if it is divisible by four without
   * remainder. However, years divisible by 100, are not leap years, with
   * the exception of years divisible by 400 which are.
   * 
   * For example, 1904 is a leap year it is divisible by 4.
   * 1900 was not a leap year as it is divisible by 100, however 2000 was a
   * leap year as it is divisible by 400.
   * 
   * The calculation is proleptic - applying the same rules into the far future and far past.
   * This is historically inaccurate, but is correct for the ISO-8601 standard.
   *
   * @param prolepticYear  the ISO proleptic year to check
   * @return true if the year is leap, false otherwise
  */
  isLeapYear(prolepticYear: number): boolean;
  prolepticYear(era: Era, yearOfEra: number): number;
  eraOf(eraValue: number): IsoEra;
  eras(): Era[];
  /**
   * Resolves parsed `ChronoField` values into a date during parsing.
   * 
   * Most `TemporalField` implementations are resolved using the
   * resolve method on the field. By contrast, the `ChronoField` class
   * defines fields that only have meaning relative to the chronology.
   * As such, `ChronoField` date fields are resolved here in the
   * context of a specific chronology.
   * 
   * `ChronoField` instances on the ISO calendar system are resolved
   * as follows.
   * 
   * `EPOCH_DAY` - If present, this is converted to a `LocalDate`
   *  and all other date fields are then cross-checked against the date.
   * `PROLEPTIC_MONTH` - If present, then it is split into the
   *  `YEAR` and `MONTH_OF_YEAR`. If the mode is strict or smart
   *  then the field is validated.
   * `YEAR_OF_ERA` and `ERA` - If both are present, then they
   *  are combined to form a `YEAR`. In lenient mode, the `YEAR_OF_ERA`
   *  range is not validated, in smart and strict mode it is. The `ERA` is
   *  validated for range in all three modes. If only the `YEAR_OF_ERA` is
   *  present, and the mode is smart or lenient, then the current era (CE/AD)
   *  is assumed. In strict mode, no era is assumed and the `YEAR_OF_ERA` is
   *  left untouched. If only the `ERA` is present, then it is left untouched.
   * `YEAR`, `MONTH_OF_YEAR` and `DAY_OF_MONTH` -
   *  If all three are present, then they are combined to form a `LocalDate`.
   *  In all three modes, the `YEAR` is validated. If the mode is smart or strict,
   *  then the month and day are validated, with the day validated from 1 to 31.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first of January in the requested year, then adding
   *  the difference in months, then the difference in days.
   *  If the mode is smart, and the day-of-month is greater than the maximum for
   *  the year-month, then the day-of-month is adjusted to the last day-of-month.
   *  If the mode is strict, then the three fields must form a valid date.
   * `YEAR` and `DAY_OF_YEAR` -
   *  If both are present, then they are combined to form a `LocalDate`.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first of January in the requested year, then adding
   *  the difference in days.
   *  If the mode is smart or strict, then the two fields must form a valid date.
   * `YEAR`, `MONTH_OF_YEAR`, `ALIGNED_WEEK_OF_MONTH` and
   *  `ALIGNED_DAY_OF_WEEK_IN_MONTH` -
   *  If all four are present, then they are combined to form a `LocalDate`.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first of January in the requested year, then adding
   *  the difference in months, then the difference in weeks, then in days.
   *  If the mode is smart or strict, then the all four fields are validated to
   *  their outer ranges. The date is then combined in a manner equivalent to
   *  creating a date on the first day of the requested year and month, then adding
   *  the amount in weeks and days to reach their values. If the mode is strict,
   *  the date is additionally validated to check that the day and week adjustment
   *  did not change the month.
   * `YEAR`, `MONTH_OF_YEAR`, `ALIGNED_WEEK_OF_MONTH` and
   *  `DAY_OF_WEEK` - If all four are present, then they are combined to
   *  form a `LocalDate`. The approach is the same as described above for
   *  years, months and weeks in `ALIGNED_DAY_OF_WEEK_IN_MONTH`.
   *  The day-of-week is adjusted as the next or same matching day-of-week once
   *  the years, months and weeks have been handled.
   * `YEAR`, `ALIGNED_WEEK_OF_YEAR` and `ALIGNED_DAY_OF_WEEK_IN_YEAR` -
   *  If all three are present, then they are combined to form a `LocalDate`.
   *  In all three modes, the `YEAR` is validated.
   *  If the mode is lenient, then the date is combined in a manner equivalent to
   *  creating a date on the first of January in the requested year, then adding
   *  the difference in weeks, then in days.
   *  If the mode is smart or strict, then the all three fields are validated to
   *  their outer ranges. The date is then combined in a manner equivalent to
   *  creating a date on the first day of the requested year, then adding
   *  the amount in weeks and days to reach their values. If the mode is strict,
   *  the date is additionally validated to check that the day and week adjustment
   *  did not change the year.
   * `YEAR`, `ALIGNED_WEEK_OF_YEAR` and `DAY_OF_WEEK` -
   *  If all three are present, then they are combined to form a `LocalDate`.
   *  The approach is the same as described above for years and weeks in
   *  `ALIGNED_DAY_OF_WEEK_IN_YEAR`. The day-of-week is adjusted as the
   *  next or same matching day-of-week once the years and weeks have been handled.
   * 
   *
   * @param fieldValues  the map of fields to values, which can be updated, not null
   * @param resolverStyle  the requested type of resolve, not null
   * @return the resolved date, null if insufficient information to create a date
   * @throws DateTimeException if the date cannot be resolved, typically
   *  because of a conflict in the input data
  */
  resolveDate(fieldValues: Map<TemporalField,number>, resolverStyle: ResolverStyle): LocalDate;
  range(field: ChronoField): ValueRange;
  /**
   * Obtains a period for this chronology based on years, months and days.
   * 
   * This returns a period tied to the ISO chronology using the specified
   * years, months and days. See {@link Period} for further details.
   *
   * @param years  the number of years, may be negative
   * @param months  the number of years, may be negative
   * @param days  the number of years, may be negative
   * @return the ISO period, not null
  */
  period(years: number, months: number, days: number): Period;
  /**
   * `IsoChronology` is an ISO based chronology, which supports fields
   * in {@link IsoFields}, such as {@link IsoFields#DAY_OF_QUARTER DAY_OF_QUARTER}
   * and {@link IsoFields#QUARTER_OF_YEAR QUARTER_OF_YEAR}.
   * @see IsoFields
   * @return `true`
   * @since 19
  */
  isIsoBased(): boolean;
  /**
   * Gets the number of seconds from the epoch of 1970-01-01T00:00:00Z.
   * 
   * The number of seconds is calculated using the era, year-of-era,
   * month, day-of-month, hour, minute, second, and zoneOffset.
   *
   * @param era  the era of the correct type for the chronology, not null
   * @param yearOfEra the chronology year-of-era
   * @param month the chronology month-of-year
   * @param dayOfMonth the chronology day-of-month
   * @param hour the hour-of-day, from 0 to 23
   * @param minute the minute-of-hour, from 0 to 59
   * @param second the second-of-minute, from 0 to 59
   * @param zoneOffset the zone offset, not null
   * @return the number of seconds relative to 1970-01-01T00:00:00Z, may be negative
   * @throws DateTimeException if any of the values are out of range
   * @since 9
  */
  epochSecond(era: Era, yearOfEra: number, month: number, dayOfMonth: number, hour: number, minute: number, second: number, zoneOffset: ZoneOffset): number;
}
export interface IsoChronology extends AbstractChronology, Serializable {}
/**
 * A date-based amount of time, such as '3 years, 4 months and 5 days' in an
 * arbitrary chronology, intended for advanced globalization use cases.
 * 
 * This interface models a date-based amount of time in a calendar system.
 * While most calendar systems use years, months and days, some do not.
 * Therefore, this interface operates solely in terms of a set of supported
 * units that are defined by the `Chronology`.
 * The set of supported units is fixed for a given chronology.
 * The amount of a supported unit may be set to zero.
 * 
 * The period is modeled as a directed amount of time, meaning that individual
 * parts of the period may be negative.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @since 1.8
*/
export class ChronoPeriod extends TemporalAmount {
  /**
   * Obtains a `ChronoPeriod` consisting of amount of time between two dates.
   * 
   * The start date is included, but the end date is not.
   * The period is calculated using {@link ChronoLocalDate#until(ChronoLocalDate)}.
   * As such, the calculation is chronology specific.
   * 
   * The chronology of the first date is used.
   * The chronology of the second date is ignored, with the date being converted
   * to the target chronology system before the calculation starts.
   * 
   * The result of this method can be a negative period if the end is before the start.
   * In most cases, the positive/negative sign will be the same in each of the supported fields.
   *
   * @param startDateInclusive  the start date, inclusive, specifying the chronology of the calculation, not null
   * @param endDateExclusive  the end date, exclusive, in any chronology, not null
   * @return the period between this date and the end date, not null
   * @see ChronoLocalDate#until(ChronoLocalDate)
  */
  static between(startDateInclusive: ChronoLocalDate, endDateExclusive: ChronoLocalDate): ChronoPeriod;
  /**
   * Gets the value of the requested unit.
   * 
   * The supported units are chronology specific.
   * They will typically be {@link ChronoUnit#YEARS YEARS},
   * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
   * Requesting an unsupported unit will throw an exception.
   *
   * @param unit the `TemporalUnit` for which to return the value
   * @return the long value of the unit
   * @throws DateTimeException if the unit is not supported
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  get(unit: TemporalUnit): number;
  /**
   * Gets the set of units supported by this period.
   * 
   * The supported units are chronology specific.
   * They will typically be {@link ChronoUnit#YEARS YEARS},
   * {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
   * They are returned in order from largest to smallest.
   * 
   * This set can be used in conjunction with {@link #get(TemporalUnit)}
   * to access the entire state of the period.
   *
   * @return a list containing the supported units, not null
  */
  get units(): TemporalUnit[];
  /**
   * Gets the chronology that defines the meaning of the supported units.
   * 
   * The period is defined by the chronology.
   * It controls the supported units and restricts addition/subtraction
   * to `ChronoLocalDate` instances of the same chronology.
   *
   * @return the chronology defining the period, not null
  */
  get chronology(): Chronology;
  /**
   * Checks if all the supported units of this period are zero.
   *
   * @return true if this period is zero-length
  */
  isZero(): boolean;
  /**
   * Checks if any of the supported units of this period are negative.
   *
   * @return true if any unit of this period is negative
  */
  isNegative(): boolean;
  /**
   * Returns a copy of this period with the specified period added.
   * 
   * If the specified amount is a `ChronoPeriod` then it must have
   * the same chronology as this period. Implementations may choose to
   * accept or reject other `TemporalAmount` implementations.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToAdd  the period to add, not null
   * @return a `ChronoPeriod` based on this period with the requested period added, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  plus(amountToAdd: TemporalAmount): ChronoPeriod;
  /**
   * Returns a copy of this period with the specified period subtracted.
   * 
   * If the specified amount is a `ChronoPeriod` then it must have
   * the same chronology as this period. Implementations may choose to
   * accept or reject other `TemporalAmount` implementations.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param amountToSubtract  the period to subtract, not null
   * @return a `ChronoPeriod` based on this period with the requested period subtracted, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  minus(amountToSubtract: TemporalAmount): ChronoPeriod;
  /**
   * Returns a new instance with each amount in this period in this period
   * multiplied by the specified scalar.
   * 
   * This returns a period with each supported unit individually multiplied.
   * For example, a period of "2 years, -3 months and 4 days" multiplied by
   * 3 will return "6 years, -9 months and 12 days".
   * No normalization is performed.
   *
   * @param scalar  the scalar to multiply by, not null
   * @return a `ChronoPeriod` based on this period with the amounts multiplied
   *  by the scalar, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  multipliedBy(scalar: number): ChronoPeriod;
  /**
   * Returns a new instance with each amount in this period negated.
   * 
   * This returns a period with each supported unit individually negated.
   * For example, a period of "2 years, -3 months and 4 days" will be
   * negated to "-2 years, 3 months and -4 days".
   * No normalization is performed.
   *
   * @return a `ChronoPeriod` based on this period with the amounts negated, not null
   * @throws ArithmeticException if numeric overflow occurs, which only happens if
   *  one of the units has the value `Long.MIN_VALUE`
  */
  negated(): ChronoPeriod;
  /**
   * Returns a copy of this period with the amounts of each unit normalized.
   * 
   * The process of normalization is specific to each calendar system.
   * For example, in the ISO calendar system, the years and months are
   * normalized but the days are not, such that "15 months" would be
   * normalized to "1 year and 3 months".
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `ChronoPeriod` based on this period with the amounts of each
   *  unit normalized, not null
   * @throws ArithmeticException if numeric overflow occurs
  */
  normalized(): ChronoPeriod;
  /**
   * Adds this period to the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this period added.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#plus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisPeriod.addTo(dateTime);
   *   dateTime = dateTime.plus(thisPeriod);
   * 
   * 
   * The specified temporal must have the same chronology as this period.
   * This returns a temporal with the non-zero supported units added.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to add
   * @throws ArithmeticException if numeric overflow occurs
  */
  addTo(temporal: Temporal): Temporal;
  /**
   * Subtracts this period from the specified temporal object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with this period subtracted.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#minus(TemporalAmount)}.
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   dateTime = thisPeriod.subtractFrom(dateTime);
   *   dateTime = dateTime.minus(thisPeriod);
   * 
   * 
   * The specified temporal must have the same chronology as this period.
   * This returns a temporal with the non-zero supported units subtracted.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the temporal object to adjust, not null
   * @return an object of the same type with the adjustment made, not null
   * @throws DateTimeException if unable to subtract
   * @throws ArithmeticException if numeric overflow occurs
  */
  subtractFrom(temporal: Temporal): Temporal;
  /**
   * Checks if this period is equal to another period, including the chronology.
   * 
   * Compares this period with another ensuring that the type, each amount and
   * the chronology are the same.
   * Note that this means that a period of "15 Months" is not equal to a period
   * of "1 Year and 3 Months".
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other period
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this period.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this period as a `String`.
   * 
   * The output will include the period amounts and chronology.
   *
   * @return a string representation of this period, not null
  */
  toString(): string;
}
/**
 * A date without time-of-day or time-zone in an arbitrary chronology, intended
 * for advanced globalization use cases.
 * 
 * Most applications should declare method signatures, fields and variables
 * as {@link LocalDate}, not this interface.
 * 
 * A `ChronoLocalDate` is the abstract representation of a date where the
 * `Chronology chronology`, or calendar system, is pluggable.
 * The date is defined in terms of fields expressed by {@link TemporalField},
 * where most common implementations are defined in {@link ChronoField}.
 * The chronology defines how the calendar system operates and the meaning of
 * the standard fields.
 *
 * When to use this interface
 * The design of the API encourages the use of `LocalDate` rather than this
 * interface, even in the case where the application needs to deal with multiple
 * calendar systems.
 * 
 * This concept can seem surprising at first, as the natural way to globalize an
 * application might initially appear to be to abstract the calendar system.
 * However, as explored below, abstracting the calendar system is usually the wrong
 * approach, resulting in logic errors and hard to find bugs.
 * As such, it should be considered an application-wide architectural decision to choose
 * to use this interface as opposed to `LocalDate`.
 *
 * Architectural issues to consider
 * These are some of the points that must be considered before using this interface
 * throughout an application.
 * 
 * 1) Applications using this interface, as opposed to using just `LocalDate`,
 * face a significantly higher probability of bugs. This is because the calendar system
 * in use is not known at development time. A key cause of bugs is where the developer
 * applies assumptions from their day-to-day knowledge of the ISO calendar system
 * to code that is intended to deal with any arbitrary calendar system.
 * The section below outlines how those assumptions can cause problems
 * The primary mechanism for reducing this increased risk of bugs is a strong code review process.
 * This should also be considered a extra cost in maintenance for the lifetime of the code.
 * 
 * 2) This interface does not enforce immutability of implementations.
 * While the implementation notes indicate that all implementations must be immutable
 * there is nothing in the code or type system to enforce this. Any method declared
 * to accept a `ChronoLocalDate` could therefore be passed a poorly or
 * maliciously written mutable implementation.
 * 
 * 3) Applications using this interface  must consider the impact of eras.
 * `LocalDate` shields users from the concept of eras, by ensuring that `getYear()`
 * returns the proleptic year. That decision ensures that developers can think of
 * `LocalDate` instances as consisting of three fields - year, month-of-year and day-of-month.
 * By contrast, users of this interface must think of dates as consisting of four fields -
 * era, year-of-era, month-of-year and day-of-month. The extra era field is frequently
 * forgotten, yet it is of vital importance to dates in an arbitrary calendar system.
 * For example, in the Japanese calendar system, the era represents the reign of an Emperor.
 * Whenever one reign ends and another starts, the year-of-era is reset to one.
 * 
 * 4) The only agreed international standard for passing a date between two systems
 * is the ISO-8601 standard which requires the ISO calendar system. Using this interface
 * throughout the application will inevitably lead to the requirement to pass the date
 * across a network or component boundary, requiring an application specific protocol or format.
 * 
 * 5) Long term persistence, such as a database, will almost always only accept dates in the
 * ISO-8601 calendar system (or the related Julian-Gregorian). Passing around dates in other
 * calendar systems increases the complications of interacting with persistence.
 * 
 * 6) Most of the time, passing a `ChronoLocalDate` throughout an application
 * is unnecessary, as discussed in the last section below.
 *
 * False assumptions causing bugs in multi-calendar system code
 * As indicated above, there are many issues to consider when try to use and manipulate a
 * date in an arbitrary calendar system. These are some of the key issues.
 * 
 * Code that queries the day-of-month and assumes that the value will never be more than
 * 31 is invalid. Some calendar systems have more than 31 days in some months.
 * 
 * Code that adds 12 months to a date and assumes that a year has been added is invalid.
 * Some calendar systems have a different number of months, such as 13 in the Coptic or Ethiopic.
 * 
 * Code that adds one month to a date and assumes that the month-of-year value will increase
 * by one or wrap to the next year is invalid. Some calendar systems have a variable number
 * of months in a year, such as the Hebrew.
 * 
 * Code that adds one month, then adds a second one month and assumes that the day-of-month
 * will remain close to its original value is invalid. Some calendar systems have a large difference
 * between the length of the longest month and the length of the shortest month.
 * For example, the Coptic or Ethiopic have 12 months of 30 days and 1 month of 5 days.
 * 
 * Code that adds seven days and assumes that a week has been added is invalid.
 * Some calendar systems have weeks of other than seven days, such as the French Revolutionary.
 * 
 * Code that assumes that because the year of `date1` is greater than the year of `date2`
 * then `date1` is after `date2` is invalid. This is invalid for all calendar systems
 * when referring to the year-of-era, and especially untrue of the Japanese calendar system
 * where the year-of-era restarts with the reign of every new Emperor.
 * 
 * Code that treats month-of-year one and day-of-month one as the start of the year is invalid.
 * Not all calendar systems start the year when the month value is one.
 * 
 * In general, manipulating a date, and even querying a date, is wide open to bugs when the
 * calendar system is unknown at development time. This is why it is essential that code using
 * this interface is subjected to additional code reviews. It is also why an architectural
 * decision to avoid this interface type is usually the correct one.
 *
 * Using LocalDate instead
 * The primary alternative to using this interface throughout your application is as follows.
 * 
 * Declare all method signatures referring to dates in terms of `LocalDate`.
 * Either store the chronology (calendar system) in the user profile or lookup
 *  the chronology from the user locale
 * Convert the ISO `LocalDate` to and from the user's preferred calendar system during
 *  printing and parsing
 * 
 * This approach treats the problem of globalized calendar systems as a localization issue
 * and confines it to the UI layer. This approach is in keeping with other localization
 * issues in the java platform.
 * 
 * As discussed above, performing calculations on a date where the rules of the calendar system
 * are pluggable requires skill and is not recommended.
 * Fortunately, the need to perform calculations on a date in an arbitrary calendar system
 * is extremely rare. For example, it is highly unlikely that the business rules of a library
 * book rental scheme will allow rentals to be for one month, where meaning of the month
 * is dependent on the user's preferred calendar system.
 * 
 * A key use case for calculations on a date in an arbitrary calendar system is producing
 * a month-by-month calendar for display and user interaction. Again, this is a UI issue,
 * and use of this interface solely within a few methods of the UI layer may be justified.
 * 
 * In any other part of the system, where a date must be manipulated in a calendar system
 * other than ISO, the use case will generally specify the calendar system to use.
 * For example, an application may need to calculate the next Islamic or Hebrew holiday
 * which may require manipulating the date.
 * This kind of use case can be handled as follows:
 * 
 * start from the ISO `LocalDate` being passed to the method
 * convert the date to the alternate calendar system, which for this use case is known
 *  rather than arbitrary
 * perform the calculation
 * convert back to `LocalDate`
 * 
 * Developers writing low-level frameworks or libraries should also avoid this interface.
 * Instead, one of the two general purpose access interfaces should be used.
 * Use {@link TemporalAccessor} if read-only access is required, or use {@link Temporal}
 * if read-write access is required.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 * 
 * Additional calendar systems may be added to the system.
 * See {@link Chronology} for more details.
 *
 * @since 1.8
*/
export class ChronoLocalDate extends Temporal {
  /**
   * Gets a comparator that compares `ChronoLocalDate` in
   * time-line order ignoring the chronology.
   * 
   * This comparator differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the position of the date on the local time-line.
   * The underlying comparison is equivalent to comparing the epoch-day.
   *
   * @return a comparator that compares in time-line order ignoring the chronology
   * @see #isAfter
   * @see #isBefore
   * @see #isEqual
  */
  static timeLineOrder(): Comparator<ChronoLocalDate>;
  /**
   * Obtains an instance of `ChronoLocalDate` from a temporal object.
   * 
   * This obtains a local date based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoLocalDate`.
   * 
   * The conversion extracts and combines the chronology and the date
   * from the temporal object. The behavior is equivalent to using
   * {@link Chronology#date(TemporalAccessor)} with the extracted chronology.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ChronoLocalDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date, not null
   * @throws DateTimeException if unable to convert to a `ChronoLocalDate`
   * @see Chronology#date(TemporalAccessor)
  */
  static from(temporal: TemporalAccessor): ChronoLocalDate;
  /**
   * Gets the chronology of this date.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the chronology, not null
  */
  get chronology(): Chronology;
  /**
   * Gets the era, as defined by the chronology.
   * 
   * The era is, conceptually, the largest division of the time-line.
   * Most calendar systems have a single epoch dividing the time-line into two eras.
   * However, some have multiple eras, such as one for the reign of each leader.
   * The exact meaning is determined by the `Chronology`.
   * 
   * All correctly implemented `Era` classes are singletons, thus it
   * is valid code to write `date.getEra() == SomeChrono.ERA_NAME)`.
   * 
   * This default implementation uses {@link Chronology#eraOf(int)}.
   *
   * @return the chronology specific era constant applicable at this date, not null
  */
  get era(): Era;
  /**
   * Checks if the year is a leap year, as defined by the calendar system.
   * 
   * A leap-year is a year of a longer length than normal.
   * The exact meaning is determined by the chronology with the constraint that
   * a leap-year must imply a year-length longer than a non leap-year.
   * 
   * This default implementation uses {@link Chronology#isLeapYear(long)}.
   *
   * @return true if this date is in a leap year, false otherwise
  */
  isLeapYear(): boolean;
  /**
   * Returns the length of the month represented by this date, as defined by the calendar system.
   * 
   * This returns the length of the month in days.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  /**
   * Returns the length of the year represented by this date, as defined by the calendar system.
   * 
   * This returns the length of the year in days.
   * 
   * The default implementation uses {@link #isLeapYear()} and returns 365 or 366.
   *
   * @return the length of the year in days
  */
  lengthOfYear(): number;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if the specified field can be queried on this date.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * The set of supported fields is defined by the chronology and normally includes
   * all `ChronoField` date fields.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field can be queried, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to or subtracted from this date.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * The set of supported units is defined by the chronology and normally includes
   * all `ChronoUnit` date units except `FOREVER`.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): ChronoLocalDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws UnsupportedTemporalTypeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(field: TemporalField, newValue: number): ChronoLocalDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): ChronoLocalDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amountToAdd: number, unit: TemporalUnit): ChronoLocalDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): ChronoLocalDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws UnsupportedTemporalTypeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amountToSubtract: number, unit: TemporalUnit): ChronoLocalDate;
  /**
   * Queries this date using the specified query.
   * 
   * This queries this date using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Adjusts the specified temporal object to have the same date as this object.
   * 
   * This returns a temporal object of the same observable type as the input
   * with the date changed to be the same as this.
   * 
   * The adjustment is equivalent to using {@link Temporal#with(TemporalField, long)}
   * passing {@link ChronoField#EPOCH_DAY} as the field.
   * 
   * In most cases, it is clearer to reverse the calling pattern by using
   * {@link Temporal#with(TemporalAdjuster)}:
   *      *   // these two lines are equivalent, but the second approach is recommended
   *   temporal = thisLocalDate.adjustInto(temporal);
   *   temporal = temporal.with(thisLocalDate);
   * 
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param temporal  the target object to be adjusted, not null
   * @return the adjusted object, not null
   * @throws DateTimeException if unable to make the adjustment
   * @throws ArithmeticException if numeric overflow occurs
  */
  adjustInto(temporal: Temporal): Temporal;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ChronoLocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `ChronoLocalDate` using {@link Chronology#date(TemporalAccessor)}.
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * should be supported by all implementations.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a
   *  `ChronoLocalDate` in the same chronology, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ChronoLocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
  /**
   * Calculates the period between this date and another date as a `ChronoPeriod`.
   * 
   * This calculates the period between two dates. All supplied chronologies
   * calculate the period using years, months and days, however the
   * `ChronoPeriod` API allows the period to be represented using other units.
   * 
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The negative sign will be the same in each of year, month and day.
   * 
   * The calculation is performed using the chronology of this date.
   * If necessary, the input date will be converted to match.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endDateExclusive  the end date, exclusive, which may be in any chronology, not null
   * @return the period between this date and the end date, not null
   * @throws DateTimeException if the period cannot be calculated
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endDateExclusive: ChronoLocalDate): ChronoPeriod;
  /**
   * Formats this date using the specified formatter.
   * 
   * This date will be passed to the formatter to produce a string.
   * 
   * The default implementation must behave as follows:
   *      *  return formatter.format(this);
   * 
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Combines this date with a time to create a `ChronoLocalDateTime`.
   * 
   * This returns a `ChronoLocalDateTime` formed from this date at the specified time.
   * All possible combinations of date and time are valid.
   *
   * @param localTime  the local time to use, not null
   * @return the local date-time formed from this date and the specified time, not null
  */
  atTime(localTime: LocalTime): ChronoLocalDateTime<any>;
  /**
   * Converts this date to the Epoch Day.
   * 
   * The {@link ChronoField#EPOCH_DAY Epoch Day count} is a simple
   * incrementing count of days where day 0 is 1970-01-01 (ISO).
   * This definition is the same for all chronologies, enabling conversion.
   * 
   * This default implementation queries the `EPOCH_DAY` field.
   *
   * @return the Epoch Day equivalent to this date
  */
  toEpochDay(): number;
  /**
   * Compares this date to another date, including the chronology.
   * 
   * The comparison is based first on the underlying time-line date, then
   * on the chronology.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * For example, the following is the comparator order:
   * 
   * `2012-12-03 (ISO)`
   * `2012-12-04 (ISO)`
   * `2555-12-04 (ThaiBuddhist)`
   * `2012-12-05 (ISO)`
   * 
   * Values #2 and #3 represent the same date on the time-line.
   * When two values represent the same date, the chronology ID is compared to distinguish them.
   * This step is needed to make the ordering "consistent with equals".
   * 
   * If all the date objects being compared are in the same chronology, then the
   * additional chronology stage is not required and only the local date is used.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   * 
   * This default implementation performs the comparison defined above.
   *
   * @param other  the other date to compare to, not null
   * @return the comparator value, that is the comparison of this local date with
   *          the `other` local date and this chronology with the `other` chronology,
   *          in order, returning the first non-zero result, and otherwise returning zero
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: ChronoLocalDate): number;
  /**
   * Checks if this date is after the specified date ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the time-line position.
   * This is equivalent to using `date1.toEpochDay() > date2.toEpochDay()`.
   * 
   * This default implementation performs the comparison based on the epoch-day.
   *
   * @param other  the other date to compare to, not null
   * @return true if this is after the specified date
  */
  isAfter(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is before the specified date ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the time-line position.
   * This is equivalent to using `date1.toEpochDay() < date2.toEpochDay()`.
   * 
   * This default implementation performs the comparison based on the epoch-day.
   *
   * @param other  the other date to compare to, not null
   * @return true if this is before the specified date
  */
  isBefore(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is equal to the specified date ignoring the chronology.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying date and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the time-line position.
   * This is equivalent to using `date1.toEpochDay() == date2.toEpochDay()`.
   * 
   * This default implementation performs the comparison based on the epoch-day.
   *
   * @param other  the other date to compare to, not null
   * @return true if the underlying date is equal to the specified date
  */
  isEqual(other: ChronoLocalDate): boolean;
  /**
   * Checks if this date is equal to another date, including the chronology.
   * 
   * Compares this date with another ensuring that the date and chronology are the same.
   * 
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date as a `String`.
   * 
   * The output will include the full local date.
   *
   * @return the formatted date, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface ChronoLocalDate extends Temporal, TemporalAdjuster, Comparable<ChronoLocalDate> {}
/**
 * An era in the Hijrah calendar system.
 * 
 * The Hijrah calendar system has only one era covering the
 * proleptic years greater than zero.
 * 
 * Do not use `ordinal()` to obtain the numeric representation of `HijrahEra`.
 * Use `getValue()` instead.
 *
 * @implSpec
 * This is an immutable and thread-safe enum.
 *
 * @since 1.8
*/
export class HijrahEra extends Enum<HijrahEra> {
  /**
   * The singleton instance for the current era, 'Anno Hegirae',
   * which has the numeric value 1.
  */
  static readonly AH: HijrahEra;
  static valueOf(name: string): HijrahEra;
  static values(): HijrahEra[];
  /**
   * Obtains an instance of `HijrahEra` from an `int` value.
   * 
   * The current era, which is the only accepted value, has the value 1
   *
   * @param hijrahEra  the era to represent, only 1 supported
   * @return the HijrahEra.AH singleton, not null
   * @throws DateTimeException if the value is invalid
  */
  static of(hijrahEra: number): HijrahEra;
  /**
   * Gets the numeric era `int` value.
   * 
   * The era AH has the value 1.
   *
   * @return the era value, 1 (AH)
  */
  get value(): number;
  /**
   * Gets the range of valid values for the specified field.
   * 
   * The range object expresses the minimum and maximum valid values for a field.
   * This era is used to enhance the accuracy of the returned range.
   * If it is not possible to return the range, because the field is not supported
   * or for some other reason, an exception is thrown.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The `ERA` field returns the range.
   * All other `ChronoField` instances will throw an `UnsupportedTemporalTypeException`.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.rangeRefinedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the range can be obtained is determined by the field.
   * 
   * The `ERA` field returns a range for the one valid Hijrah era.
   *
   * @param field  the field to query the range for, not null
   * @return the range of valid values for the field, not null
   * @throws DateTimeException if the range for the field cannot be obtained
   * @throws UnsupportedTemporalTypeException if the unit is not supported
  */
  range(field: TemporalField): ValueRange;
  /**
   * {@inheritDoc}
   *
   * @param style {@inheritDoc}
   * @param locale {@inheritDoc}
  */
  getDisplayName(style: TextStyle, locale: Locale): string;
}
/**
 * A date-time with a time-zone in an arbitrary chronology,
 * intended for advanced globalization use cases.
 * 
 * Most applications should declare method signatures, fields and variables
 * as {@link ZonedDateTime}, not this interface.
 * 
 * A `ChronoZonedDateTime` is the abstract representation of an offset date-time
 * where the `Chronology chronology`, or calendar system, is pluggable.
 * The date-time is defined in terms of fields expressed by {@link TemporalField},
 * where most common implementations are defined in {@link ChronoField}.
 * The chronology defines how the calendar system operates and the meaning of
 * the standard fields.
 *
 * When to use this interface
 * The design of the API encourages the use of `ZonedDateTime` rather than this
 * interface, even in the case where the application needs to deal with multiple
 * calendar systems. The rationale for this is explored in detail in {@link ChronoLocalDate}.
 * 
 * Ensure that the discussion in `ChronoLocalDate` has been read and understood
 * before using this interface.
 *
 * @implSpec
 * This interface must be implemented with care to ensure other classes operate correctly.
 * All implementations that can be instantiated must be final, immutable and thread-safe.
 * Subclasses should be Serializable wherever possible.
 *
 * @param  the concrete type for the date of this date-time
 * @since 1.8
*/
export class ChronoZonedDateTime<D> extends Temporal {
  /**
   * Gets a comparator that compares `ChronoZonedDateTime` in
   * time-line order ignoring the chronology.
   * 
   * This comparator differs from the comparison in {@link #compareTo} in that it
   * only compares the underlying instant and not the chronology.
   * This allows dates in different calendar systems to be compared based
   * on the position of the date-time on the instant time-line.
   * The underlying comparison is equivalent to comparing the epoch-second and nano-of-second.
   *
   * @return a comparator that compares in time-line order ignoring the chronology
   * @see #isAfter
   * @see #isBefore
   * @see #isEqual
  */
  static timeLineOrder(): Comparator<ChronoZonedDateTime<any>>;
  /**
   * Obtains an instance of `ChronoZonedDateTime` from a temporal object.
   * 
   * This creates a zoned date-time based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `ChronoZonedDateTime`.
   * 
   * The conversion extracts and combines the chronology, date, time and zone
   * from the temporal object. The behavior is equivalent to using
   * {@link Chronology#zonedDateTime(TemporalAccessor)} with the extracted chronology.
   * Implementations are permitted to perform optimizations such as accessing
   * those fields that are equivalent to the relevant objects.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `ChronoZonedDateTime::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date-time, not null
   * @throws DateTimeException if unable to convert to a `ChronoZonedDateTime`
   * @see Chronology#zonedDateTime(TemporalAccessor)
  */
  static from(temporal: TemporalAccessor): ChronoZonedDateTime<any>;
  range(field: TemporalField): ValueRange;
  get(field: TemporalField): number;
  getLong(field: TemporalField): number;
  /**
   * Gets the local date part of this date-time.
   * 
   * This returns a local date with the same year, month and day
   * as this date-time.
   *
   * @return the date part of this date-time, not null
  */
  toLocalDate(): D;
  /**
   * Gets the local time part of this date-time.
   * 
   * This returns a local time with the same hour, minute, second and
   * nanosecond as this date-time.
   *
   * @return the time part of this date-time, not null
  */
  toLocalTime(): LocalTime;
  /**
   * Gets the local date-time part of this date-time.
   * 
   * This returns a local date with the same year, month and day
   * as this date-time.
   *
   * @return the local date-time part of this date-time, not null
  */
  toLocalDateTime(): ChronoLocalDateTime<D>;
  /**
   * Gets the chronology of this date-time.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the chronology, not null
  */
  get chronology(): Chronology;
  /**
   * Gets the zone offset, such as '+01:00'.
   * 
   * This is the offset of the local date-time from UTC/Greenwich.
   *
   * @return the zone offset, not null
  */
  get offset(): ZoneOffset;
  /**
   * Gets the zone ID, such as 'Europe/Paris'.
   * 
   * This returns the stored time-zone id used to determine the time-zone rules.
   *
   * @return the zone ID, not null
  */
  get zone(): ZoneId;
  /**
   * Returns a copy of this date-time changing the zone offset to the
   * earlier of the two valid offsets at a local time-line overlap.
   * 
   * This method only has any effect when the local time-line overlaps, such as
   * at an autumn daylight savings cutover. In this scenario, there are two
   * valid offsets for the local date-time. Calling this method will return
   * a zoned date-time with the earlier of the two selected.
   * 
   * If this method is called when it is not an overlap, `this`
   * is returned.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `ChronoZonedDateTime` based on this date-time with the earlier offset, not null
   * @throws DateTimeException if no rules can be found for the zone
   * @throws DateTimeException if no rules are valid for this date-time
  */
  withEarlierOffsetAtOverlap(): ChronoZonedDateTime<D>;
  /**
   * Returns a copy of this date-time changing the zone offset to the
   * later of the two valid offsets at a local time-line overlap.
   * 
   * This method only has any effect when the local time-line overlaps, such as
   * at an autumn daylight savings cutover. In this scenario, there are two
   * valid offsets for the local date-time. Calling this method will return
   * a zoned date-time with the later of the two selected.
   * 
   * If this method is called when it is not an overlap, `this`
   * is returned.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @return a `ChronoZonedDateTime` based on this date-time with the later offset, not null
   * @throws DateTimeException if no rules can be found for the zone
   * @throws DateTimeException if no rules are valid for this date-time
  */
  withLaterOffsetAtOverlap(): ChronoZonedDateTime<D>;
  /**
   * Returns a copy of this date-time with a different time-zone,
   * retaining the local date-time if possible.
   * 
   * This method changes the time-zone and retains the local date-time.
   * The local date-time is only changed if it is invalid for the new zone.
   * 
   * To change the zone and adjust the local date-time,
   * use {@link #withZoneSameInstant(ZoneId)}.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param zone  the time-zone to change to, not null
   * @return a `ChronoZonedDateTime` based on this date-time with the requested zone, not null
  */
  withZoneSameLocal(zone: ZoneId): ChronoZonedDateTime<D>;
  /**
   * Returns a copy of this date-time with a different time-zone,
   * retaining the instant.
   * 
   * This method changes the time-zone and retains the instant.
   * This normally results in a change to the local date-time.
   * 
   * This method is based on retaining the same instant, thus gaps and overlaps
   * in the local time-line have no effect on the result.
   * 
   * To change the offset while keeping the local time,
   * use {@link #withZoneSameLocal(ZoneId)}.
   *
   * @param zone  the time-zone to change to, not null
   * @return a `ChronoZonedDateTime` based on this date-time with the requested zone, not null
   * @throws DateTimeException if the result exceeds the supported date range
  */
  withZoneSameInstant(zone: ZoneId): ChronoZonedDateTime<D>;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if the specified field can be queried on this date-time.
   * If false, then calling the {@link #range(TemporalField) range},
   * {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
   * methods will throw an exception.
   * 
   * The set of supported fields is defined by the chronology and normally includes
   * all `ChronoField` fields.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field can be queried, false if not
  */
  isSupported(field: TemporalField): boolean;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to or subtracted from this date-time.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * The set of supported units is defined by the chronology and normally includes
   * all `ChronoUnit` units except `FOREVER`.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): ChronoZonedDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(field: TemporalField, newValue: number): ChronoZonedDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): ChronoZonedDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amountToAdd: number, unit: TemporalUnit): ChronoZonedDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): ChronoZonedDateTime<D>;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amountToSubtract: number, unit: TemporalUnit): ChronoZonedDateTime<D>;
  /**
   * Queries this date-time using the specified query.
   * 
   * This queries this date-time using the specified query strategy object.
   * The `TemporalQuery` object defines the logic to be used to
   * obtain the result. Read the documentation of the query to understand
   * what the result of this method will be.
   * 
   * The result of this method is obtained by invoking the
   * {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
   * specified query passing `this` as the argument.
   *
   * @param  the type of the result
   * @param query  the query to invoke, not null
   * @return the query result, null may be returned (defined by the query)
   * @throws DateTimeException if unable to query (defined by the query)
   * @throws ArithmeticException if numeric overflow occurs (defined by the query)
  */
  query<R>(query: TemporalQuery<R>): R;
  /**
   * Formats this date-time using the specified formatter.
   * 
   * This date-time will be passed to the formatter to produce a string.
   * 
   * The default implementation must behave as follows:
   *      *  return formatter.format(this);
   * 
   *
   * @param formatter  the formatter to use, not null
   * @return the formatted date-time string, not null
   * @throws DateTimeException if an error occurs during printing
  */
  format(formatter: DateTimeFormatter): string;
  /**
   * Converts this date-time to an `Instant`.
   * 
   * This returns an `Instant` representing the same point on the
   * time-line as this date-time. The calculation combines the
   * {@linkplain #toLocalDateTime() local date-time} and
   * {@linkplain #getOffset() offset}.
   *
   * @return an `Instant` representing the same instant, not null
  */
  toInstant(): Instant;
  /**
   * Converts this date-time to the number of seconds from the epoch
   * of 1970-01-01T00:00:00Z.
   * 
   * This uses the {@linkplain #toLocalDateTime() local date-time} and
   * {@linkplain #getOffset() offset} to calculate the epoch-second value,
   * which is the number of elapsed seconds from 1970-01-01T00:00:00Z.
   * Instants on the time-line after the epoch are positive, earlier are negative.
   *
   * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z
  */
  toEpochSecond(): number;
  /**
   * Compares this date-time to another date-time, including the chronology.
   * 
   * The comparison is based first on the instant, then on the local date-time,
   * then on the zone ID, then on the chronology.
   * It is "consistent with equals", as defined by {@link Comparable}.
   * 
   * If all the date-time objects being compared are in the same chronology, then the
   * additional chronology stage is not required.
   * 
   * This default implementation performs the comparison defined above.
   *
   * @param other  the other date-time to compare to, not null
   * @return the comparator value, that is the comparison of this with the `other` values for the instant,
   *          the local date-time, the zone ID, and the chronology, in order, returning the first non-zero result,
   *          and otherwise returning zero
   * @see #isBefore
   * @see #isAfter
  */
  compareTo(other: ChronoZonedDateTime<any>): number;
  /**
   * Checks if the instant of this date-time is before that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().isBefore(dateTime2.toInstant());`.
   * 
   * This default implementation performs the comparison based on the epoch-second
   * and nano-of-second.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this point is before the specified date-time
  */
  isBefore(other: ChronoZonedDateTime<any>): boolean;
  /**
   * Checks if the instant of this date-time is after that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} in that it
   * only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().isAfter(dateTime2.toInstant());`.
   * 
   * This default implementation performs the comparison based on the epoch-second
   * and nano-of-second.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if this is after the specified date-time
  */
  isAfter(other: ChronoZonedDateTime<any>): boolean;
  /**
   * Checks if the instant of this date-time is equal to that of the specified date-time.
   * 
   * This method differs from the comparison in {@link #compareTo} and {@link #equals}
   * in that it only compares the instant of the date-time. This is equivalent to using
   * `dateTime1.toInstant().equals(dateTime2.toInstant());`.
   * 
   * This default implementation performs the comparison based on the epoch-second
   * and nano-of-second.
   *
   * @param other  the other date-time to compare to, not null
   * @return true if the instant equals the instant of the specified date-time
  */
  isEqual(other: ChronoZonedDateTime<any>): boolean;
  /**
   * Checks if this date-time is equal to another date-time.
   * 
   * The comparison is based on the offset date-time and the zone.
   * To compare for the same instant on the time-line, use {@link #compareTo}.
   * Only objects of type `ChronoZonedDateTime` are compared, other types return false.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date-time
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date-time.
   *
   * @return a suitable hash code
  */
  hashCode(): number;
  /**
   * Outputs this date-time as a `String`.
   * 
   * The output will include the full zoned date-time.
   *
   * @return a string representation of this date-time, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface ChronoZonedDateTime<D> extends Temporal, Comparable<ChronoZonedDateTime<any>> {}
/**
 * A date in the Japanese Imperial calendar system.
 * 
 * This date operates using the {@linkplain JapaneseChronology Japanese Imperial calendar}.
 * This calendar system is primarily used in Japan.
 * 
 * The Japanese Imperial calendar system is the same as the ISO calendar system
 * apart from the era-based year numbering. The proleptic-year is defined to be
 * equal to the ISO proleptic-year.
 * 
 * Japan introduced the Gregorian calendar starting with Meiji 6.
 * Only Meiji and later eras are supported;
 * dates before Meiji 6, January 1 are not supported.
 * 
 * For example, the Japanese year "Heisei 24" corresponds to ISO year "2012".
 * Calling `japaneseDate.get(YEAR_OF_ERA)` will return 24.
 * Calling `japaneseDate.get(YEAR)` will return 2012.
 * Calling `japaneseDate.get(ERA)` will return 2, corresponding to
 * `JapaneseChronology.ERA_HEISEI`.
 * 
 * This is a value-based
 * class; programmers should treat instances that are
 * {@linkplain #equals(Object) equal} as interchangeable and should not
 * use instances for synchronization, or unpredictable behavior may
 * occur. For example, in a future release, synchronization may fail.
 * The `equals` method should be used for comparisons.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class JapaneseDate extends ChronoLocalDate {
  /**
   * Obtains the current `JapaneseDate` from the system clock in the default time-zone.
   * 
   * This will query the {@link Clock#systemDefaultZone() system clock} in the default
   * time-zone to obtain the current date.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @return the current date using the system clock and default time-zone, not null
  */
  static now(): JapaneseDate;
  /**
   * Obtains the current `JapaneseDate` from the system clock in the specified time-zone.
   * 
   * This will query the {@link Clock#system(ZoneId) system clock} to obtain the current date.
   * Specifying the time-zone avoids dependence on the default time-zone.
   * 
   * Using this method will prevent the ability to use an alternate clock for testing
   * because the clock is hard-coded.
   *
   * @param zone  the zone ID to use, not null
   * @return the current date using the system clock, not null
  */
  static now(zone: ZoneId): JapaneseDate;
  /**
   * Obtains the current `JapaneseDate` from the specified clock.
   * 
   * This will query the specified clock to obtain the current date - today.
   * Using this method allows the use of an alternate clock for testing.
   * The alternate clock may be introduced using {@linkplain Clock dependency injection}.
   *
   * @param clock  the clock to use, not null
   * @return the current date, not null
   * @throws DateTimeException if the current date cannot be obtained
  */
  static now(clock: Clock): JapaneseDate;
  /**
   * Obtains a `JapaneseDate` representing a date in the Japanese calendar
   * system from the era, year-of-era, month-of-year and day-of-month fields.
   * 
   * This returns a `JapaneseDate` with the specified fields.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * 
   * The Japanese month and day-of-month are the same as those in the
   * ISO calendar system. They are not reset when the era changes.
   * For example:
   *      *  6th Jan Showa 64 = ISO 1989-01-06
   *  7th Jan Showa 64 = ISO 1989-01-07
   *  8th Jan Heisei 1 = ISO 1989-01-08
   *  9th Jan Heisei 1 = ISO 1989-01-09
   * 
   *
   * @param era  the Japanese era, not null
   * @param yearOfEra  the Japanese year-of-era
   * @param month  the Japanese month-of-year, from 1 to 12
   * @param dayOfMonth  the Japanese day-of-month, from 1 to 31
   * @return the date in Japanese calendar system, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year,
   *  or if the date is not a Japanese era
  */
  static of(era: JapaneseEra, yearOfEra: number, month: number, dayOfMonth: number): JapaneseDate;
  /**
   * Obtains a `JapaneseDate` representing a date in the Japanese calendar
   * system from the proleptic-year, month-of-year and day-of-month fields.
   * 
   * This returns a `JapaneseDate` with the specified fields.
   * The day must be valid for the year and month, otherwise an exception will be thrown.
   * 
   * The Japanese proleptic year, month and day-of-month are the same as those
   * in the ISO calendar system. They are not reset when the era changes.
   *
   * @param prolepticYear  the Japanese proleptic-year
   * @param month  the Japanese month-of-year, from 1 to 12
   * @param dayOfMonth  the Japanese day-of-month, from 1 to 31
   * @return the date in Japanese calendar system, not null
   * @throws DateTimeException if the value of any field is out of range,
   *  or if the day-of-month is invalid for the month-year
  */
  static of(prolepticYear: number, month: number, dayOfMonth: number): JapaneseDate;
  /**
   * Obtains a `JapaneseDate` from a temporal object.
   * 
   * This obtains a date in the Japanese calendar system based on the specified temporal.
   * A `TemporalAccessor` represents an arbitrary set of date and time information,
   * which this factory converts to an instance of `JapaneseDate`.
   * 
   * The conversion typically uses the {@link ChronoField#EPOCH_DAY EPOCH_DAY}
   * field, which is standardized across calendar systems.
   * 
   * This method matches the signature of the functional interface {@link TemporalQuery}
   * allowing it to be used as a query via method reference, `JapaneseDate::from`.
   *
   * @param temporal  the temporal object to convert, not null
   * @return the date in Japanese calendar system, not null
   * @throws DateTimeException if unable to convert to a `JapaneseDate`
  */
  static from(temporal: TemporalAccessor): JapaneseDate;
  /**
   * Gets the chronology of this date, which is the Japanese calendar system.
   * 
   * The `Chronology` represents the calendar system in use.
   * The era and other fields in {@link ChronoField} are defined by the chronology.
   *
   * @return the Japanese chronology, not null
  */
  get chronology(): JapaneseChronology;
  /**
   * Gets the era applicable at this date.
   * 
   * The Japanese calendar system has multiple eras defined by {@link JapaneseEra}.
   *
   * @return the era applicable at this date, not null
  */
  get era(): JapaneseEra;
  /**
   * Returns the length of the month represented by this date.
   * 
   * This returns the length of the month in days.
   * Month lengths match those of the ISO calendar system.
   *
   * @return the length of the month in days
  */
  lengthOfMonth(): number;
  lengthOfYear(): number;
  /**
   * Checks if the specified field is supported.
   * 
   * This checks if this date can be queried for the specified field.
   * If false, then calling the {@link #range(TemporalField) range} and
   * {@link #get(TemporalField) get} methods will throw an exception.
   * 
   * If the field is a {@link ChronoField} then the query is implemented here.
   * The supported fields are:
   * 
   * `DAY_OF_WEEK`
   * `DAY_OF_MONTH`
   * `DAY_OF_YEAR`
   * `EPOCH_DAY`
   * `MONTH_OF_YEAR`
   * `PROLEPTIC_MONTH`
   * `YEAR_OF_ERA`
   * `YEAR`
   * `ERA`
   * 
   * All other `ChronoField` instances will return false.
   * 
   * If the field is not a `ChronoField`, then the result of this method
   * is obtained by invoking `TemporalField.isSupportedBy(TemporalAccessor)`
   * passing `this` as the argument.
   * Whether the field is supported is determined by the field.
   *
   * @param field  the field to check, null returns false
   * @return true if the field is supported on this date, false if not
  */
  isSupported(field: TemporalField): boolean;
  range(field: TemporalField): ValueRange;
  getLong(field: TemporalField): number;
  with(field: TemporalField, newValue: number): JapaneseDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  with(adjuster: TemporalAdjuster): JapaneseDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  plus(amount: TemporalAmount): JapaneseDate;
  /**
   * {@inheritDoc}
   * @throws DateTimeException {@inheritDoc}
   * @throws ArithmeticException {@inheritDoc}
  */
  minus(amount: TemporalAmount): JapaneseDate;
  plus(amountToAdd: number, unit: TemporalUnit): JapaneseDate;
  minus(amountToSubtract: number, unit: TemporalUnit): JapaneseDate;
  atTime(localTime: LocalTime): ChronoLocalDateTime<JapaneseDate>;
  until(endDate: ChronoLocalDate): ChronoPeriod;
  toEpochDay(): number;
  /**
   * Compares this date to another date, including the chronology.
   * 
   * Compares this `JapaneseDate` with another ensuring that the date is the same.
   * 
   * Only objects of type `JapaneseDate` are compared, other types return false.
   * To compare the dates of two `TemporalAccessor` instances, including dates
   * in two different chronologies, use {@link ChronoField#EPOCH_DAY} as a comparator.
   *
   * @param obj  the object to check, null returns false
   * @return true if this is equal to the other date
  */
  equals(obj: any): boolean;
  /**
   * A hash code for this date.
   *
   * @return a suitable hash code based only on the Chronology and the date
  */
  hashCode(): number;
  /**
   * Checks if the specified unit is supported.
   * 
   * This checks if the specified unit can be added to or subtracted from this date.
   * If false, then calling the {@link #plus(long, TemporalUnit)} and
   * {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
   * 
   * The set of supported units is defined by the chronology and normally includes
   * all `ChronoUnit` date units except `FOREVER`.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.isSupportedBy(Temporal)`
   * passing `this` as the argument.
   * Whether the unit is supported is determined by the unit.
   *
   * @param unit  the unit to check, null returns false
   * @return true if the unit can be added/subtracted, false if not
  */
  isSupported(unit: TemporalUnit): boolean;
  /**
   * Calculates the amount of time until another date in terms of the specified unit.
   * 
   * This calculates the amount of time between two `ChronoLocalDate`
   * objects in terms of a single `TemporalUnit`.
   * The start and end points are `this` and the specified date.
   * The result will be negative if the end is before the start.
   * The `Temporal` passed to this method is converted to a
   * `ChronoLocalDate` using {@link Chronology#date(TemporalAccessor)}.
   * The calculation returns a whole number, representing the number of
   * complete units between the two dates.
   * For example, the amount in days between two dates can be calculated
   * using `startDate.until(endDate, DAYS)`.
   * 
   * There are two equivalent ways of using this method.
   * The first is to invoke this method.
   * The second is to use {@link TemporalUnit#between(Temporal, Temporal)}:
   *      *   // these two lines are equivalent
   *   amount = start.until(end, MONTHS);
   *   amount = MONTHS.between(start, end);
   * 
   * The choice should be made based on which makes the code more readable.
   * 
   * The calculation is implemented in this method for {@link ChronoUnit}.
   * The units `DAYS`, `WEEKS`, `MONTHS`, `YEARS`,
   * `DECADES`, `CENTURIES`, `MILLENNIA` and `ERAS`
   * should be supported by all implementations.
   * Other `ChronoUnit` values will throw an exception.
   * 
   * If the unit is not a `ChronoUnit`, then the result of this method
   * is obtained by invoking `TemporalUnit.between(Temporal, Temporal)`
   * passing `this` as the first argument and the converted input temporal as
   * the second argument.
   * 
   * This instance is immutable and unaffected by this method call.
   *
   * @param endExclusive  the end date, exclusive, which is converted to a
   *  `ChronoLocalDate` in the same chronology, not null
   * @param unit  the unit to measure the amount in, not null
   * @return the amount of time between this date and the end date
   * @throws DateTimeException if the amount cannot be calculated, or the end
   *  temporal cannot be converted to a `ChronoLocalDate`
   * @throws UnsupportedTemporalTypeException if the unit is not supported
   * @throws ArithmeticException if numeric overflow occurs
  */
  until(endExclusive: Temporal, unit: TemporalUnit): number;
}
export interface JapaneseDate extends ChronoLocalDate, Serializable {}

}
declare module 'java.time.zone' {
import { Set, NavigableMap, List } from 'java.util';
import { LocalDateTime, Month, DayOfWeek, DateTimeException, LocalTime, Instant, Duration, ZoneOffset } from 'java.time';
import { Comparable, Throwable } from 'java.lang';
import { Serializable } from 'java.io';
import { ConcurrentMap, CopyOnWriteArrayList } from 'java.util.concurrent';
import { TimeDefinition } from 'java.time.zone.ZoneOffsetTransitionRule';
/**
 * A rule expressing how to create a transition.
 * 
 * This class allows rules for identifying future transitions to be expressed.
 * A rule might be written in many forms:
 * 
 * the 16th March
 * the Sunday on or after the 16th March
 * the Sunday on or before the 16th March
 * the last Sunday in February
 * 
 * These different rule types can be expressed and queried.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ZoneOffsetTransitionRule extends Serializable {
  /**
   * Obtains an instance defining the yearly rule to create transitions between two offsets.
   * 
   * Applications should normally obtain an instance from {@link ZoneRules}.
   * This factory is only intended for use when creating {@link ZoneRules}.
   *
   * @param month  the month of the month-day of the first day of the cutover week, not null
   * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that
   *  day or later, negative if the week is that day or earlier, counting from the last day of the month,
   *  from -28 to 31 excluding 0
   * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed
   * @param time  the cutover time in the 'before' offset, not null
   * @param timeEndOfDay  whether the time is midnight at the end of day
   * @param timeDefinition  how to interpret the cutover
   * @param standardOffset  the standard offset in force at the cutover, not null
   * @param offsetBefore  the offset before the cutover, not null
   * @param offsetAfter  the offset after the cutover, not null
   * @return the rule, not null
   * @throws IllegalArgumentException if the day of month indicator is invalid
   * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight
   * @throws IllegalArgumentException if `time.getNano()` returns non-zero value
  */
  static of(month: Month, dayOfMonthIndicator: number, dayOfWeek: DayOfWeek, time: LocalTime, timeEndOfDay: boolean, timeDefinition: TimeDefinition, standardOffset: ZoneOffset, offsetBefore: ZoneOffset, offsetAfter: ZoneOffset): ZoneOffsetTransitionRule;
  /**
   * Gets the month of the transition.
   * 
   * If the rule defines an exact date then the month is the month of that date.
   * 
   * If the rule defines a week where the transition might occur, then the month
   * if the month of either the earliest or latest possible date of the cutover.
   *
   * @return the month of the transition, not null
  */
  get month(): Month;
  /**
   * Gets the indicator of the day-of-month of the transition.
   * 
   * If the rule defines an exact date then the day is the month of that date.
   * 
   * If the rule defines a week where the transition might occur, then the day
   * defines either the start of the end of the transition week.
   * 
   * If the value is positive, then it represents a normal day-of-month, and is the
   * earliest possible date that the transition can be.
   * The date may refer to 29th February which should be treated as 1st March in non-leap years.
   * 
   * If the value is negative, then it represents the number of days back from the
   * end of the month where `-1` is the last day of the month.
   * In this case, the day identified is the latest possible date that the transition can be.
   *
   * @return the day-of-month indicator, from -28 to 31 excluding 0
  */
  get dayOfMonthIndicator(): number;
  /**
   * Gets the day-of-week of the transition.
   * 
   * If the rule defines an exact date then this returns null.
   * 
   * If the rule defines a week where the cutover might occur, then this method
   * returns the day-of-week that the month-day will be adjusted to.
   * If the day is positive then the adjustment is later.
   * If the day is negative then the adjustment is earlier.
   *
   * @return the day-of-week that the transition occurs, null if the rule defines an exact date
  */
  get dayOfWeek(): DayOfWeek;
  /**
   * Gets the local time of day of the transition which must be checked with
   * {@link #isMidnightEndOfDay()}.
   * 
   * The time is converted into an instant using the time definition.
   *
   * @return the local time of day of the transition, not null
  */
  get localTime(): LocalTime;
  /**
   * Is the transition local time midnight at the end of day.
   * 
   * The transition may be represented as occurring at 24:00.
   *
   * @return whether a local time of midnight is at the start or end of the day
  */
  isMidnightEndOfDay(): boolean;
  /**
   * Gets the time definition, specifying how to convert the time to an instant.
   * 
   * The local time can be converted to an instant using the standard offset,
   * the wall offset or UTC.
   *
   * @return the time definition, not null
  */
  get timeDefinition(): TimeDefinition;
  /**
   * Gets the standard offset in force at the transition.
   *
   * @return the standard offset, not null
  */
  get standardOffset(): ZoneOffset;
  /**
   * Gets the offset before the transition.
   *
   * @return the offset before, not null
  */
  get offsetBefore(): ZoneOffset;
  /**
   * Gets the offset after the transition.
   *
   * @return the offset after, not null
  */
  get offsetAfter(): ZoneOffset;
  /**
   * Creates a transition instance for the specified year.
   * 
   * Calculations are performed using the ISO-8601 chronology.
   *
   * @param year  the year to create a transition for, not null
   * @return the transition instance, not null
  */
  createTransition(year: number): ZoneOffsetTransition;
  /**
   * Checks if this object equals another.
   * 
   * The entire state of the object is compared.
   *
   * @param otherRule  the other object to compare to, null returns false
   * @return true if equal
  */
  equals(otherRule: any): boolean;
  /**
   * Returns a suitable hash code.
   *
   * @return the hash code
  */
  hashCode(): number;
  /**
   * Returns a string describing this object.
   *
   * @return a string for debugging, not null
  */
  toString(): string;
}
/**
 * The rules defining how the zone offset varies for a single time-zone.
 * 
 * The rules model all the historic and future transitions for a time-zone.
 * {@link ZoneOffsetTransition} is used for known transitions, typically historic.
 * {@link ZoneOffsetTransitionRule} is used for future transitions that are based
 * on the result of an algorithm.
 * 
 * The rules are loaded via {@link ZoneRulesProvider} using a {@link ZoneId}.
 * The same rules may be shared internally between multiple zone IDs.
 * 
 * Serializing an instance of `ZoneRules` will store the entire set of rules.
 * It does not store the zone ID as it is not part of the state of this object.
 * 
 * A rule implementation may or may not store full information about historic
 * and future transitions, and the information stored is only as accurate as
 * that supplied to the implementation by the rules provider.
 * Applications should treat the data provided as representing the best information
 * available to the implementation of this rule.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ZoneRules extends Serializable {
  /**
   * Obtains an instance of a ZoneRules.
   *
   * @param baseStandardOffset  the standard offset to use before legal rules were set, not null
   * @param baseWallOffset  the wall offset to use before legal rules were set, not null
   * @param standardOffsetTransitionList  the list of changes to the standard offset, not null
   * @param transitionList  the list of transitions, not null
   * @param lastRules  the recurring last rules, size 16 or less, not null
   * @return the zone rules, not null
  */
  static of(baseStandardOffset: ZoneOffset, baseWallOffset: ZoneOffset, standardOffsetTransitionList: ZoneOffsetTransition[], transitionList: ZoneOffsetTransition[], lastRules: ZoneOffsetTransitionRule[]): ZoneRules;
  /**
   * Obtains an instance of ZoneRules that has fixed zone rules.
   *
   * @param offset  the offset this fixed zone rules is based on, not null
   * @return the zone rules, not null
   * @see #isFixedOffset()
  */
  static of(offset: ZoneOffset): ZoneRules;
  /**
   * Checks of the zone rules are fixed, such that the offset never varies.
   *
   * @return true if the time-zone is fixed and the offset never changes
  */
  isFixedOffset(): boolean;
  /**
   * Gets the offset applicable at the specified instant in these rules.
   * 
   * The mapping from an instant to an offset is simple, there is only
   * one valid offset for each instant.
   * This method returns that offset.
   *
   * @param instant  the instant to find the offset for, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the offset, not null
  */
  getOffset(instant: Instant): ZoneOffset;
  /**
   * Gets a suitable offset for the specified local date-time in these rules.
   * 
   * The mapping from a local date-time to an offset is not straightforward.
   * There are three cases:
   * 
   * Normal, with one valid offset. For the vast majority of the year, the normal
   *  case applies, where there is a single valid offset for the local date-time.
   * Gap, with zero valid offsets. This is when clocks jump forward typically
   *  due to the spring daylight savings change from "winter" to "summer".
   *  In a gap there are local date-time values with no valid offset.
   * Overlap, with two valid offsets. This is when clocks are set back typically
   *  due to the autumn daylight savings change from "summer" to "winter".
   *  In an overlap there are local date-time values with two valid offsets.
   * 
   * Thus, for any given local date-time there can be zero, one or two valid offsets.
   * This method returns the single offset in the Normal case, and in the Gap or Overlap
   * case it returns the offset before the transition.
   * 
   * Since, in the case of Gap and Overlap, the offset returned is a "best" value, rather
   * than the "correct" value, it should be treated with care. Applications that care
   * about the correct offset should use a combination of this method,
   * {@link #getValidOffsets(LocalDateTime)} and {@link #getTransition(LocalDateTime)}.
   *
   * @param localDateTime  the local date-time to query, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the best available offset for the local date-time, not null
  */
  getOffset(localDateTime: LocalDateTime): ZoneOffset;
  /**
   * Gets the offset applicable at the specified local date-time in these rules.
   * 
   * The mapping from a local date-time to an offset is not straightforward.
   * There are three cases:
   * 
   * Normal, with one valid offset. For the vast majority of the year, the normal
   *  case applies, where there is a single valid offset for the local date-time.
   * Gap, with zero valid offsets. This is when clocks jump forward typically
   *  due to the spring daylight savings change from "winter" to "summer".
   *  In a gap there are local date-time values with no valid offset.
   * Overlap, with two valid offsets. This is when clocks are set back typically
   *  due to the autumn daylight savings change from "summer" to "winter".
   *  In an overlap there are local date-time values with two valid offsets.
   * 
   * Thus, for any given local date-time there can be zero, one or two valid offsets.
   * This method returns that list of valid offsets, which is a list of size 0, 1 or 2.
   * In the case where there are two offsets, the earlier offset is returned at index 0
   * and the later offset at index 1.
   * 
   * There are various ways to handle the conversion from a `LocalDateTime`.
   * One technique, using this method, would be:
   *      *  List<ZoneOffset> validOffsets = rules.getValidOffsets(localDT);
   *  if (validOffsets.size() == 1) {
   *    // Normal case: only one valid offset
   *    zoneOffset = validOffsets.get(0);
   *  } else {
   *    // Gap or Overlap: determine what to do from transition (which will be non-null)
   *    ZoneOffsetTransition trans = rules.getTransition(localDT);
   *  }
   * 
   * 
   * In theory, it is possible for there to be more than two valid offsets.
   * This would happen if clocks to be put back more than once in quick succession.
   * This has never happened in the history of time-zones and thus has no special handling.
   * However, if it were to happen, then the list would return more than 2 entries.
   *
   * @param localDateTime  the local date-time to query for valid offsets, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the list of valid offsets, may be immutable, not null
  */
  getValidOffsets(localDateTime: LocalDateTime): ZoneOffset[];
  /**
   * Gets the offset transition applicable at the specified local date-time in these rules.
   * 
   * The mapping from a local date-time to an offset is not straightforward.
   * There are three cases:
   * 
   * Normal, with one valid offset. For the vast majority of the year, the normal
   *  case applies, where there is a single valid offset for the local date-time.
   * Gap, with zero valid offsets. This is when clocks jump forward typically
   *  due to the spring daylight savings change from "winter" to "summer".
   *  In a gap there are local date-time values with no valid offset.
   * Overlap, with two valid offsets. This is when clocks are set back typically
   *  due to the autumn daylight savings change from "summer" to "winter".
   *  In an overlap there are local date-time values with two valid offsets.
   * 
   * A transition is used to model the cases of a Gap or Overlap.
   * The Normal case will return null.
   * 
   * There are various ways to handle the conversion from a `LocalDateTime`.
   * One technique, using this method, would be:
   *      *  ZoneOffsetTransition trans = rules.getTransition(localDT);
   *  if (trans != null) {
   *    // Gap or Overlap: determine what to do from transition
   *  } else {
   *    // Normal case: only one valid offset
   *    zoneOffset = rule.getOffset(localDT);
   *  }
   * 
   *
   * @param localDateTime  the local date-time to query for offset transition, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the offset transition, null if the local date-time is not in transition
  */
  getTransition(localDateTime: LocalDateTime): ZoneOffsetTransition;
  /**
   * Gets the standard offset for the specified instant in this zone.
   * 
   * This provides access to historic information on how the standard offset
   * has changed over time.
   * The standard offset is the offset before any daylight saving time is applied.
   * This is typically the offset applicable during winter.
   *
   * @param instant  the instant to find the offset information for, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the standard offset, not null
  */
  getStandardOffset(instant: Instant): ZoneOffset;
  /**
   * Gets the amount of daylight savings in use for the specified instant in this zone.
   * 
   * This provides access to historic information on how the amount of daylight
   * savings has changed over time.
   * This is the difference between the standard offset and the actual offset.
   * Typically the amount is zero during winter and one hour during summer.
   * Time-zones are second-based, so the nanosecond part of the duration will be zero.
   * 
   * This default implementation calculates the duration from the
   * {@link #getOffset(java.time.Instant) actual} and
   * {@link #getStandardOffset(java.time.Instant) standard} offsets.
   *
   * @param instant  the instant to find the daylight savings for, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the difference between the standard and actual offset, not null
  */
  getDaylightSavings(instant: Instant): Duration;
  /**
   * Checks if the specified instant is in daylight savings.
   * 
   * This checks if the standard offset and the actual offset are the same
   * for the specified instant.
   * If they are not, it is assumed that daylight savings is in operation.
   * 
   * This default implementation compares the {@link #getOffset(java.time.Instant) actual}
   * and {@link #getStandardOffset(java.time.Instant) standard} offsets.
   *
   * @param instant  the instant to find the offset information for, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the standard offset, not null
  */
  isDaylightSavings(instant: Instant): boolean;
  /**
   * Checks if the offset date-time is valid for these rules.
   * 
   * To be valid, the local date-time must not be in a gap and the offset
   * must match one of the valid offsets.
   * 
   * This default implementation checks if {@link #getValidOffsets(java.time.LocalDateTime)}
   * contains the specified offset.
   *
   * @param localDateTime  the date-time to check, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @param offset  the offset to check, null returns false
   * @return true if the offset date-time is valid for these rules
  */
  isValidOffset(localDateTime: LocalDateTime, offset: ZoneOffset): boolean;
  /**
   * Gets the next transition after the specified instant.
   * 
   * This returns details of the next transition after the specified instant.
   * For example, if the instant represents a point where "Summer" daylight savings time
   * applies, then the method will return the transition to the next "Winter" time.
   *
   * @param instant  the instant to get the next transition after, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the next transition after the specified instant, null if this is after the last transition
  */
  nextTransition(instant: Instant): ZoneOffsetTransition;
  /**
   * Gets the previous transition before the specified instant.
   * 
   * This returns details of the previous transition before the specified instant.
   * For example, if the instant represents a point where "summer" daylight saving time
   * applies, then the method will return the transition from the previous "winter" time.
   *
   * @param instant  the instant to get the previous transition after, not null, but null
   *  may be ignored if the rules have a single offset for all instants
   * @return the previous transition before the specified instant, null if this is before the first transition
  */
  previousTransition(instant: Instant): ZoneOffsetTransition;
  /**
   * Gets the complete list of fully defined transitions.
   * 
   * The complete set of transitions for this rules instance is defined by this method
   * and {@link #getTransitionRules()}. This method returns those transitions that have
   * been fully defined. These are typically historical, but may be in the future.
   * 
   * The list will be empty for fixed offset rules and for any time-zone where there has
   * only ever been a single offset. The list will also be empty if the transition rules are unknown.
   *
   * @return an immutable list of fully defined transitions, not null
  */
  get transitions(): ZoneOffsetTransition[];
  /**
   * Gets the list of transition rules for years beyond those defined in the transition list.
   * 
   * The complete set of transitions for this rules instance is defined by this method
   * and {@link #getTransitions()}. This method returns instances of {@link ZoneOffsetTransitionRule}
   * that define an algorithm for when transitions will occur.
   * 
   * For any given `ZoneRules`, this list contains the transition rules for years
   * beyond those years that have been fully defined. These rules typically refer to future
   * daylight saving time rule changes.
   * 
   * If the zone defines daylight savings into the future, then the list will normally
   * be of size two and hold information about entering and exiting daylight savings.
   * If the zone does not have daylight savings, or information about future changes
   * is uncertain, then the list will be empty.
   * 
   * The list will be empty for fixed offset rules and for any time-zone where there is no
   * daylight saving time. The list will also be empty if the transition rules are unknown.
   *
   * @return an immutable list of transition rules, not null
  */
  get transitionRules(): ZoneOffsetTransitionRule[];
  /**
   * Checks if this set of rules equals another.
   * 
   * Two rule sets are equal if they will always result in the same output
   * for any given input instant or local date-time.
   * Rules from two different groups may return false even if they are in fact the same.
   * 
   * This definition should result in implementations comparing their entire state.
   *
   * @param otherRules  the other rules, null returns false
   * @return true if this rules is the same as that specified
  */
  equals(otherRules: any): boolean;
  /**
   * Returns a suitable hash code given the definition of `#equals`.
   *
   * @return the hash code
  */
  hashCode(): number;
  /**
   * Returns a string describing this object.
   *
   * @return a string for debugging, not null
  */
  toString(): string;
}
/**
 * A transition between two offsets caused by a discontinuity in the local time-line.
 * 
 * A transition between two offsets is normally the result of a daylight savings cutover.
 * The discontinuity is normally a gap in spring and an overlap in autumn.
 * `ZoneOffsetTransition` models the transition between the two offsets.
 * 
 * Gaps occur where there are local date-times that simply do not exist.
 * An example would be when the offset changes from `+03:00` to `+04:00`.
 * This might be described as 'the clocks will move forward one hour tonight at 1am'.
 * 
 * Overlaps occur where there are local date-times that exist twice.
 * An example would be when the offset changes from `+04:00` to `+03:00`.
 * This might be described as 'the clocks will move back one hour tonight at 2am'.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
*/
export class ZoneOffsetTransition extends Comparable<ZoneOffsetTransition> {
  /**
   * Obtains an instance defining a transition between two offsets.
   * 
   * Applications should normally obtain an instance from {@link ZoneRules}.
   * This factory is only intended for use when creating {@link ZoneRules}.
   *
   * @param transition  the transition date-time at the transition, which never
   *  actually occurs, expressed local to the before offset, not null
   * @param offsetBefore  the offset before the transition, not null
   * @param offsetAfter  the offset at and after the transition, not null
   * @return the transition, not null
   * @throws IllegalArgumentException if `offsetBefore` and `offsetAfter`
   *         are equal, or `transition.getNano()` returns non-zero value
  */
  static of(transition: LocalDateTime, offsetBefore: ZoneOffset, offsetAfter: ZoneOffset): ZoneOffsetTransition;
  /**
   * Gets the transition instant.
   * 
   * This is the instant of the discontinuity, which is defined as the first
   * instant that the 'after' offset applies.
   * 
   * The methods {@link #getInstant()}, {@link #getDateTimeBefore()} and {@link #getDateTimeAfter()}
   * all represent the same instant.
   *
   * @return the transition instant, not null
  */
  get instant(): Instant;
  /**
   * Gets the transition instant as an epoch second.
   *
   * @return the transition epoch second
  */
  toEpochSecond(): number;
  /**
   * Gets the local transition date-time, as would be expressed with the 'before' offset.
   * 
   * This is the date-time where the discontinuity begins expressed with the 'before' offset.
   * At this instant, the 'after' offset is actually used, therefore the combination of this
   * date-time and the 'before' offset will never occur.
   * 
   * The combination of the 'before' date-time and offset represents the same instant
   * as the 'after' date-time and offset.
   *
   * @return the transition date-time expressed with the before offset, not null
  */
  get dateTimeBefore(): LocalDateTime;
  /**
   * Gets the local transition date-time, as would be expressed with the 'after' offset.
   * 
   * This is the first date-time after the discontinuity, when the new offset applies.
   * 
   * The combination of the 'before' date-time and offset represents the same instant
   * as the 'after' date-time and offset.
   *
   * @return the transition date-time expressed with the after offset, not null
  */
  get dateTimeAfter(): LocalDateTime;
  /**
   * Gets the offset before the transition.
   * 
   * This is the offset in use before the instant of the transition.
   *
   * @return the offset before the transition, not null
  */
  get offsetBefore(): ZoneOffset;
  /**
   * Gets the offset after the transition.
   * 
   * This is the offset in use on and after the instant of the transition.
   *
   * @return the offset after the transition, not null
  */
  get offsetAfter(): ZoneOffset;
  /**
   * Gets the duration of the transition.
   * 
   * In most cases, the transition duration is one hour, however this is not always the case.
   * The duration will be positive for a gap and negative for an overlap.
   * Time-zones are second-based, so the nanosecond part of the duration will be zero.
   *
   * @return the duration of the transition, positive for gaps, negative for overlaps
  */
  get duration(): Duration;
  /**
   * Does this transition represent a gap in the local time-line.
   * 
   * Gaps occur where there are local date-times that simply do not exist.
   * An example would be when the offset changes from `+01:00` to `+02:00`.
   * This might be described as 'the clocks will move forward one hour tonight at 1am'.
   *
   * @return true if this transition is a gap, false if it is an overlap
  */
  isGap(): boolean;
  /**
   * Does this transition represent an overlap in the local time-line.
   * 
   * Overlaps occur where there are local date-times that exist twice.
   * An example would be when the offset changes from `+02:00` to `+01:00`.
   * This might be described as 'the clocks will move back one hour tonight at 2am'.
   *
   * @return true if this transition is an overlap, false if it is a gap
  */
  isOverlap(): boolean;
  /**
   * Checks if the specified offset is valid during this transition.
   * 
   * This checks to see if the given offset will be valid at some point in the transition.
   * A gap will always return false.
   * An overlap will return true if the offset is either the before or after offset.
   *
   * @param offset  the offset to check, null returns false
   * @return true if the offset is valid during the transition
  */
  isValidOffset(offset: ZoneOffset): boolean;
  /**
   * Compares this transition to another based on the transition instant.
   * 
   * This compares the instants of each transition.
   * The offsets are ignored, making this order inconsistent with equals.
   *
   * @param otherTransition  the transition to compare to, not null
   * @return the comparator value, that is the comparison of this transition instant
   *          with `otherTransition` instant
  */
  compareTo(otherTransition: ZoneOffsetTransition): number;
  /**
   * Checks if this object equals another.
   * 
   * The entire state of the object is compared.
   *
   * @param other  the other object to compare to, null returns false
   * @return true if equal
  */
  equals(other: any): boolean;
  /**
   * Returns a suitable hash code.
   *
   * @return the hash code
  */
  hashCode(): number;
  /**
   * Returns a string describing this object.
   *
   * @return a string for debugging, not null
  */
  toString(): string;
  /**
   * Compares this object with the specified object for order.  Returns a
   * negative integer, zero, or a positive integer as this object is less
   * than, equal to, or greater than the specified object.
   *
   * The implementor must ensure {@link Integer#signum
   * signum}`(x.compareTo(y)) == -signum(y.compareTo(x))` for
   * all `x` and `y`.  (This implies that `     * x.compareTo(y)` must throw an exception if and only if `     * y.compareTo(x)` throws an exception.)
   *
   * The implementor must also ensure that the relation is transitive:
   * `(x.compareTo(y) > 0 && y.compareTo(z) > 0)` implies
   * `x.compareTo(z) > 0`.
   *
   * Finally, the implementor must ensure that `     * x.compareTo(y)==0` implies that {@code signum(x.compareTo(z))
   * == signum(y.compareTo(z))}, for all `z`.
   *
   * @apiNote
   * It is strongly recommended, but not strictly required that
   * `(x.compareTo(y)==0) == (x.equals(y))`.  Generally speaking, any
   * class that implements the `Comparable` interface and violates
   * this condition should clearly indicate this fact.  The recommended
   * language is "Note: this class has a natural ordering that is
   * inconsistent with equals."
   *
   * @param   o the object to be compared.
   * @return  a negative integer, zero, or a positive integer as this object
   *          is less than, equal to, or greater than the specified object.
   *
   * @throws NullPointerException if the specified object is null
   * @throws ClassCastException if the specified object's type prevents it
   *         from being compared to this object.
  */
  compareTo(o: T): number;
}
export interface ZoneOffsetTransition extends Comparable<ZoneOffsetTransition>, Serializable {}
/**
 * Thrown to indicate a problem with time-zone configuration.
 * 
 * This exception is used to indicate a problems with the configured
 * time-zone rules.
 *
 * @implSpec
 * This class is intended for use in a single thread.
 *
 * @since 1.8
*/
export class ZoneRulesException extends DateTimeException {
  /**
   * Constructs a new date-time exception with the specified message.
   *
   * @param message  the message to use for this exception, may be null
  */
  constructor(message: string);
  /**
   * Constructs a new date-time exception with the specified message and cause.
   *
   * @param message  the message to use for this exception, may be null
   * @param cause  the cause of the exception, may be null
  */
  constructor(message: string, cause: Throwable);
}
/**
 * Provider of time-zone rules to the system.
 * 
 * This class manages the configuration of time-zone rules.
 * The static methods provide the public API that can be used to manage the providers.
 * The abstract methods provide the SPI that allows rules to be provided.
 * 
 * ZoneRulesProvider may be installed in an instance of the Java Platform as
 * extension classes, that is, jar files placed into any of the usual extension
 * directories. Installed providers are loaded using the service-provider loading
 * facility defined by the {@link ServiceLoader} class. A ZoneRulesProvider
 * identifies itself with a provider configuration file named
 * `java.time.zone.ZoneRulesProvider` in the resource directory
 * `META-INF/services`. The file should contain a line that specifies the
 * fully qualified concrete zonerules-provider class name.
 * Providers may also be made available by adding them to the class path or by
 * registering themselves via {@link #registerProvider} method.
 * 
 * The Java virtual machine has a default provider that provides zone rules
 * for the time-zones defined by IANA Time Zone Database (TZDB). If the system
 * property {@systemProperty java.time.zone.DefaultZoneRulesProvider} is defined then
 * it is taken to be the fully-qualified name of a concrete ZoneRulesProvider
 * class to be loaded as the default provider, using the system class loader.
 * If this system property is not defined, a system-default provider will be
 * loaded to serve as the default provider.
 * 
 * Rules are looked up primarily by zone ID, as used by {@link ZoneId}.
 * Only zone region IDs may be used, zone offset IDs are not used here.
 * 
 * Time-zone rules are political, thus the data can change at any time.
 * Each provider will provide the latest rules for each zone ID, but they
 * may also provide the history of how the rules changed.
 *
 * @implSpec
 * This interface is a service provider that can be called by multiple threads.
 * Implementations must be immutable and thread-safe.
 * 
 * Providers must ensure that once a rule has been seen by the application, the
 * rule must continue to be available.
 * 
 * Providers are encouraged to implement a meaningful `toString` method.
 * 
 * Many systems would like to update time-zone rules dynamically without stopping the JVM.
 * When examined in detail, this is a complex problem.
 * Providers may choose to handle dynamic updates, however the default provider does not.
 *
 * @since 1.8
*/
export class ZoneRulesProvider {
  /**
   * Gets the set of available zone IDs.
   * 
   * These IDs are the string form of a {@link ZoneId}.
   *
   * @return the unmodifiable set of zone IDs, not null
  */
  static get availableZoneIds(): Set<string>;
  /**
   * Gets the rules for the zone ID.
   * 
   * This returns the latest available rules for the zone ID.
   * 
   * This method relies on time-zone data provider files that are configured.
   * These are loaded using a `ServiceLoader`.
   * 
   * The caching flag is designed to allow provider implementations to
   * prevent the rules being cached in `ZoneId`.
   * Under normal circumstances, the caching of zone rules is highly desirable
   * as it will provide greater performance. However, there is a use case where
   * the caching would not be desirable, see {@link #provideRules}.
   *
   * @param zoneId the zone ID as defined by `ZoneId`, not null
   * @param forCaching whether the rules are being queried for caching,
   * true if the returned rules will be cached by `ZoneId`,
   * false if they will be returned to the user without being cached in `ZoneId`
   * @return the rules, null if `forCaching` is true and this
   * is a dynamic provider that wants to prevent caching in `ZoneId`,
   * otherwise not null
   * @throws ZoneRulesException if rules cannot be obtained for the zone ID
  */
  static getRules(zoneId: string, forCaching: boolean): ZoneRules;
  /**
   * Gets the history of rules for the zone ID.
   * 
   * Time-zones are defined by governments and change frequently.
   * This method allows applications to find the history of changes to the
   * rules for a single zone ID. The map is keyed by a string, which is the
   * version string associated with the rules.
   * 
   * The exact meaning and format of the version is provider specific.
   * The version must follow lexicographical order, thus the returned map will
   * be order from the oldest known rules to the newest available rules.
   * The default 'TZDB' group uses version numbering consisting of the year
   * followed by a letter, such as '2009e' or '2012f'.
   * 
   * Implementations must provide a result for each valid zone ID, however
   * they do not have to provide a history of rules.
   * Thus the map will always contain one element, and will only contain more
   * than one element if historical rule information is available.
   *
   * @param zoneId  the zone ID as defined by `ZoneId`, not null
   * @return a modifiable copy of the history of the rules for the ID, sorted
   *  from oldest to newest, not null
   * @throws ZoneRulesException if history cannot be obtained for the zone ID
  */
  static getVersions(zoneId: string): NavigableMap<string,ZoneRules>;
  /**
   * Registers a zone rules provider.
   * 
   * This adds a new provider to those currently available.
   * A provider supplies rules for one or more zone IDs.
   * A provider cannot be registered if it supplies a zone ID that has already been
   * registered. See the notes on time-zone IDs in {@link ZoneId}, especially
   * the section on using the concept of a "group" to make IDs unique.
   * 
   * To ensure the integrity of time-zones already created, there is no way
   * to deregister providers.
   *
   * @param provider  the provider to register, not null
   * @throws ZoneRulesException if a zone ID is already registered
  */
  static registerProvider(provider: ZoneRulesProvider): void;
  /**
   * Refreshes the rules from the underlying data provider.
   * 
   * This method allows an application to request that the providers check
   * for any updates to the provided rules.
   * After calling this method, the offset stored in any {@link ZonedDateTime}
   * may be invalid for the zone ID.
   * 
   * Dynamic update of rules is a complex problem and most applications
   * should not use this method or dynamic rules.
   * To achieve dynamic rules, a provider implementation will have to be written
   * as per the specification of this class.
   * In addition, instances of `ZoneRules` must not be cached in the
   * application as they will become stale. However, the boolean flag on
   * {@link #provideRules(String, boolean)} allows provider implementations
   * to control the caching of `ZoneId`, potentially ensuring that
   * all objects in the system see the new rules.
   * Note that there is likely to be a cost in performance of a dynamic rules
   * provider. Note also that no dynamic rules provider is in this specification.
   *
   * @return true if the rules were updated
   * @throws ZoneRulesException if an error occurs during the refresh
  */
  static refresh(): boolean;
}

}
